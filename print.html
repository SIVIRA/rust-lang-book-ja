<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>プログラミング言語 Rust</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="foreword.html">前書き</a></li><li class="affix"><a href="ch00-00-introduction.html">導入</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 入門</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 数当てゲームをプログラムする</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> プログラミングの共通概念</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と変更可能性</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数の動作</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 制御フロー</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権について</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とはなにか？</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関係のあるデータを構造化する</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使用したプログラム例</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumとパターンマッチング</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match制御フロー演算子</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letによる簡潔な制御フロー</a></li></ol></li><li><a href="ch07-00-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> パッケージ、クレート、モジュール</a></li><li><ol class="section"><li><a href="ch07-01-packages-and-crates-for-making-libraries-and-executables.html"><strong aria-hidden="true">7.1.</strong> ライブラリと実行可能ファイルを作成するためのパッケージとクレート</a></li><li><a href="ch07-02-modules-and-use-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> スコープとプライバシーを制御するモジュールシステム</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 共通コレクション</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> vectorで一連の値を保持する</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8でエンコードされた文字列を格納する</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 関連付けられた値を持つキーをhash mapに格納する</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト: 共通の振る舞いを定義する</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を有効化する</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> テスト</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストを書く</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストを走らせる</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト: コマンドラインプログラムを構築する</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoを拡張する</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects that Allow for Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li><li><a href="ch19-06-macros.html"><strong aria-hidden="true">19.6.</strong> Macros</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning our Single Threaded Server into a Multithreaded Server</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">プログラミング言語 Rust</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#a前書き" id="a前書き"><h1>前書き</h1></a>
<p>すぐにはわかりにくいかもしれませんが、Rustプログラミング言語は、*エンパワーメント(empowerment)*を根本原理としています。どんな種類のコードを現在書いているにせよ、Rustは幅広い領域で以前よりも遠くへ到達し、自信を持ってプログラムを組む力を与えます。</p>
<p>一例を挙げると、メモリ管理やデータ表現、並列性などの低レベルな詳細を扱う「システムレベル」のプログラミングがあります。伝統的にこの分野は難解で、年月をかけてやっかいな落とし穴を回避する術を習得した選ばれし者にだけ可能と見なされています。そのように鍛錬を積んだ者でさえ注意が必要で、さもないと書いたコードがクラッキングの糸口になったりクラッシュやデータ破損を引き起こしかねないのです。</p>
<p>この難しさを取り除くために、Rustは古い落とし穴を排除し、その過程で使いやすく役に立つ洗練された一連のツールを提供します。低レベルな制御に「下がる」必要があるプログラマは、お決まりのクラッシュやセキュリティホールのリスクを負わず、気まぐれなツールチェーンのデリケートな部分を学ぶ必要なくRustで同じことができます。さらにいいことに、Rustは、スピードとメモリ使用の観点で効率的な信頼性の高いコードへと自然に導くよう設計されています。</p>
<p>既に低レベルコードに取り組んでいるプログラマは、Rustを使用してさらなる高みを目指せます。例えば、Rustで並行性を導入することは、比較的低リスクです。コンパイラが伝統的なミスを捕捉してくれるからです。そして、クラッシュやクラッキングの糸口を誤って導入しないという自信を持ってコードの大胆な最適化に取り組めるのです。</p>
<p>ですが、Rustは低レベルなシステムプログラミングに限定されているわけではありません。十分に表現力豊かでエルゴノミックなので、コマンドラインアプリやWebサーバ、その他様々な楽しいコードを書けます。この本の後半に両者の単純な例が見つかるでしょう。Rustを使うことで1つの領域から他の領域へと使い回せる技術を身につけられます。ウェブアプリを書いてRustを学び、それからその同じ技術をラズベリーパイを対象に適用できるのです。</p>
<p>この本は、ユーザに力を与え(empower)るRustのポテンシャルを全て含んでいます。あなたのRustの知識のみをレベルアップさせるだけでなく、プログラマとして全般的な能力や自信をもレベルアップさせる手助けを意図した親しみやすくわかりやすいテキストです。さあ、飛び込んで学ぶ準備をしてください。Rustコミュニティへようこそ！</p>
<p>ニコラス・マットサキス(Nicholas Matsakis)とアーロン・チューロン(Aaron Turon)</p>
<a class="header" href="#aはじめに" id="aはじめに"><h1>はじめに</h1></a>
<p>Rustについての入門書、<em>The Rust Programming Language</em>へようこそ。Rustプログラミング言語は、より高速で信頼性の高いソフトウェアの作成に役立ちます。高水準の人間工学と低レベルの制御は、しばしばプログラミング言語の設計において偶然です。Rustはその競合に挑戦します。強力なバランスをとることで技術的な能力と優れた開発者経験を持つRustは、あなたにオプションを提供します。すべての手間をかけずに（例えば、メモリ使用量などの）低レベルの詳細を制御します。</p>
<a class="header" href="#a誰が必要とするのか" id="a誰が必要とするのか"><h2>誰が必要とするのか</h2></a>
<p>Rustはさまざまな理由から多くの人々にとって理想的です。最も重要なグループのいくつかを見てみましょう。</p>
<a class="header" href="#a開発チームにとって" id="a開発チームにとって"><h3>開発チームにとって</h3></a>
<p>Rustはさまざまなレベルのシステムプログラミング知識を持つ大規模な開発者チーム間のコラボレーションのための生産的なツールであることが証明されています。低レベルのコードでは、さまざまな微妙なバグが発生する可能性があります。これは、他の多くの言語では、経験豊かな開発者による広範なテストと慎重なコードレビューによってしか検出できません。Rustでは、コンパイラは次のことを拒否してゲートキーパーの役割を果たします。
並行性のバグを含むこれらの難解なバグをコードをコンパイルします。コンパイラと一緒に作業することで、チームはバグを追い出すのではなく、プログラムのロジックに集中して時間を費やすことができます。</p>
<p>Rustは現代の開発ツールをシステムプログラミングの世界にももたらします。</p>
<ul>
<li>付属の依存マネージャーとビルドツールであるCargoは、Rustエコシステム全体で、無痛で一貫性のある依存関係の追加、コンパイル、および管理を行います。</li>
<li>Rustfmtは開発者間で一貫したコーディングスタイルを保証します。</li>
<li>TRust Language Serverはコード補完とインラインエラーメッセージの統合開発環境（IDE）の統合を実現します。</li>
</ul>
<p>Rustエコシステムでこれらのツールや他のツールを使用することで、開発者はシステムレベルのコードを書く際に生産性を高めることができます。</p>
<a class="header" href="#a学生にとって" id="a学生にとって"><h3>学生にとって</h3></a>
<p>Rustは学生やシステムコンセプトの学習に興味のある人のためのものです。Rustを使用して、オペレーティングシステム開発のようなトピックについて多くの人が学びました。コミュニティは非常に歓迎しており、学生の疑問に答えることができます。この本のような努力を通して、Rustチームは、より多くの人々、特にプログラミングに新しいシステムコンセプトにアクセスしやすくしたいと考えています。</p>
<a class="header" href="#a会社にとって" id="a会社にとって"><h3>会社にとって</h3></a>
<p>大小さまざまな企業がさまざまな作業のために生産でRustを使用しています。これらのタスクには、コマンドラインツール、Webサービス、DevOpsツール、組み込みデバイス、オーディオとビデオの分析とトランスコード、暗号化通信、バイオインフォマティクス、検索エンジン、IoTアプリケーション、機械学習、Firefox Webブラウザの主要部分が含まれます。</p>
<a class="header" href="#aオープンソース開発者にとって" id="aオープンソース開発者にとって"><h3>オープンソース開発者にとって</h3></a>
<p>Rustは、Rustプログラミング言語、コミュニティ、開発者ツール、およびライブラリを構築したい人向けです。私たちはあなたにRust言語に貢献してもらいたいです。</p>
<a class="header" href="#aスピードと安定性を重視する人々にとって" id="aスピードと安定性を重視する人々にとって"><h3>スピードと安定性を重視する人々にとって</h3></a>
<p>Rustは言語のスピードと安定性を求めている人のためのものです。 スピードとは、Rustで作成できるプログラムのスピードとRustで書き込みできるスピードです。 Rustコンパイラのチェックは、機能の追加やリファクタリングによる安定性を保証します。 これは、これらのチェックがない言語の脆弱なレガシーコードとは対照的であり、開発者はしばしば変更することを恐れている。 手動で書かれたコードと同じくらい速く低レベルのコードにコンパイルする高レベルの機能をゼロコストの抽象化に努めて、Rustは安全なコードを高速なコードにするよう努めています。</p>
<p>Rust言語は他の多くのユーザーもサポートしたいと考えています。ここに挙げたものは、最大の利害関係者の一部にすぎません。 全体として、Rustの最大の野望は、安全性と生産性、スピードと人間工学を提供することにより、プログラマが何十年も受け入れてきたトレードオフを排除することです。その選択があなたのために働くかどうか試してみてください。</p>
<a class="header" href="#aこの本の対象者" id="aこの本の対象者"><h2>この本の対象者</h2></a>
<p>この本は、あなたが別のプログラミング言語でコードを書いたことを前提としていますが、どちらのプログラミング言語についても何も仮定していません。私たちは、幅広いプログラミングの背景にある人々が幅広くアクセスできるようにしました。私たちはプログラミングが何であるか、それについてどのように考えているかについて話すのに多くの時間を費やすことはありません。あなたがプログラミングに全く触れていないなら、プログラミングの入門書を特別に読んでいる本を読むことでより効果的です。</p>
<a class="header" href="#aこの本の使い方" id="aこの本の使い方"><h2>この本の使い方</h2></a>
<p>一般的に、この本はあなたが前から後に順にそれを読んでいることを前提としています。後の章では、以前の章の概念を基にしています。以前の章では、トピックの詳細を掘り下げていないかもしれません。我々は、通常、後の章でそのトピックを再訪します。</p>
<p>この本では、概念の章とプロジェクトの章の2種類の章があります。概念の章では、Rustの側面について学びます。 プロジェクトの章では、これまでに学んだことを応用して、小さなプログラムをまとめていきます。第2章、第12章、第20章はプロジェクトの章です。残りは概念の章です。</p>
<p>第1章では、Rustをインストールする方法、Hello Worldを書く方法について説明します。Cargo、Rustのパッケージマネージャーとビルドツールを使用する方法について説明します。第2章では、Rust言語の手引きを紹介します。ここでは概念を高レベルでカバーし、後の章では詳細を説明します。すぐに手を動かしたければ、第2章がその場所です。最初は、他のプログラミング言語と同様のRust機能を扱う第3章はスキップし、Rustの所有システムについては第4章を参照してください。しかし、あなたが次のものに進む前にすべての詳細を学ぶことを好む特に細心のある学習者ならば、第2章をスキップし、第3章に進み、第2章に戻り、プロジェクトは、あなたが学んだ詳細を適用します。</p>
<p>第5章では構造体とメソッドについて説明し、第6章ではenum、 <code>match</code>式、 <code>if let</code>制御フローの構造について説明します。 構造体と列挙型を使用して、Rustでカスタム型を作成します。</p>
<p>第7章では、Rustのモジュールシステムとコードとその公開API（Application Programming Interface）の整理に関するプライバシー規則について学びます。第8章ではベクトル、文字列、hash mapなど、標準ライブラリが提供する共通のコレクションデータ構造について説明します。第9章ではRustのエラー処理の哲学とテクニックについて解説します。</p>
<p>第10章では、generics、traits、およびライフタイムについて説明します。これにより、複数のタイプに適用されるコードを定義する権限が与えられます。第11章はすべてテストに関するもので、プログラムのロジックが正しいことを保証するためにRustの安全保証が必要な場合でもあります。第12章では、ファイル内のテキストを検索する<code>grep</code>コマンドラインツールから、独自の機能の実装を構築します。このために、前の章で説明した概念の多くを使用します。</p>
<p>第13章では関数型プログラミング言語に由来するRustの機能であるクロージャとイテレータについて説明します。第14章では、
ライブラリを他の人と共有するためのベストプラクティスについて深く説明します。
第15章では標準ライブラリが提供するスマートポインタとその機能を有効にする特徴について説明します。</p>
<p>第16章では並行プログラミングのさまざまなモデルを紹介し、Rustが複数のスレッドで勇敢にプログラムするのに役立つ方法について説明します。第17章ではRustイディオムとあなたが慣れ親しんでいるオブジェクト指向プログラミングの原理との比較を説明します。</p>
<p>第18章ではパターンとパターンのマッチングについて説明します。これはRustプログラム全体でアイデアを表現する強力な方法です。第19章では、安全でないRust、マクロ、ライフサイクル、トレイト、型、関数、クロージャなどの高度なトピックを紹介します。</p>
<p>第20章では低レベルのマルチスレッドWebサーバーを実装するプロジェクトを完成させます。</p>
<p>最後にいくつかの付録には言語についてのより有用な情報がリファレンスのような形式で含まれています。Appendix AはRustのキーワード、Appendix BはRustの演算子と記号、Appendix Cは標準ライブラリで提供される微分特性、付録Dは有用な開発ツール、Appendix EはRustエディションを説明しています。</p>
<p>この本を読むための全く間違った方法はありません：あなたはスキップしたい場合はそうしてください！
あなたが任意の混乱が発生した場合は、以前の章に戻ってジャンプする必要がある場合があります。</p>
<p><span id="ferris"></span></p>
<p>Rustを学ぶプロセスの重要な部分は、コンパイラが表示するエラーメッセージを読む方法を学ぶことです。これらは作業コードに向かってあなたを導くでしょう。 したがって、コンパイラが各状況で表示されるエラーメッセージとともにコンパイルされないコードの例を多数提供します。 ランダムな例を入力して実行すると、コンパイルされないことがあります。 周囲のテキストを読んで、実行しようとしている例がエラーであるかどうかを確認してください。 Ferrisは、動作しないコードを区別するのにも役立ちます。</p>
<table><thead><tr><th> Ferris                                                                 </th><th> Meaning                                          </th></tr></thead><tbody>
<tr><td> <img src="img/ferris/does_not_compile.svg" class="ferris-explain">     </td><td> このコードはコンパイルされません！</td></tr>
<tr></tr>
<tr><td> <img src="img/ferris/panics.svg" class="ferris-explain">               </td><td> このコードはpanics!                                </td></tr>
<tr><td> <img src="img/ferris/unsafe.svg" class="ferris-explain">               </td><td> このコードブロックには安全でないコードが含まれています</td></tr>
<tr></tr>
<tr><td> <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"> </td><td> このコードは、期待通りの動作をしません</td></tr>
<tr></tr>
</tbody></table>
<p>ほとんどの場合、コンパイルされないコードの正しいバージョンに導くでしょう。</p>
<a class="header" href="#aソースコード" id="aソースコード"><h2>ソースコード</h2></a>
<p>この本が生成されたソースファイルは<a href="https://github.com/SIVIRA/rust-lang-book-ja/tree/translation/src-ja">GitHub</a>にあります。</p>
<a class="header" href="#a入門" id="a入門"><h1>入門</h1></a>
<p>この章では、次の内容について説明します。</p>
<ul>
<li>Linux、macOS、およびWindowsにRustをインストールする</li>
<li><code>Hello, world!</code>を表示するプログラムを書く</li>
<li><code>cargo</code>を使ってRustのパッケージマネージャーとビルドシステム</li>
</ul>
<a class="header" href="#aインストール" id="aインストール"><h2>インストール</h2></a>
<p>最初のステップは、Rustをインストールすることです。Rustバージョンと関連ツールを管理するためのコマンドラインツールである <code>rustup</code>を通じてRustをダウンロードします。ダウンロードにはインターネット接続が必要です。</p>
<blockquote>
<p>注：何らかの理由で <code>rustup</code>を使用したくない場合は、<a href="https://www.rust-lang.org/install.html">Rustのインストールページ</a> でその他のオプションを確認してください。</p>
</blockquote>
<p>以下の手順で最新の安定バージョンのRustコンパイラをインストールします。Rustの安定性は、コンパイルされた本のすべての例が新しいRustバージョンでコンパイルされ続けることを保証します。Rustはエラーメッセージと警告を改善することが多いため、出力はバージョンによって若干異なる場合があります。言い換えれば、これらの手順を使用してインストールする新しい、安定版のRustは、この本の内容で期待どおりに動作するはずです。</p>
<blockquote>
<a class="header" href="#aコマンドライン表記法" id="aコマンドライン表記法"><h3>コマンドライン表記法</h3></a>
<p>この章と本では、端末で使用されるコマンドをいくつか示します。端末に入力する行はすべて <code>$</code>で始まります。<code>$</code>文字を入力する必要はありません。<code>$</code>は各コマンドの開始を示します。<code>$</code>で始まらない行は通常、前のコマンドの出力を示します。さらに、PowerShell固有の例では<code>$</code>ではなく<code>&gt;</code>が使用されます。</p>
</blockquote>
<a class="header" href="#linuxやmacosにrustupをインストールする" id="linuxやmacosにrustupをインストールする"><h3>LinuxやmacOSに<code>rustup</code>をインストールする</h3></a>
<p>LinuxまたはmacOSを使用している場合は、端末を開いて次のコマンドを入力します。</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>このコマンドはスクリプトをダウンロードして、Rustの最新の安定バージョンをインストールするrustupツールのインストールを開始します。 パスワードの入力を求めるメッセージが表示される場合があります。インストールが成功すると、次の行が表示されます。</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>必要に応じて、実行する前にスクリプトをダウンロードして検査してください。</p>
<p>インストールスクリプトは、次回のログイン後にシステムPATHに自動的にRustを追加します。端末を再起動する代わりにRustをすぐに使用したい場合は、シェルで次のコマンドを実行して、システムPATHにRustを手動で追加します。</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>あるいは*~/.bash_profile*に次の行を追加することもできます</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<p>さらに、何らかのリンカーが必要です。既にインストールされている可能性がありますが、Rustプログラムをコンパイルしてリンカが実行できないというエラーが表示された場合は、システムにリンカがインストールされていないことを意味し、手動でインストールする必要があります。Cコンパイラには通常、適切なリンカが付属しています。Cコンパイラーのインストール方法については、ご使用のプラットフォームの資料を参照してください。また、いくつかの一般的なRustパッケージはCコードに依存しており、Cコンパイラが必要になります。したがって、今すぐインストールする価値があります。</p>
<a class="header" href="#windowsへのインストール" id="windowsへのインストール"><h3>Windowsへのインストール</h3></a>
<p>Windowsでは、<a href="https://www.rust-lang.org/install.html">https://www.rust-lang.org/install.html</a>にアクセスし、Rustのインストール手順に従ってください。インストールのある時点で、Visual Studio 2013以降のC ++ビルドツールも必要であることを示すメッセージが表示されます。ビルドツールを入手する最も簡単な方法は、<a href="https://www.visualstudio.com/downloads/">Visual Studio 2017用のビルドツール</a>をインストールすることです。ツールはその他のツールとフレームワークセクションにあります。</p>
<p>この本の残りの部分では、<em>cmd.exe</em>とPowerShellの両方で動作するコマンドを使用します。具体的な相違点がある場合は、どちらを使用するかを説明します。</p>
<a class="header" href="#a更新とアンインストール" id="a更新とアンインストール"><h3>更新とアンインストール</h3></a>
<p>Rustを <code>rustup</code>経由でインストールした後、最新バージョンへの更新は簡単です。 シェルから、次の更新スクリプトを実行します。</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<p>Rustと <code>rustup</code>をアンインストールするには、シェルから以下のアンインストールスクリプトを実行します</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="#aトラブルシューティング" id="aトラブルシューティング"><h3>トラブルシューティング</h3></a>
<p>Rustが正しくインストールされているかどうかを確認するには、シェルを開いてこの行を入力します</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>次の形式でリリースされた最新の安定版のバージョン番号、コミットハッシュ、およびコミット日付が表示されます</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>この情報が表示されたら、Rustを正常にインストールしました。この情報が表示されず、Windowsの場合は、％PATH％システム変数にRustがあることを確認してください。それでも問題ないのですが、まだRustが働いていない場合は、助けとなる場所がたくさんあります。最も簡単なのはirc.mozilla.orgの<a href="irc://irc.mozilla.org/#rust">#rust IRCチャンネル</a><!-- ignore -->で、<a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>からアクセスできます。そのアドレスで、あなたを助けることができる他のラスト開発者とチャットすることができます。その他の素晴らしいリソースには、<a href="https://users.rust-lang.org/">Usersフォーラム</a>や<a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>などがあります。</p>
<a class="header" href="#aローカルドキュメント" id="aローカルドキュメント"><h3>ローカルドキュメント</h3></a>
<p>インストーラーには、ドキュメンテーションのコピーもローカルに含まれているため、オフラインで読むことができます。<code>rustup doc</code>を実行してブラウザのローカルドキュメントを開きます。</p>
<p>標準ライブラリによって型または関数が提供され、その動作や使用方法がわからない場合は、アプリケーションプログラミングインターフェイス（API）のドキュメントを参照してください。</p>
<a class="header" href="#hello-world" id="hello-world"><h2>Hello, World!</h2></a>
<p>Rustをインストールしたので、最初のRustプログラムを作成しましょう。 テキスト<code>Hello、world</code>を出力する小さなプログラムを書くために新しい言語を学ぶときは伝統的です。画面に表示されるので、ここでも同じことをします！</p>
<blockquote>
<p>注意：このマニュアルでは、コマンドラインについての基本的な知識があることを前提としています。Rustは、編集やツーリング、コードが存在する場所について特別な要求をしないので、コマンドラインの代わりに統合開発環境（IDE）を使用する場合は、好きなIDEを自由に使用してください。多くのIDEは、ある程度のRustをサポートしています。詳細は、IDEのドキュメントを参照してください。最近、Rustチームは素晴らしいIDEサポートを可能にすることに重点を置いており、その前進が急速に進んでいます！</p>
</blockquote>
<a class="header" href="#aプロジェクトディレクトリの作成" id="aプロジェクトディレクトリの作成"><h3>プロジェクトディレクトリの作成</h3></a>
<p>まず、Rustコードを格納するディレクトリを作成します。 コードがどこにあるのかは問題ではありませんが、この本の演習とプロジェクトでは、ホームディレクトリに<em>projects</em>ディレクトリを作成し、そこにすべてのプロジェクトを保存することをお勧めします。</p>
<p>ターミナルを開き、次のコマンドを入力して、<em>projects</em>ディレクトリ内の Hello、world！の<em>projects</em>ディレクトリとディレクトリを作成します。</p>
<p>LinuxおよびmacOSの場合は、次のように入力します。</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows CMDの場合は、次のように入力します。</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<p>Windows PowerShellの場合は、次のように入力します。</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projects
&gt; cd $env:USERPROFILE\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<a class="header" href="#rustプログラムの作成と実行" id="rustプログラムの作成と実行"><h3>Rustプログラムの作成と実行</h3></a>
<p>次に、新しいソースファイルを作成し、<em>main.rs</em>という名前にします。
Rustファイルは常に* .rs <em>拡張子で終わります。ファイル名に複数の単語を使用する場合は、アンダースコアを使用して単語を区切ります。たとえば、<em>helloworld.rs</em>ではなく</em>hello_world.rs*を使用します。</p>
<p>今作成した*main.rs&quot;*ファイルを開き、リスト1-1のコードを入力します。</p>
<p><span class="filename">ファイル名: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">リスト 1-1: <code>Hello World!</code>を出力するプログラム</span></p>
<p>ファイルを保存して、ターミナルウィンドウに戻ります。 LinuxまたはmacOSの場合は、次のコマンドを入力してファイルをコンパイルして実行します。</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>Windowsの場合、 <code>./main</code>の代わりに<code>.\main.exe</code>コマンドを入力してください。</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>オペレーティングシステムにかかわらず、<code>Hello、world!</code>という文字列がターミナルに出力されるはずです。この出力が表示されない場合は、インストールのセクションの「トラブルシューティング」の部分に戻って、ヘルプを入手する方法を参照してください。</p>
<p>「Hello World!」が出力された場合成功です。あなたは正式にRustプログラムを書いています。これであなたはRusプログラマーです。</p>
<a class="header" href="#rustプログラムの解説" id="rustプログラムの解説"><h3>Rustプログラムの解説</h3></a>
<p><code>Hello、world!</code>プログラムで何が起こったかを詳しく見てみましょう。パズルの最初の部分は次のとおりです。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>これらの行は、Rustの関数を定義します。<code>main</code>関数は特別で、常に実行可能なすべてのRustプログラムで実行される最初のコードです。最初の行は、引数を持たず、何も返さない<code>main</code>という名前の関数を宣言しています。引数があれば、それらは<code>()</code>の中に入り ます。</p>
<p>また、関数本体は<code>{}</code>の中括弧で囲まれています。Rustはすべての関数本体の周りにこれらを必要とします。関数の宣言と同じ行に中かっこを配置し、宣言との間にスペースを1つ追加するのは良いスタイルです。</p>
<p>この執筆時点では、<code>rustfmt</code>という自動フォーマッタツールが開発中です。Rustプロジェクト全体で標準スタイルに固執したい場合、<code>rustfmt</code>はコードを特定のスタイルでフォーマットします。 Rustチームは、このツールに<code>rustc</code>のような標準のRustディストリビューションを追加する予定です。 あなたがこの本を読んだときには、コンピュータにすでにインストールされているかもしれません。詳細については、オンラインドキュメントを参照してください。</p>
<p><code>main</code>関数の中には次のコードがあります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<p>この行は、この小さなプログラムのすべての作業を行います。スクリーンにテキストを出力します。ここで注意すべき4つの重要な詳細があります。</p>
<p>まず、Rustスタイルは、タブではなく4つのスペースでインデントすることです。</p>
<p>次に、<code>println!</code>はRustマクロを呼び出します。代わりに関数を呼び出すと、<code>println</code>(<code>!</code>なし)として入力されます。Rustマクロについては、第19章でより詳しく説明します。今のところ、<code>!</code>を使用することは、通常の関数の代わりにマクロを呼び出すことを意味するだけです。</p>
<p>３つ目はあなたは<code>&quot;Hello, world!&quot;</code>という文字列を見ることができます。この文字列を<code>println!</code>の引数として渡し、文字列を画面に出力します。</p>
<p>第4に、セミコロン(<code>;</code>)で行を終了します。これは、この式が終了し、次の式が開始する準備ができていることを示します。ほとんどの行のRustコードはセミコロンで終わります。</p>
<a class="header" href="#aコンパイルと実行は別々の手順です" id="aコンパイルと実行は別々の手順です"><h3>コンパイルと実行は別々の手順です</h3></a>
<p>新しく作成したプログラムを実行しただけなので、そのプロセスの各ステップを調べてみましょう。</p>
<p>Rustプログラムを実行する前に、<code>rustc</code>のコマンドの引数にソースファイルの名前を渡し、Rustコンパイラを使ってコンパイルする必要があります。</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>CまたはC++のバックグラウンドを持っているなら、これは<code>gcc</code>や<code>clang</code>に似ていることに気付くでしょう。コンパイルが正常に終了すると、Rustはバイナリ実行可能ファイルを出力します。</p>
<p>LinuxおよびmacOSでは、以下のようにシェルに<code>ls</code>コマンドを入力して、実行可能ファイルを確認することができます。</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>Windows上のPowerShellでは<code>ls</code>も使用できますが、3つのファイルが表示されます</p>
<pre><code class="language-text">&gt; ls


    Directory: Path:\to\the\project


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----         6/1/2018   7:31 AM         137728 main.exe
-a----         6/1/2018   7:31 AM        1454080 main.pdb
-a----         6/1/2018   7:31 AM             14 main.rs
</code></pre>
<p>WindowsでCMDを使用する場合は、次のように入力します。</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>これは、<em>.rs</em>拡張子を持つソースコードファイル、実行可能ファイル（Windowsでは<em>main.exe</em>、他のすべてのプラットフォームでは<em>main</em>）、およびCMDを使用する場合は拡張子*.pdb<em>のデバッグ情報を含むファイルを示しています。ここから</em>main<em>や</em>main.exe*ファイルを実行します。</p>
<pre><code class="language-text">$ ./main # or .\main.exe on Windows
</code></pre>
<p><em>main.rs</em>があなたの <code>Hello, world!</code>プログラムであれば、この行はターミナルに<code>Hello, world!</code>を出力します。</p>
<p>Ruby、Python、JavaScriptなどの動的言語に慣れている場合は、プログラムをコンパイルして別の手順として実行することに慣れていない可能性があります。Rustは<em>事前コンパイラ</em>言語です。つまり、プログラムをコンパイルして実行可能ファイルを他の人に与えることができ、Rustをインストールしなくても実行できます。誰かに*.rb*、<em>.py</em>、または*.js*ファイルを与える場合は、Ruby、Python、またはJavaScriptの実装をそれぞれインストールする必要があります。しかし、これらの言語では、プログラムをコンパイルして実行するためのコマンドが1つだけ必要です。すべてが言語デザインのトレードオフです。</p>
<p><code>rustc</code>でコンパイルするのは簡単なプログラムでは問題ありませんが、プロジェクトが成長するにつれて、すべてのオプションを管理してコードを簡単に共有したいと思うでしょう。次に実際のRustプログラムを書くのに役立つCargoツールを紹介します。</p>
<a class="header" href="#hello-cargo" id="hello-cargo"><h2>Hello, Cargo!</h2></a>
<p>CargoはRustのビルドシステムとパッケージマネージャーです。ほとんどのRust開発者はこのツールを使ってRustプロジェクトを管理しています。Cargoはコードの構築、コードが依存するライブラリのダウンロード、それらのライブラリの構築など、多くのタスクを処理するためです（コードが必要とするライブラリを<em>依存関係</em>と呼びます）。</p>
<p>これまでに書いたような最も単純なRustプログラムは、依存関係を持ちません。そのため、Hello World! Cargoプロジェクトでは、コードの作成を担当する部分のみCargoを使用します。もっと複雑なRustプログラムを書くと、依存関係が追加され、Cargoを使用してプロジェクトを開始すると、依存関係を追加する方がはるかに簡単になります。</p>
<p>Rustプロジェクトの大部分はCargoを使用しているため、この本の残りの部分では、Cargoも使用していると仮定しています。「インストール」セクションで説明した公式のインストーラを使用した場合、CargoにはRustがインストールされます。他の方法でRustをインストールした場合、Cargoがインストールされているかどうかは、端末に次のように入力して確認してください。</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>バージョン番号が表示されている場合は、インストールされています。<code>command not found</code>などのエラーが表示された場合は、インストール方法に関するドキュメントを参照して、Cargoを個別にインストールしてください。</p>
<a class="header" href="#cargoでプロジェクト作成" id="cargoでプロジェクト作成"><h3>Cargoでプロジェクト作成</h3></a>
<p>Cargoを使用して新しいプロジェクトを作成し、元のHello、world！プロジェクトとどのように違うのかを見てみましょう。<em>projects</em>ディレクトリ（またはコードを保存することに決めた場所）に戻ります。次に、すべてのオペレーティングシステムで次のコマンドを実行します。</p>
<pre><code class="language-text">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>最初のコマンドは、<em>hello_cargo</em>という新しいディレクトリを作成します。 プロジェクト<em>hello_cargo</em>に名前を付け、Cargoは同じ名前のディレクトリにファイルを作成します。</p>
<p><em>hello_cargo</em>ディレクトリに移動し、ファイルを一覧表示します。Cargoが2つのファイルと1つのディレクトリ（<em>Cargo.toml</em>ファイルと<em>main.rs</em>ファイルのある<em>src</em>ディレクトリ）を生成したことがわかります。また、<em>.gitignore</em>ファイルとともに新しいGitリポジトリを初期化しました。</p>
<blockquote>
<p>注意：Gitは一般的なバージョン管理システムです。<code>cargo new</code>を<code>--vcs</code>フラグを使って別のバージョン管理システムを使うか、バージョン管理システムを使わないように変更することができます。<code>cargo new --help</code>を実行すると利用可能なオプションが表示されます。</p>
</blockquote>
<p>選択したテキストエディタでCargo.tomlを開きます。<em>リスト1-2</em>のコードに似ているはずです。
<span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p><span class="caption">リスト 1-2: <code>cargo new</code>によって生成された<em>Cargo.toml</em>の内容</span></p>
<p>このファイルは、Cargoの設定形式である[<em>TOML</em>][toml]<!-- ignore --> （<em>Tom's Obvious、Minimal Language</em>）形式です。
[toml]: https://github.com/toml-lang/toml</p>
<p>最初の行<code>[package]</code>は、次の文がパッケージを構成していることを示すセクション見出しです。このファイルに情報を追加すると、他のセクションも追加されます。</p>
<p>次の4行は、プログラムをコンパイルするためにCargoが必要とする構成情報（名前、バージョン、およびそれを書いた人）を設定します。Cargoはお使いの環境から名前とemail情報を取得します。その情報が正しくない場合は、ここで情報を修正してからファイルを保存してください。Appendix Eの<code>edition</code>キーについてお話します。</p>
<p>最後の行<code>[dependencies]</code>は、プロジェクトの依存関係のリストを表示するセクションの先頭です。Rustでは、コードのパッケージは<em>クレート</em>と呼ばれます。このプロジェクトでは他のクレートは必要ありませんが、第2章の最初のプロジェクトではこの依存関係のセクションを使用します。</p>
<p><em>src/main.rs</em>を開いて見てください。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargoはリスト1-1で書いたのと同じように<code>Hello, world!</code>プログラムを生成しました。これまでのプロジェクトとCargoプロジェクトの違いは、Cargoが<em>src</em>ディレクトリにコードを配置し、<em>Cargo.toml</em>構成ファイルがトップディレクトリにあることです。</p>
<p>Cargoはソースファイルが<em>src</em>ディレクトリ内に存在することを期待しています。トップレベルのプロジェクトディレクトリは、READMEファイル、ライセンス情報、設定ファイル、およびコードに関係のないその他のものです。Cargoを使用すると、プロジェクトを整理するのに役立ちます。</p>
<p><code>Hello, world!</code>のように、Cargoを使用しないプロジェクトを開始した場合 それをCargoを使用するプロジェクトに変換することができます。プロジェクトコードを<em>src</em>ディレクトリに移動し、適切な<em>Cargo.toml</em>ファイルを作成します。</p>
<a class="header" href="#cargoプロジェクトのビルドと実行" id="cargoプロジェクトのビルドと実行"><h3>Cargoプロジェクトのビルドと実行</h3></a>
<p>さあ、Cargoで<code>Hello, world!</code>プログラムを構築して実行すると、何が違うのか見てみましょう。<em>hello_cargo</em>ディレクトリから、次のコマンドを入力してプロジェクトをビルドします。</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>このコマンドは、現在のディレクトリではなく、<em>target/debug/hello_cargo</em>（Windowsでは<em>target\debug\hello_cargo.exe</em>）に実行可能ファイルを作成します。このコマンドで実行可能ファイルを実行することができます。</p>
<pre><code class="language-text">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>すべてうまくいけば、<code>Hello, world!</code>がターミナルに出力されるはずです。<code>cargo build</code>を初めて実行すると、Cargoはトップレベルで新しい<em>Cargo.lock</em>というファイルを作成します。このファイルはプロジェクトの依存関係の正確なバージョンを追跡します。このプロジェクトは依存関係がないので、ファイルは少しだけです。手動でこのファイルを変更する必要はありません。Cargoはその内容を管理します。</p>
<p><code>cargo build</code>を使ってプロジェクトをビルドし、<code>./target/debug/hello_cargo</code>で実行しましたが、<code>cargo run</code>を使ってコードをコンパイルし、実行可能なすべての実行可能ファイルを一つのコマンドで実行することもできます。</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>今回は、Cargoが <code>hello_cargo</code>をコンパイルしていることを示す出力が表示されなかったことに注目してください。Cargoはファイルが変更されていないことを知ったので、バイナリを実行しました。ソースコードを変更した場合、Cargoはプロジェクトを実行する前にプロジェクトを再構築しています。この出力は次のようになります。</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargoには、<code>Cargo check</code>というコマンドもあります。このコマンドは、コードがコンパイルされているかどうかをすぐにチェックしますが、実行可能ファイルは生成しません。</p>
<pre><code class="language-text">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>なぜ実行可能ファイルを生成しないほうがよいのでしょうか？実行可能ファイルを生成するステップをスキップするので、<code>cargo check</code>は<code>cargo build</code>よりもはるかに高速です。コードを書いている間、作業を絶えずチェックしているなら、<code>cargo check</code>を使ってプロセスをスピードアップしましょう。このように、多くのRust開発者は定期的に<code>cargo check</code>を行い、コンパイルを確実にするためにプログラムを書きます。実行可能ファイルを使用する準備ができたら、<code>cargo build</code>を実行します。</p>
<p>これまでにCargoについて学んだことをまとめます</p>
<ul>
<li><code>cargo build</code>や<code>cargo check</code>を使用してプロジェクトを構築することができます。</li>
<li><code>cargo run</code>を使ってプロジェクトをビルドして1つのステップで実行することができます。</li>
<li>ビルド結果をコードと同じディレクトリに保存する代わりに、Cargoは<em>target/debug</em>ディレクトリに格納します。</li>
</ul>
<p>Cargoを使用することのもう一つの利点は、作業しているオペレーティングシステムに関係なくコマンドが同じであることです。そのため、LinuxとmacOS、Windowsのための具体的な手順は提供しなくなります。</p>
<a class="header" href="#aリリース" id="aリリース"><h3>リリース</h3></a>
<p>プロジェクトが最終的にリリース準備が整ったら、<code>cargo build --release</code>を使って最適化してコンパイルすることができます。このコマンドは、<em>target/debug</em>の代わりに<em>target/release</em>に実行可能ファイルを作成します。最適化によってRustコードはより速く実行されますが、プログラムをコンパイルするのにかかる時間が長くなります。これは、2つの異なるプロファイルがあります。1つは開発用で迅速かつ頻繁にリビルドすることが可能で、もう1つは繰り返しリビルドされない最終的なプログラム用です。コードの実行時間をベンチマークしているならば、<code>cargo build --release</code>を実行し、<em>target/release</em>の実行ファイルでベンチマークしてください。</p>
<a class="header" href="#a条約としてのcargo" id="a条約としてのcargo"><h3>条約としてのCargo</h3></a>
<p>単純なプロジェクトでは、Cargoは<code>rustc</code>を使用するだけでは価値がありませんが、プログラムが複雑になるにつれてその価値は証明されます。 複数のcratesで構成される複雑なプロジェクトでは、Cargoがビルドを調整するのがずっと簡単です。</p>
<p><code>hello_cargo</code>プロジェクトはシンプルですが、Rustの残りの仕事で使う本当のツールの多くを使います。実際、既存のプロジェクトを操作するには、次のコマンドを使用してGitを使ってコードをチェックアウトし、そのプロジェクトのディレクトリに変更してビルドします。</p>
<pre><code class="language-text">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Cargoの詳細については、<a href="https://doc.rust-lang.org/cargo/">ドキュメント</a>を参照してください。</p>
<a class="header" href="#aまとめ" id="aまとめ"><h2>まとめ</h2></a>
<p>すでにRustの素晴らしいスタートを切ることができています。この章では、以下の方法を学習しました。</p>
<ul>
<li><code>rustup</code>を使って最新の安定版Rustをインストールしてください</li>
<li>新しいRustバージョンへのアップデート</li>
<li>ローカルにインストールされたドキュメントを開く</li>
<li>Hello world!を作成して<code>rustc</code>を直接使って実行する</li>
<li>Cargoを使用して新しいプロジェクトを作成して実行する</li>
</ul>
<p>これは、Rustのコードの読み書きに慣れるためのより充実したプログラムを構築する素晴らしい時間です。したがって、第2章では、数あてゲームプログラムを作成します。Rustで一般的なプログラミングの概念がどのように機能するかを学ぶことから始める場合は、第3章を参照してから第2章に戻ります。</p>
<a class="header" href="#a数当てゲームをプログラムする" id="a数当てゲームをプログラムする"><h1>数当てゲームをプログラムする</h1></a>
<p>実践的なプロジェクトを一緒に進めて、Rustに飛び込みましょう＞この章では、実際のプログラムでそれらを使用する方法を示すことによって、いくつかの一般的なRustの概念を紹介します。<code>let</code>、<code>match</code>、メソッド、関連する関数、外部クレートの使用などについて学習します。以下の章では、これらのアイデアについて詳しく説明します。この章では、基本を練習します。</p>
<p>古典的な初心者プログラミングの問題を実装します。数あてゲームです。これはどのように動作するのでしょうか？プログラムは1から100の間のランダムな整数を生成します。次に、予想を入力するようプレーヤーに促します。予想が入力されると、予想が低すぎるか高すぎるかを示すプログラムが表示されます。予想が正しい場合、ゲームは祝福メッセージを出力して終了します。</p>
<a class="header" href="#a新しいプロジェクトを設定する" id="a新しいプロジェクトを設定する"><h2>新しいプロジェクトを設定する</h2></a>
<p>新しいプロジェクトを設定するには、第1章で作成した<em>projects</em>ディレクトリに移動し、Cargoを使用して新しいプロジェクトを作成します。</p>
<pre><code class="language-text">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>最初のコマンド <code>cargo new</code>は、プロジェクトの名前（<code>guessing_game</code>）を最初の引数として取ります。2番目のコマンドは新しいプロジェクトのディレクトリに移動します。</p>
<p>生成された<em>Cargo.toml</em>ファイルを見てください。</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Cargoが環境から取得した著者情報が正しくない場合は、ファイルに修正してもう一度保存してください。</p>
<p>第1章でみたように、<code>cargo new</code>は&quot;Hello, world!&quot;プログラムを生成します。<em>src/main.rs</em>ファイルをチェックしてください。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>今度はこの&quot;Hello, world!&quot;プログラムをコンパイルして、<code>cargo run</code>コマンドを使って同じステップで実行しましょう。</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p><code>run</code>コマンドは、このゲームでやっているように、プロジェクトを迅速に反復する必要があるときに、すぐに各反復をテストして次のものに移る必要があるときに便利です。</p>
<p><em>src/main.rs</em>ファイルを再度開きます。このファイルにすべてのコードを記述します。</p>
<a class="header" href="#a数あてゲームの処理をする" id="a数あてゲームの処理をする"><h2>数あてゲームの処理をする</h2></a>
<p>数あてゲームプログラムの最初の部分は、ユーザーの入力を求め、その入力を処理し、入力が予想される形式であることを確認します。まず、プレイヤーに予想を入力させます。リスト2-1のコードを<em>src/main.rs</em>に入力します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">リスト 2-1: ユーザーからの予想を取得して出力するコード</span></p>
<p>このコードには多くの情報が含まれていますので、行ごとに説明しましょう。ユーザー入力を取得し、その結果を出力として出力するには、 <code>io</code>（入出力）ライブラリをスコープに持っていく必要があります。<code>io</code>ライブラリは標準ライブラリ（<code>std</code>として知られています）からきています。</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>デフォルトでは、Rustは<a href="../../std/prelude/index.html">prelude</a><!-- ignore -->内のすべてのプログラムの範囲にわずかなタイプしか持ちません。使用する型がpreludeにない場合は、そのタイプを<code>use</code>ステートメントで明示的にスコープに入れる必要があります。<code>std::io</code>ライブラリを使うと、ユーザの入力を受け入れることを含む多くの便利な機能が提供されます。</p>
<p>第1章で見たように、main関数はプログラムへの入り口です。</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p><code>fn</code>構文は新しい関数を宣言し、<code>()</code>は引数がないことを示し、<code>{</code>は関数の本体を開始します。</p>
<p>第1章で学んだように、<code>println!</code>は文字列を画面に表示するマクロです。</p>
<pre><code class="language-rust ignore">println!(&quot;Guess the number!&quot;);

println!(&quot;Please input your guess.&quot;);
</code></pre>
<p>このコードはゲームが何であるかを示すプロンプトを表示し、ユーザーからの入力を要求しています。</p>
<a class="header" href="#a値を変数に格納する" id="a値を変数に格納する"><h3>値を変数に格納する</h3></a>
<p>次に、次のようにユーザー入力を格納する場所を作成します。</p>
<pre><code class="language-rust ignore">let mut guess = String::new();
</code></pre>
<p>これは <code>let</code>文であり、<em>変数</em>の作成に使用されていることに注目してください。別の例があります。</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>この行は<code>foo</code>という名前の新しい変数を作成し、それを<code>bar</code>変数の値にバインドします。Rustでは変数はデフォルトでは不変です。この概念については、第3章の「変数と可変性」のセクションで詳しく説明します。次の例は、変数名の前に<code>mut</code>を使用して変数を可変にする方法を示しています。</p>
<pre><code class="language-rust ignore">let foo = 5; // 不変
let mut bar = 5; // 可変
</code></pre>
<blockquote>
<p>注：//構文は、行末まで続くコメントを開始します。Rustはコメントのすべてを無視します。
これについては第3章で詳しく説明します。</p>
</blockquote>
<p>次の行は<code>let mut guess</code>が<code>guess</code>という変数を定義します。等号(<code>=</code>)の反対側には、<code>guess</code>がバインドされている値があります。これは<code>String::new</code>を呼び出す結果で、<code>String</code>の新しいインスタンスを返す関数です。<a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore -->は標準ライブラリが提供する文字列型で、拡張可能なUTF-8でエンコードされたテキストです。</p>
<p><code>::new</code>行の<code>::</code>構文は、<code>new</code>が<code>String</code>型の<em>関連関数</em>であることを示します。関連関数は、Stringの特定のインスタンスではなく、型(この場合は<code>String</code>)で実装されます。いくつかの言語はこれを<em>staticメソッド</em>と呼びます。</p>
<p>この<code>new</code>関数は、空の新しい文字列を作成します。多くの型の中に<code>new</code>関数があります。なぜなら、ある種の新しい値を作る関数の一般的な名前だからです。</p>
<p>要約すると、 <code>let mut guess = String::new();</code>行は現在、<code>String</code>の新しい空のインスタンスにバインドされている変数を作成しました。</p>
<p>プログラムの最初の行に<code>use std::io;</code>という標準ライブラリの入出力機能が含まれていることを思い出してください。ここで<code>io</code>に関連する関数<code>stdin</code>を呼び出します：</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>もしプログラムの先頭に<code>use std::io</code>行がなければ、この関数呼び出しを<code>std::io::stdin</code>と書くことができました。<code>stdin</code>関数は、端末の標準入力へのハンドルを表す型である<a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->のインスタンスを返します。</p>
<p>コードの次の部分である<code>.read_line(&amp;mut guess)</code>は、ユーザからの入力を得るために標準入力ハンドルの<a href="../../std/io/struct.Stdin.html#method.read_line">read_line</a><!-- ignore -->メソッドを呼び出します。<code>read_line</code>の引数に<code>&amp;mut guess</code>を渡しています。</p>
<p><code>read_line</code>の役割は、ユーザが標準入力に入力したものをそのまま文字列に入れて、その文字列を引数として取ることです。文字列引数は変更可能である必要があり、メソッドはユーザー入力を追加して文字列の内容を変更できます。</p>
<p><code>&amp;</code>は、この引数が<em>参照</em>であることを示します。コードの複数の部分がそのデータを複数回メモリにコピーする必要なしに1つのデータにアクセスできるようにします。参照は複雑な機能であり、Rustの主な利点の1つは、参照を使用することがどれほど安全で簡単なのかです。このプログラムを終了するために多くの詳細を知る必要はありません。この時点で知る必要があるのは、同じ変数の場合、参照はデフォルトでは不変であるということです。したがって、<code>&amp;guess</code>ではなく<code>＆mut guess</code>を書き換えて変更可能にする必要があります（第4章では、参照をより詳しく説明します）。</p>
<a class="header" href="#result型による潜在的な障害の処理" id="result型による潜在的な障害の処理"><h3><code>Result</code>型による潜在的な障害の処理</h3></a>
<p>このコード行ではあまり成し遂げられていません。これまで説明してきたのは1行のテキストですが、これは単一の論理的なコード行の最初の部分にすぎません。2番目の部分はこのメソッドです。</p>
<pre><code class="language-rust ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<p><code>.foo()</code>構文でメソッドを呼び出すときには、長い行を分割するのに役立つ改行やその他の空白を導入することが賢明です。このコードを次のように書くことができました：</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>しかし、1つの長い行は読みにくいので、分割することをお勧めします。2つのメソッド呼び出しの2行です。
さて、この行が何をしているかについて話しましょう。</p>
<p>先に述べたように<code>read_line</code>は、渡している文字列にユーザーが入力したものを入れますが、この場合は<a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->型の値も返します。Rustには標準ライブラリに<code>Result</code>という名前のいくつかの型があります。一般的な<a href="../../std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->と<code>io::Result</code>のようなサブモジュールの特定バージョンです。</p>
<p><code>Result</code>型は、<em>列挙型</em><a href="ch06-00-enums.html">enums</a><!-- ignore -->です。列挙型は固定値のセットを持つことができる型であり、その値は列挙型の<em>バリアント</em>と呼ばれます。第6章では列挙型について詳しく説明します。</p>
<p><code>Result</code>の場合、バリアントは<code>Ok</code>か<code>Err</code>です。<code>Ok</code>は操作が成功したことを示し、<code>Ok</code>の内部は正常に生成された値です。<code>Err</code>は操作が失敗したことを意味し、<code>Err</code>は操作の失敗の理由や理由についての情報を含んでいます。</p>
<p>これらの<code>Result</code>型の目的は、エラー処理情報をエンコードすることです。<code>Result</code>型の値は、どんな型と同様、それらに定義されたメソッドを持っています。<code>io::Result</code>のインスタンスには、呼び出すことができる<a href="../../std/result/enum.Result.html#method.expect"><code>expect</code>メソッド</a><!-- ignore -->があります。<code>io::Result</code>のこのインスタンスが<code>Err</code>の値なら、<code>expect</code>はプログラムがクラッシュし、<code>expect</code>に引数として渡したメッセージを表示します。<code>read_line</code>メソッドが<code>Err</code>を返した場合、それは基礎となるオペレーティングシステムからのエラーの結果である可能性があります。<code>io::Result</code>のこのインスタンスが<code>Ok</code>の値なら、<code>expect</code>は<code>Ok</code>が保持している戻り値をとり、その値だけを返します。この場合、その値はユーザーが標準入力に入力したバイト数です。</p>
<p><code>expect</code>を呼び出さなければ、プログラムはコンパイルされますが警告が表示されます。</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rustは<code>read_line</code>から返された<code>Result</code>を使用していないことを警告します。これはプログラムがエラーを処理しなかったことを示しています。</p>
<p>警告を抑制する正しい方法は、実際にエラー処理を書くことですが、問題が発生したときにこのプログラムをクラッシュさせたいので、<code>expect</code>を使うことができます。エラーからの回復については、第9章で学習します。</p>
<a class="header" href="#printlnで値を表示するプレースホルダ" id="printlnで値を表示するプレースホルダ"><h3><code>println!</code>で値を表示するプレースホルダ</h3></a>
<p>これまでに追加されたコードではさらに議論すべき行が1つあります。</p>
<pre><code class="language-rust ignore">println!(&quot;You guessed: {}&quot;, guess);
</code></pre>
<p>この行はユーザーの入力を保存した文字列を表示します。<code>{}</code>はプレースホルダです。値を保持する小さなカニの挟み込みを<code>{}</code>と考えます。中括弧を使用して複数の値を出力することができます。中括弧の最初のセットは、書式文字列の後にリストされた最初の値を保持し、2番目のセットは2番目の値を保持します。<code>println!</code>の1回の呼び出しで複数の値を出力すると、次のようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
#}</code></pre></pre>
<p>このコードは<code>x = 5 and y = 10</code>を出力します。</p>
<a class="header" href="#a最初の部分をテストする" id="a最初の部分をテストする"><h3>最初の部分をテストする</h3></a>
<p>数あてゲームの最初の部分をテストしましょう。<code>cargo run</code>を使って実行します。</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>この時点でゲームの最初の部分が完了します。キーボードから入力を受け取り、それを出力しています。</p>
<a class="header" href="#a秘密番号の生成" id="a秘密番号の生成"><h2>秘密番号の生成</h2></a>
<p>次に、ユーザーが予想しようとする秘密の番号を生成する必要があります。ゲームは複数回遊ぶので、秘密の番号は毎回異なるはずです。1と100の間の乱数を使用して、ゲームがそれほど難しくないようにしましょう。Rustには標準ライブラリに乱数機能はまだ含まれていません。しかし、Rustチームは<a href="https://crates.io/crates/rand"><code>rand</code>クレート</a>を提供しています。</p>
<a class="header" href="#aクレートを使用してより多くの機能を利用する" id="aクレートを使用してより多くの機能を利用する"><h3>クレートを使用してより多くの機能を利用する</h3></a>
<p>クレートはRustのソースコードファイルの集合であることに注意してください。構築してきたプロジェクトは<em>バイナリクレート</em>です。これは実行可能ファイルです。<code>rand</code> クレートは、他のプログラムで使用されることを意図したコードを含む<em>ライブラリクレート</em>です。</p>
<p>Cargoの外部クレートの使用は、それが本当に価値のあることです。<code>rand</code>を使用するコードを書く前に、<em>Cargo.toml</em>ファイルを修正して、<code>rand</code>クレートを依存関係として含める必要があります。そのファイルを開き、Cargoが作成した<code>[dependencies]</code>セクションのヘッダの下に次の行を追加してください。</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p><em>Cargo.toml</em>ファイルではヘッダーの後に続くすべてが、別のセクションが開始するまで続くセクションの一部です。<code>[dependencies]</code>セクションは、Cargoにプロジェクトが依存している外部クレートと、必要とするクレートのバージョンを伝える場所です。この場合、<code>rand</code>クレートはセマンティックバージョニング指定子<code>0.3.14</code>で指定します。Cargoはバージョン番号を書くための標準である<a href="http://semver.org">セマンティックバージョニング</a><!-- ignore -->（時には<em>SemVer</em>と呼ばれる）を理解しています。数字<code>0.3.14</code>は実際には<code>^0.3.14</code>の省略形で、「バージョン0.3.14と互換性のある公開APIを持つすべてのバージョン」を意味します。</p>
<p>さて、コードを変更せずに、リスト2-2に示すようにプロジェクトをビルドしましょう。</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">リスト 2-2:依存関係として<code>rand</code>クレートを追加した後に<code>cargo build</code>を実行した結果
</span></p>
<p>なるバージョン番号が表示されることがあります（しかし、それらはすべてSemVerのおかげでコードと互換性があります）。また、行の順序が異なる場合があります。</p>
<p>Cargoは外部依存関係を持つようになったので、<a href="https://crates.io">Crates.io</a>のデータのコピーである<em>レジストリ</em>からすべての最新バージョンを取得します。Crates.ioは、Rustエコシステムの人々が他の人が使用するためのオープンソースのRustプロジェクトを投稿する場所です。</p>
<p>レジストリを更新した後、Cargoは<code>[dependencies]</code>セクションをチェックし、まだ持っていないクレートをダウンロードします。この場合、<code>rand</code>は依存関係としてリストされていましたが、<code>rand</code>は<code>libc</code>に依存しているため、Cargoは<code>libc</code>のコピーも取得しました。クレートをダウンロードした後、Rustはそれらをコンパイルし、利用可能な依存関係でプロジェクトをコンパイルします。</p>
<p><code>cargo build</code>を何も変更せずに直ちに実行すると、<code>Finished</code>行以外の出力は得られません。Cargoはそれがすでに依存関係をダウンロードしてコンパイルしていることを知っており、<em>Cargo.toml</em>ファイルでそれらについて何も変更していません。Cargoは、コードを何も変更していないことも知っているので、それを再コンパイルしません。何もすることなく終了します。</p>
<p><em>src/main.rs</em>ファイルを開き、簡単な変更を加えて保存してもう一度ビルドすると、2行の出力しか表示されません。</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>これらの行は、Cargoが<em>src/main.rs</em>ファイルへの小さな変更でビルドを更新するだけであることを示しています。依存関係は変更されていないので、Cargoはすでにダウンロードしてコンパイルしたものを再利用できることを認識しています。コードの一部を再構築するだけです。</p>
<a class="header" href="#cargolockファイルによる再現可能なビルドの保証" id="cargolockファイルによる再現可能なビルドの保証"><h4><em>Cargo.lock</em>ファイルによる再現可能なビルドの保証</h4></a>
<p>Cargoには、あなたや他の誰かがコードをビルドするたびに、同じアーティファクトを再構築できる仕組みがあります。Cargoは別のバージョンを指定するまで指定した依存関係のバージョンのみを使用します。例えば、<code>rand</code>クレートの<code>v0.3.15</code>バージョンが来て、重要なバグ修正が含まれているだけでなく、コードを壊す回帰が含まれているとどうなりますか？</p>
<p>この問題への答えは、最初に<code>cargo build</code>を実行したときに作成され、<em>guessing_game</em>ディレクトリにある<em>Cargo.lock</em>ファイルです。初めてプロジェクトをビルドするとき、Cargoは基準に適合するすべてのバージョンの依存関係を把握し、<em>Cargo.lock</em>ファイルに書き込みます。将来的にプロジェクトをビルドする場合、Cargoは<em>Cargo.lock</em>ファイルが存在することを確認し、バージョンを再検討するすべての作業を行うのではなく、指定されたバージョンを使用します。これにより、自動的に再現可能なビルドが可能になります。つまり、<em>Cargo.lock</em>ファイルのおかげで明示的にアップグレードするまでプロジェクトは<code>0.3.14</code>のままです。</p>
<a class="header" href="#a新しいバージョンを取得するためのクレートの更新" id="a新しいバージョンを取得するためのクレートの更新"><h4>新しいバージョンを取得するためのクレートの更新</h4></a>
<p>クレートを更新したいとき、Cargoは<em>Cargo.lock</em>ファイルを無視して、<em>Cargo.toml</em>の仕様に合った最新バージョンをすべて調べる、もう一つのコマンド<code>update</code>を提供します。それが有効ならば、Cargoはこれらのバージョンを<em>Cargo.lock</em>ファイルに書き込みます。</p>
<p>しかし、デフォルトでは、Cargoは<code>0.3.0</code>より大きく、<code>0.4.0</code>より小さいバージョンのみを探します。<code>rand</code>クレートが<code>0.3.15</code>と<code>0.4.0</code>という2つの新しいバージョンをリリースした場合、<code>cargo update</code>を実行すると、次のように表示されます。</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>この時点で、<em>Cargo.lock</em>ファイルの変更が気付くでしょう。現在使用している<code>rand</code>クレートのバージョンは<code>0.3.15</code>です。</p>
<p><code>rand</code>バージョン<code>0.4.0</code>や<code>0.4.x</code>シリーズのバージョンを使いたい場合は、<em>Cargo.toml</em>ファイルを次のように更新する必要があります。</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>次に<code>cargo build</code>を実行すると、Cargoは利用可能なクレートレジストリを更新し、指定した新しいバージョンに従って<code>rand</code>要件を再評価します。</p>
<p>第14章で議論する<a href="http://doc.crates.io">Cargo</a><!--ignore -->と<a href="http://doc.crates.io/crates-io.html">エコシステム</a><!--ignore -->についてはもっと多くのことが説明されていて、そこですべてのことを知ることができます。Cargoはライブラリの再利用を非常に簡単にします。したがって、Rust開発者は多くのパッケージから組み立てられた小さなプロジェクトを書くことができます。</p>
<a class="header" href="#a乱数の生成" id="a乱数の生成"><h3>乱数の生成</h3></a>
<p><em>Cargo.toml</em>に<code>rand</code>クレートを追加したので、<code>rand</code>を使い始めましょう。次のステップは、リスト2-3に示すように、<em>src/main.rs</em>を更新することです。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">リスト 2-3: 乱数を生成するコードを追加する</span></p>
<p>まず、Rustに外部依存として<code>rand</code>クレートを使用することを知らせる行を追加します。これは<code>use rand</code>を呼び出すのと同じことですが、<code>rand</code>の前に<code>rand::</code>を置くことで<code>rand</code>クレートの何かを呼び出すことができます。</p>
<p>次に、<code>use rand::Rng</code>という別の<code>use</code>行を追加します。<code>Rng</code>トレイトは、乱数ジェネレータが実装するメソッドを定義しており、これらのメソッドを使用するには、このトレイトが有効でなければなりません。第10章では、トレイトの詳細について説明します。</p>
<p>また、中央に2行追加しています。<code>rand::thread_rng</code>関数は、使用する特定の乱数ジェネレータを提供します。現在の実行スレッドのローカルであり、オペレーティングシステムによってシードされるものです。次に、乱数ジェネレータで<code>gen_range</code>メソッドを呼び出します。 このメソッドは、<code>use rand::Rng</code>ステートメントでスコープ化した<code>Rng</code>トレイトによって定義されています。<code>gen_range</code>メソッドは引数として2つの数字をとり、それらの間に乱数を生成します。これは下限に含まれていますが上限にはありませんので、1と100の間の数値を要求するには<code>1</code>と<code>101</code>を指定する必要があります。</p>
<blockquote>
<p>注：使用するトレイトやクレートから呼び出すメソッドや関数はわかりません。クレートを使用するための説明は各クレートのドキュメントに記載されています。Cargoのもうひとつの特徴は、<code>cargo doc --open</code>コマンドを実行することです。このコマンドは、すべての依存関係によって提供されるドキュメントをローカルにビルドし、ブラウザで開くようにします。例えば、<code>rand</code>枠内の他の機能に興味があるなら、<code>cargo doc --open</code>を実行し、左側のサイドバーで<code>rand</code>をクリックしてください。</p>
</blockquote>
<p>コードに追加した2行目は秘密の番号を出力します。これは、テストできるようにプログラムを開発している間は便利ですが、最終版から削除します。プログラムが起動するとすぐに答えが表示されるのは、ゲームとしてよくありません。</p>
<p>数回プログラムを実行してみてください。</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>異なる乱数を得なければなりません。それらはすべて1から100までの数字でなければなりません。</p>
<a class="header" href="#a予想を秘密の番号と比較する" id="a予想を秘密の番号と比較する"><h2>予想を秘密の番号と比較する</h2></a>
<p>ユーザー入力と乱数があるので、比較することができます。リスト2-4にその手順を示します。ここで説明するように、このコードはまだコンパイルされません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    // ---snip---

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">リスト 2-4: 2つの数値を比較する戻り値の処理</span></p>
<p>最初の新しい点は<code>std::cmp::Ordering</code>という型を標準ライブラリのスコープに持ち込む別の<code>use</code>ステートメントです。<code>Result</code>と同様に<code>Ordering</code>も別の列挙型ですが、<code>Ordering</code>のバリアントは<code>Less</code>、<code>Greater</code>、<code>Equal</code>です。これらは、2つの値を比較したときの3つの結果です。</p>
<p>次に、<code>Ordering</code>型を使用する新しい5行を追加します。</p>
<p><code>cmp</code>メソッドは2つの値を比較し、比較可能なもので呼び出すことができます。それは比較したいものを参照します。ここでは <code>guess</code>と<code>secret_number</code>を比較しています。次に、<code>use</code>ステートメントでスコープに入れた<code>Ordering</code>列挙型のバリアントを返します。<a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->式を使用して、<code>guess</code>の<code>cmp</code>の呼び出しから返された<code>Ordering</code>のバリアントに基づいて、次に何をするかを決定します。</p>
<p><code>match</code>式は<em>arm</em>で構成されています。armは<em>パターン</em>と<code>match</code>式の先頭に与えられた値がそのarmのパターンに合っていれば実行されるべきコードで構成されています。Rustは<code>match</code>に与えられた値を取り、順番に各armのパターンを調べます。<code>match</code>コンストラクトとパターンはRustの強力な機能であり、コードが遭遇する可能性のあるさまざまな状況を表現し、それらをすべて処理することを保証します。これらの機能については、それぞれ第6章と第18章で詳しく説明します。</p>
<p>ここで使用される<code>match</code>式で何が起こるかの例を見てみましょう。50と38を比較すると、<code>cmp</code>メソッドは<code>Ordering::Greater</code>を返します。これは、50が38より大きいためです。<code>match</code>式は<code>Ordering::Greater</code>値を取得し、各armのパターンのチェックを開始します。最初のarmのパターン、<code>Ordering::Less</code>を見て、<code>Ordering::Greater</code>の値が<code>Ordering::Less</code>と一致しないので、そのarmのコードを無視して次の腕に移動します。次のarmのパターン、<code>Ordering::Greater</code>は、<code>Ordering::Greater</code>にマッチします。そのarmの関連コードが実行され、<code>Too big!</code>を画面に表示します。このシナリオでは最後のarmを見る必要がないため、<code>match</code>式は終了します。</p>
<p>しかし、リスト2-4のコードはまだコンパイルされません。試してみましょう。</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>エラーのコアには、<em>mismatched types</em>と書かれています。Rustは強力な静的タイプのシステムを持っています。ただし、型推論もあります。<code>let mut guess = String::new();</code>と書いたとき、Rustは<code>guess</code>が<code>String</code>でなければならないと推論することができました。一方、<code>secret_number</code>は数値型です。いくつかの数値型は1〜100の値をとります。<code>i32</code>は32ビットの数値です。<code>u32</code>は符号なしの32ビット数です。64ビットの数値は他のものと同様で<code>i64</code>です。Rustのデフォルトは<code>secret_number</code>の型である<code>i32</code>です。Rustが異なる数値型を推論させるような型情報を他の場所に追加しない限り、そうではありません。エラーの原因は、Rustが文字列と数値型を比較できないためです。</p>
<p>最終的には、プログラムが読み込んだ<code>String</code>を数値型に変換して、<code>guess</code>と数値的に比較することができます。これを行うには、以下の2行を<code>main</code>関数本体に追加します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>2つの新しい行は次のとおりです。</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Please type a number!&quot;);
</code></pre>
<p><code>guess</code>という名前の変数を作成します。しかし、プログラムが既に<code>guess</code>という名前の変数を持っているのではないでしょうか？すでに存在していますが、Rustは新しい値で<code>guess</code>の以前の値を<em>シャドー</em>することができます。この機能は、値をある型から別の型に変換する場合によく使用されます。シャドーイングでは、<code>guess</code>と<code>guess_str</code>のような2つの固有の変数を強制的に作成するのではなく、<code>guess</code>変数名を再利用できます（第3章では、シャドーイングについて詳しく説明しています）。</p>
<p><code>guess</code>を<code>guess.trim().parse()</code>という表現にバインドします。式の<code>guess</code>は元の<code>guess</code>を参照していますが、<code>guess</code>は入力された<code>String</code>です。<code>String</code>インスタンスの<code>trim</code>メソッドは、最初と最後の空白を取り除きます。<code>u32</code>は数字だけを含むことができますが、ユーザーは<span class="keystroke">enter</span>を押して<code>read_line</code>を満たす必要があります。ユーザーが<span class="keystroke"></span>を入力すると、改行文字が文字列に追加されます。たとえば、<span class="keystroke">5</span>と入力し、<span class="keystroke">enter</span>を入力すると、<code>guess</code>は<code>5\n</code>のようになります。<code>\n</code>は&quot;改行&quot;を表し、<span class="keystroke"></span>を押した結果です。<code>trim</code>メソッドは<code>\n</code>を削除し、<code>5</code>だけを返します。</p>
<p>Stringの<a href="../../std/primitive.str.html#method.parse"><code>parse</code>メソッド</a><!-- ignore -->は、文字列をある種の数値にパースします。このメソッドはさまざまな数値型をパースできるので、<code>let guess: u32</code>を使ってRustに必要な正確な数値型を伝える必要があります。<code>guess</code>の後のコロン(<code>:</code>)は、Rustに変数の型に注釈を付けるよう指示します。Rustにはいくつかの組み込みの数値型があります。ここで見られる<code>u32</code>は符号なしの32ビット整数です。これは小さな正の数のための良いデフォルトの選択です。さらに、このサンプルプログラムの<code>u32</code>アノテーションと<code>secret_number</code>との比較は、<code>secret_number</code>も<code>u32</code>でなければならないとRustが推論することを意味します。これで比較は同じ型の2つの値になります。</p>
<p><code>parse</code>を呼び出すと簡単にエラーが発生する可能性があります。例えば、文字列に<code>A👍％</code>が含まれていた場合、それを数値に変換する方法はありません。<code>parse</code>メソッドは失敗する可能性があるので、<code>read_line</code>メソッドと同様に<code>Result</code>型を返します（前述の「<code>Result</code>型による潜在的な障害の処理」を参照）。<code>expect</code>メソッドを使うことによって、この<code>Result</code>を同じ方法で扱います。<code>parse</code>が文字列から数値を生成できなかったので、<code>Result</code>の<code>Err</code>バリアントを返した場合、<code>expect</code>はゲームをクラッシュさせ、与えたメッセージを出力します。<code>parse</code>が文字列を数字に変換することができれば<code>Result</code>の<code>Ok</code>バリアントを返し、<code>expect</code>は<code>Ok</code>から望む数字を返します。</p>
<p>プログラムを実行しましょう。</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>推測の前に空白が追加されたにもかかわらず、プログラムはユーザーが76を推測したと考えました。異なる種類の入力で異なる動作を確認するためにプログラムを数回実行します。数字を正しく推測し、あまりにも低い数字を推測してください。</p>
<p>現在ゲームのほとんどを動作させていますが、ユーザーは1つしか推測できません。
ループを追加して変更しましょう。</p>
<a class="header" href="#aループによる複数の推測の許可" id="aループによる複数の推測の許可"><h2>ループによる複数の推測の許可</h2></a>
<p><code>loop</code>キーワードは無限ループを作成します。これを追加して、ユーザーに番号を予測する機会を増やします。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>ご覧のとおり、推測入力プロンプトからすべてをループに移しました。ループ内の行をそれぞれ4つのスペースでインデントして、プログラムを再度実行してください。プログラムは、行った通りのことをやっているので、新しい問題があることに注意してください。別の予測を永遠に求めて、ユーザーが終了できません。</p>
<p>ユーザーは、キーボードショートカット<span class="keystroke">ctrl-c</span>を使用して、プログラムを停止することができます。しかし、前述したように、この状況から脱出する別の方法があります。ユーザーが非数字の答えを入力すると、プログラムがクラッシュします。ここに示すように、ユーザーは終了するためにそれを利用することができます。</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
</code></pre>
<p><code>quit</code>と打つと実際にゲームは終了しますが、他の数字以外の入力も終了します。しかし、これは最適とはいえません。正しい数字が推測されると、ゲームは自動的に停止するようにします。</p>
<a class="header" href="#a正しい予測の後に終了する" id="a正しい予測の後に終了する"><h3>正しい予測の後に終了する</h3></a>
<p>ユーザーが<code>break</code>ステートメントを追加して勝利したときにゲームを終了するようにプログラムしましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><code>You win!</code>の後に<code>break</code>行を追加すると、ユーザが秘密の番号を正しく予想するとプログラムがループを抜けます。ループを終了することは、ループが <code>main</code>の最後の部分であるため、プログラムを終了することも意味します。</p>
<a class="header" href="#a無効な入力の処理" id="a無効な入力の処理"><h3>無効な入力の処理</h3></a>
<p>ゲームの動作をさらに洗練するために、ユーザが非数字を入力したときにプログラムをクラッシュさせるのではなく、ゲームが予測を続けることができるように数字以外の数字を無視してみましょう。<code>guess</code>が<code>String</code>から<code>u32</code>に変換される行を変更することで、これを行うことができます。</p>
<pre><code class="language-rust ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p><code>expect</code>の呼び出しから<code>match</code>式に切り替えることでエラーを処理する方法が変わります。<code>parse</code>は<code>Result</code>型を返し、<code>Result</code>は<code>Ok</code>や<code>Err</code>型を持つ列挙型です。<code>cmp</code>メソッドの<code>Ordering</code>結果で行ったように、ここでは<code>match</code>式を使用しています。</p>
<p><code>parse</code>が文字列を数値に変換することができれば、結果の数値を含む<code>Ok</code>値を返します。その<code>Ok</code>値は最初のarmのパターンと一致し、<code>match</code>式は<code>parse</code>が生成し<code>Ok</code>値の中に入れた<code>num</code>値を返します。</p>
<p><code>parse</code>が文字列を数値に変換できない場合、エラーに関するより多くの情報を含む<code>Err</code>を返します。<code>Err</code>は最初の<code>match</code>armの<code>Ok(num)</code>パターンとは一致しませんが、2番目のアームの<code>Err(_)</code>パターンと一致します。アンダースコア<code>_</code>はキャッチオール値です。この例では、内部にどのような情報があっても、すべての<code>Err</code>値を一致させたいとしています。プログラムは2番目のarmのコード<code>continue</code>を実行します。これは<code>loop</code>の次の繰り返しに行き、別の予測を求めます。そのため、プログラムは<code>parse</code>が遭遇する可能性があるすべてのエラーを無視します。</p>
<p>これで、プログラムのすべてが期待どおりに動作するはずです。 試してみましょう。</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>1つの小さな最終調整で、我々は数あてゲームを終了します。プログラムは依然として秘密の番号を出力していることを思い出してください。それはテストのためにはうまくいきましたが、ゲームを破壊します。秘密の番号を出力する<code>println!</code>を削除しましょう。
リスト2-5に最終コードを示します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">リスト 2-5: 完全な数あてゲームのコード</span></p>
<a class="header" href="#aまとめ-1" id="aまとめ-1"><h2>まとめ</h2></a>
<p>この時点で、正常に数あてゲームを構築できました。</p>
<p>このプロジェクトは<code>let</code>、<code>match</code>、メソッド、関連機能、外部クレートの使用など、多くの新しいRustコンセプトを紹介する実践的な方法でした。次のいくつかの章では、これらの概念についてより詳しく学びます。第3章では、変数、データ型、関数などのほとんどのプログラミング言語に存在する概念と、Rustでそれらを使用する方法を示します。第4章では所有権について説明しますが、Rustは他の言語とは異なります。第5章では構造体とメソッドの構文について説明し、第6章では列挙型がどのように機能するかについて説明します。</p>
<a class="header" href="#aプログラミングの共通概念" id="aプログラミングの共通概念"><h1>プログラミングの共通概念</h1></a>
<p>この章ではほぼすべてのプログラミング言語で表示される概念と、Rustでどのように動作するかについて説明します。多くのプログラミング言語には共通点が共通しています。この章で紹介するコンセプトは、Rust独自のものではありませんが、Rustのコンテキストで説明しこれらのコンセプトを使用するための規則を説明します。</p>
<p>具体的には、変数、基本タイプ、関数、コメント、および制御フローについて学習します。これらの基盤はすべてのRustプログラムに含まれています。</p>
<a class="header" href="#aキーワード" id="aキーワード"><h2>キーワード</h2></a>
<p>Rust言語には、他の言語と同様に、その言語でのみ使用するために予約された<em>キーワード</em>があります。変数や関数の名前としてこれらの単語を使用することはできません。ほとんどのキーワードは特別な意味を持っています。これらのキーワードを使用してRustプログラムでさまざまなタスクを実行します。それらに関連する現在の機能はありませんが、今後はRustに追加される可能性のある機能のために予約されています。Appendix Aにキーワードのリストがあります。</p>
<a class="header" href="#a識別子" id="a識別子"><h2>識別子</h2></a>
<p>変数、関数、構造体、たくさんの概念について説明します。これらのすべてに名前が必要です。Rustの名前は「識別子」と呼ばれ、空でないASCII文字列で構成できますが、いくつかの制限があります。</p>
<ul>
<li>最初の文字は文字です。</li>
<li>残りの文字は英数字または_です。</li>
</ul>
<p>または、</p>
<ul>
<li>最初の文字は_です。</li>
<li>識別子は複数の文字です。_単独では識別子ではありません。</li>
<li>残りの文字は英数字または_です。</li>
</ul>
<a class="header" href="#a生識別子" id="a生識別子"><h3>生識別子</h3></a>
<p>場合によっては、別の目的のためにキーワードである名前を使用する必要があるかもしれません。Cライブラリから来ている<em>match</em>という名前の関数を呼び出す必要があるでしょう。ここで<code>match</code>はキーワードではありません。これを行うには、&quot;生識別子&quot;を使うことができます。生の識別子は<code>r#</code>で始まります。</p>
<pre><code class="language-rust ignore">let r#fn = &quot;this variable is named 'fn' even though that's a keyword&quot;;

// call a function named 'match'
r#match();
</code></pre>
<p>生識別子はあまり必要ではありませんが、時々必要になります。</p>
<a class="header" href="#a変数と変更可能性" id="a変数と変更可能性"><h2>変数と変更可能性</h2></a>
<p>第2章で述べたように、デフォルトでは変数は不変です。Rustは、Rustが提供する安全性と容易な並行性を利用してコードを記述するために、多くのポイントの1つです。ただし、変数を変更可能にするオプションはあります。どのように、そしてなぜRustが不変性を推奨し、なぜ時々オプトアウトを希望するのかを考えましょう。</p>
<p>変数が不変の場合、値が名前にバインドされるとその値を変更することはできません。これを説明するために、<em>projects</em>ディレクトリに<em>variables</em>という新しいプロジェクトを生成しましょう。</p>
<p>次に、新しい<em>variables</em>ディレクトリで、<em>src/main.rs</em>を開き、そのコードを次のコードに置き換えます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p><code>cargo run</code>を使ってプログラムを保存して実行してください。次の出力に示すように、エラーメッセージが表示されます。</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>この例は、コンパイラがどのようにプログラムのエラーを見つけるのに役立つかを示しています。こプログラムはまだ安全に実行していないことを意味します。</p>
<p>エラーの原因が<code>不変の変数xに2回割り当てられない</code>ということです。不変の<code>x</code>変数に第2の値を代入しようとしたためです。</p>
<p>このような状況がバグにつながる可能性があるため、以前は不変として指定した値を変更しようとするとコンパイル時エラーが発生することが重要です。コードの一部が変更されず、コードの別の部分がその値を変更すると仮定してコードの一部が動作する場合、コードの最初の部分は設計されたものを実行しない可能性があります。この種のバグの原因は事実の後で追跡するのが難しい場合があります。特にコードの2番目の部分が<em>時々</em>変更される場合はそうです。</p>
<p>Rustではコンパイラは、値が変更されないことを宣言すると、実際には変更されないことを保証します。つまり、コードを読み書きしているときに、値と値がどこでどのように変化するかを把握する必要はありません。したがって、そのコードは理性的に簡単です。</p>
<p>しかし、変更可能性は非常に便利です。変数はデフォルトでのみ変更できません。第2章で行ったように、変数名の前に<code>mut</code>を追加することでそれらを変更可能にすることができます。この値を変更できることに加えて、<code>mut</code>は、コードの他の部分がこの変数値を変更することを示すことによって、将来のコード読者に意図を伝えます。</p>
<p>例えば、<em>src/main.rs</em>を次のように変更してみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>プログラムを実行すると、次のようになります。</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p><code>mut</code>を使うとき、<code>x</code>が<code>5</code>から<code>6</code>にバインドする値を変更することができます。場合によっては、変数を変更可能にする必要があります。これは、変数に不変な変数がある場合よりもコードを書く方が便利なためです。</p>
<p>バグの防止に加えて、考慮すべき複数のトレードオフがあります。たとえば、大規模なデータ構造を使用している場合、インスタンスを変更すると、新しく割り当てられたインスタンスをコピーして返すよりも速くなる場合があります。より小さなデータ構造では、新しいインスタンスを作成し、より機能的なプログラミングスタイルで記述することが考えやすくなります。</p>
<a class="header" href="#a変数と定数の違い" id="a変数と定数の違い"><h3>変数と定数の違い</h3></a>
<p>変数の値を変更できない場合は、他のほとんどの言語には<em>定数</em>という概念があります。不変変数と同様に、定数は名前にバインドされ、変更が許可されない値ですが、定数と変数の間にはいくつかの違いがあります。</p>
<p>まず、定数で <code>mut</code>を使うことは許されません。定数は、デフォルトで不変ではなく、常に不変です。</p>
<p><code>let</code>キーワードの代わりに<code>const</code>キーワードを使用して定数を宣言し、値の型に注釈を付ける必要があります。次のセクション「データ型」で型と型名を扱いますので、今のところ詳細を心配しないでください。必ずタイプに注釈を付ける必要があることをご存じですか。</p>
<p>定数はグローバルスコープを含む任意のスコープで宣言することができ、コードの多くの部分が知る必要がある値に便利です。</p>
<p>最後の違いは、定数は関数呼び出しの結果や実行時にのみ計算できる他の値ではなく、定数式にのみ設定できることです。</p>
<p>次に定数の名前が<code>MAX_POINTS</code>で、その値が100,000に設定されている定数宣言の例を示します（Rustの定数命名規則では、単語間にアンダースコアを含む大文字を使用し、可読性を高めるためにアンダースコアを数値リテラルに挿入することができます）。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const MAX_POINTS: u32 = 100_000;
#}</code></pre></pre>
<p>定数はプログラムが実行されている間、宣言されたスコープ内で有効です。</p>
<p>プログラム全体で定数として使用されているハードコーディングされた値の名前は、その値の意味を将来のコードのメンテナに伝えるのに便利です。また、ハードコードされた値を将来更新する必要がある場合は、コード内に1つの場所だけを変更して変更する必要があります。</p>
<a class="header" href="#aシャドーイング" id="aシャドーイング"><h3>シャドーイング</h3></a>
<p>第2章で見たように、以前の変数と同じ名前の新しい変数を宣言することができます。新しい変数は前の変数をシャドウします。Rust開発者は、最初の変数は2番目の変数によってシャドーイングされていると言います。つまり、2番目の変数の値は変数が使用されたときの値です。同じ変数の名前を使用し、次のように<code>let</code>キーワードの使用を繰り返すことによって、変数をシャドーすることができます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>このプログラムは最初に<code>x</code>を<code>5</code>の値に束縛します。<code>let x =</code>を繰り返すことで<code>x</code>を陰にし、元の値をとり、<code>1</code>を加えると<code>x</code>の値は<code>6</code>になります。3番目の<code>let</code>ステートメントは<code>x</code>を影にし、前の値に<code>2</code>を掛けて<code>x</code>に<code>12</code>の最終値を与えます。このプログラムを実行すると、次のものが出力されます。</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
</code></pre>
<p><code>let</code>キーワードを使わずにこの変数に誤って再割り当てしようとすると、コンパイル時にエラーが発生するため、シャドウイングは変数を<code>mut</code>をつけることとは異なります。<code>let</code>を使うことによって、値に対していくつかの変換を実行できますが、変換が完了した後は変数を不変にすることができます。</p>
<p><code>mut</code>とシャドーイングのもう一つの違いは、<code>let</code>キーワードを再び使用するときに効果的に新しい変数を作成するので、同じ名前を再利用することができます。例えば、このプログラムでは、スペース文字を入力することによってテキストの間にいくつのスペースが必要かを表示するようにユーザーに求めていますが、実際にはその入力を数値として保存したいとします。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let spaces = &quot;   &quot;;
let spaces = spaces.len();
#}</code></pre></pre>
<p>この構造体は、最初の<code>spaces</code>変数が文字列型で、最初のものと同じ名前を持つまったく新しい変数である<code>spaces</code>変数が数値型であるために許可されています。したがって、シャドウイングは<code>spaces_str</code>や<code>spaces_num</code>のような別の名前を出さなくて済むようにします。代わりに、より単純な<code>spaces</code>という名前を再利用することができます。ただし、ここに示すように<code>mut</code>を使用しようとすると、コンパイル時エラーが発生します：</p>
<pre><code class="language-rust ignore does_not_compile">let mut spaces = &quot;   &quot;;
spaces = spaces.len();
</code></pre>
<p>エラーは、変数の型を変更することができないと言っています。</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<p>変数がどのように機能するかを調べたので、もっと多くのデータ型を見てみましょう。</p>
<a class="header" href="#aデータ型" id="aデータ型"><h2>データ型</h2></a>
<p>Rustのすべての値は特定の<em>データ型</em>であり、指定されているデータの種類をRustに知らせるので、そのデータの処理方法を知ることができます。スカラーと複合体の2つのデータ型サブセットを見ていきます。</p>
<p>Rustは<em>静的に型指定された</em>言語であることに注意してください。つまり、コンパイル時にすべての変数の型を知っている必要があります。コンパイラは、通常、値と使用方法に基づいて使用する型を推論することができます。第2章で<code>parse</code>を使って<code>String</code>を数値型に変換したときなど、多くの型が可能な場合には、このような型名を追加する必要があります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
#}</code></pre></pre>
<p>ここで型を追加しないと、Rustは次のエラーを表示します。これは、コンパイラが使用したいタイプを知るためにより多くの情報を必要とすることを意味します。</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
</code></pre>
<p>他のデータ型には異なるタイプの注釈が表示されます。</p>
<a class="header" href="#aスカラ型" id="aスカラ型"><h3>スカラ型</h3></a>
<p><em>スカラ</em>型は単一の値を表します。Rustには、整数、浮動小数点数、ブール値、および文字の4つの主なスカラ型があります。これらは他のプログラミング言語から認識されるかもしれません。それらがRustでどのように働いているかを考えてみましょう。</p>
<a class="header" href="#a整数型" id="a整数型"><h4>整数型</h4></a>
<p><em>integer</em>は小数成分のない数値です。第2章では1つの整数型、<code>u32</code>型を使用しました。この型宣言は、関連する値が32ビットの空間を占める符号なし整数（符号付き整数型は<code>u</code>ではなく<code>i</code>で始まる）でなければならないことを示します。表3-1に、Rustの組み込み整数型を示します。「符号付き」列と「符号なし」列の各バリアント（たとえば、<code>i16</code>）を使用して、整数値の型を宣言できます。</p>
<p><span class="caption">表3-1: Rustの数値型</span></p>
<table><thead><tr><th> Length  </th><th> Signed  </th><th> Unsigned </th></tr></thead><tbody>
<tr><td> 8-bit   </td><td> <code>i8</code>    </td><td> <code>u8</code>     </td></tr>
<tr><td> 16-bit  </td><td> <code>i16</code>   </td><td> <code>u16</code>    </td></tr>
<tr><td> 32-bit  </td><td> <code>i32</code>   </td><td> <code>u32</code>    </td></tr>
<tr><td> 64-bit  </td><td> <code>i64</code>   </td><td> <code>u64</code>    </td></tr>
<tr><td> 128-bit </td><td> <code>i128</code>  </td><td> <code>u128</code>   </td></tr>
<tr><td> arch    </td><td> <code>isize</code> </td><td> <code>usize</code>  </td></tr>
</tbody></table>
<p>各バリアントは、符号付きまたは符号なしのいずれかであり、明示的なサイズを持ちます。<em>符号付き</em>と<em>符号なし</em>は、数値が負であるか正であるかを参照します。つまり、数値に符号を付ける必要があるか（符号付き）、それとも正であるかどうか 符号なしで表されます（符号なし）。それは紙に数字を書くようなものです。記号が重要なときはプラス記号またはマイナス記号で数字が表示されます。しかし、数字が正であると仮定することは安全ですが、それは記号なしで示されます。符号付き数値は、2の補数表現を使用して格納されます（これが何であるかわからない場合は、オンラインで検索できますが説明は本書の範囲外です）。</p>
<p>各符号付きバリアントは、-(2<sup>n - 1</sup>)から2<sup>n - 1</sup> - 1までの数値を格納できます。<em>n</em>はバリアントが使用するビット数です。したがって、<code>i8</code>は -(2 <sup> 7 </sup>)から2<sup>7</sup> - 1までの数を保存できます。これは-128〜127になります。 <sup>n</sup> - 1であるので、<code>u8</code>は0から255までの数字を格納することができます。</p>
<p>さらに、<code>isize</code>と<code>usize</code>の型は、プログラムが動作しているコンピュータの種類によって異なります。64ビットアーキテクチャの場合は64ビット、32ビットアーキテクチャの場合は32ビットです。</p>
<p>表3-2に示すいずれかの形式で整数リテラルを記述することができます。バイトリテラル以外のすべての数値リテラルは、型接尾辞<code>57u8</code>を許可し、<code>_</code>は視覚的区切り文字として<code>1_000</code>などを許すことに注意してください。</p>
<p><span class="caption">表 3-2: Rustの整数リテラル</span></p>
<table><thead><tr><th> Number literals  </th><th> Example       </th></tr></thead><tbody>
<tr><td> Decimal          </td><td> <code>98_222</code>      </td></tr>
<tr><td> Hex              </td><td> <code>0xff</code>        </td></tr>
<tr><td> Octal            </td><td> <code>0o77</code>        </td></tr>
<tr><td> Binary           </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Byte (<code>u8</code> only) </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<p>どのようなタイプの整数を使うべきでしょうか？ もし確信が持てないなら、Rustのデフォルトは一般的に良い選択肢です（整数型のデフォルトは<code>i32</code>です）。このタイプは、64ビットシステムでさえ一般的に最も速いです。<code>isize</code>や<code>usize</code>を使う主な状況は何らかのコレクションのインデックスを作るときです。</p>
<a class="header" href="#a整数オーバーフロー" id="a整数オーバーフロー"><h5>整数オーバーフロー</h5></a>
<p><code>u8</code>を持っていて、0と255の間の値を保持できるとしましょう。<code>256</code>に変更しようとするとどうなりますか？これは 「整数オーバーフロー」と呼ばれ、Rustはこの振る舞いに関するいくつかの興味深い規則を持っています。デバッグモードでコンパイルすると、Rustはこの種の問題をチェックし、プログラムがエラーで終了したときにRustが使う*panic!*を引き起こします。panicについては、第9章で詳しく説明します。</p>
<p>リリースビルドでは、Rustはオーバーフローをチェックせず、代わりに「2の補数ラッピング」と呼ばれるものを実行します。つまり、<code>256</code>は<code>0</code>に、<code>257</code>は<code>1</code>になります。オーバーフローに依存するのは、 この現象が発生した場合でも、エラーが発生します。この振る舞いを明示的にしたいのであれば、標準ライブラリは明示的にそれを提供する<code>Wrapping</code>型を持っています。</p>
<a class="header" href="#a浮動小数点型" id="a浮動小数点型"><h4>浮動小数点型</h4></a>
<p>Rustには、小数点を含む数字である<em>浮動小数点数</em>の2つのプリミティブ型もあります。Rustの浮動小数点型はそれぞれ32ビットと64ビットの <code>f32</code>と<code>f64</code>です。現代のCPUでは<code>f32</code>とほぼ同じ速度ですが、より精度が高いのでデフォルトの型は<code>f64</code>です。</p>
<p>実際の浮動小数点数を示す例です。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>浮動小数点数は、IEEE-754標準に従って表されます。<code>f32</code>型は単精度浮動小数点型で、<code>f64</code>型は倍精度です。</p>
<a class="header" href="#a数値演算" id="a数値演算"><h4>数値演算</h4></a>
<p>Rustは、加算、減算、乗算、除算、および剰余のすべての数値タイプに期待される基本的な数学演算をサポートしています。次のコードは<code>let</code>文でどのように使うのかを示しています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>これらのステートメントの各式は、数学演算子を使用して単一の値に評価され、変数にバインドされます。Appendix Bには、Rustが提供するすべての演算子のリストが含まれています。</p>
<a class="header" href="#aブール型" id="aブール型"><h4>ブール型</h4></a>
<p>ほとんどの他のプログラミング言語と同様に、Rustのブール型には、2つの値、<code>true</code>と<code>false</code>があります。Rustのブール型は<code>bool</code>を使って指定します。例えば次のように使います。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre></pre>
<p>ブール値を使用する主な方法は、<code>if</code>文のような条件文によるものです。「制御フロー」セクションでRustの式がどのように働くかについて説明します。</p>
<p>ブール値は1バイトの大きさです。</p>
<a class="header" href="#a文字型" id="a文字型"><h4>文字型</h4></a>
<p>これまでは数字だけで作業していましたが、Rustも文字をサポートしています。Rustの<code>char</code>型は言語の最も原始的なアルファベット型であり、次のコードはそれを使う一つの方法を示しています(<code>char</code>リテラルは二重引用符を使用する文字列リテラルではなく、一重引用符で指定されています)。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Rustの <code>char</code>型はUnicode Scalar Valueを表しています。これはASCIIよりもはるかに多くを表現できることを意味します。アクセント付きの文字(中国語、日本語、韓国語の文字、絵文字)、ゼロ幅の空白はすべてRustの有効な<code>char</code>値です。Unicodeスカラ値の範囲は、<code>U + 0000</code>から<code>U + D7FF</code>まで、<code>U + E000</code>から<code>U + 10FFFF</code>までです。しかし、&quot;文字&quot;は実際にはUnicodeの概念ではないので、人間の&quot;文字&quot;の直感は、Rustのcharと一致しないかもしれません。このトピックについては、第8章の「文字列」で詳しく説明します。</p>
<a class="header" href="#a複合型" id="a複合型"><h3>複合型</h3></a>
<p><em>複合型</em>は、複数の値を1つの型にグループ化できます。Rustには、タプルと配列の2つの基本的な複合型があります。</p>
<a class="header" href="#aタプル" id="aタプル"><h4>タプル</h4></a>
<p>タプルはさまざまなタイプのいくつかの値を1つの複合タイプにグループ化する一般的な方法です。タプルの長さは固定されています。一度宣言すると、タプルのサイズが拡大または縮小できません。</p>
<p>タプルはカッコで区切った値のリストをコンマで区切って作成します。タプル内の各位置は型を持ち、タプル内の異なる値の型は同じである必要はありません。この例では、オプションの注釈を追加しました。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>変数tupは、タプルが単一の複合要素とみなされるため、タプル全体にバインドされます。タプルから個々の値を取得するには、パターンマッチングを使用して次のようにタプル値を破棄できます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>このプログラムは最初にタプルを作成し、それを変数<code>tup</code>にバインドします。次に<code>let</code>のパターンを使って<code>tup</code>を取り出し、<code>x</code>、<code>y</code>、<code>z</code>の3つの変数に変換します。これは、単一タプルを3つの部分に分割するため、<em>destructuring</em>と呼ばれます。最後に、プログラムは<code>y</code>の値、<code>6.4</code>を出力します。</p>
<p>パターンマッチングによる構造解除に加えて、アクセスする値のインデックスが続くピリオド(<code>.</code>)を使用して、タプル要素に直接アクセスすることができます。例えば次のようにできます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>このプログラムはタプル<code>x</code>を作成し、そのインデックスを使って要素ごとに新しい変数を作成します。ほとんどのプログラミング言語と同様に、タプルの最初のインデックスは0です。</p>
<a class="header" href="#a配列" id="a配列"><h4>配列</h4></a>
<p>複数の値のコレクションを持つもう1つの方法は、<em>配列</em>です。タプルとは異なり、配列のすべての要素は同じ型でなければなりません。Rustの配列はタプルのように固定長であるため、Rustの配列は他の言語の配列とは異なります。</p>
<p>Rustでは、配列に入る値は角括弧で囲まれたコンマ区切りのリストとして書き出されます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>配列は、ヒープではなくスタックにデータを割り当てたい場合に便利です(スタックとヒープについては第4章で詳しく説明します)。また、常に固定数の要素を確保したい場合にも便利です。しかし、配列はvector型ほど柔軟ではありません。vectorは標準ライブラリによって提供される同様のコレクション型であり、サイズの拡大または縮小が許可されています。配列やvectorを使用するかどうかわからない場合は、殆どの場合vectorを使用するべきです。第8章では、vectorについて詳しく説明します。</p>
<p>vectorではなく配列を使用する場合の例は、月の名前を知る必要があるプログラムにあります。このようなプログラムでは月を追加または削除する必要はほとんどありません。したがって、配列には常に12個の項目が含まれていることがわかっているので、配列を使用できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
#}</code></pre></pre>
<p>配列には<code>[type; 要素数]</code>という型があります。これは次のようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: [i32; 5] = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>まず、角括弧があります。配列を作成する構文のように見えます。内部にはセミコロンで区切られた2つの情報があります。1つは、配列の各要素の型です。すべての要素は同じ型であるため、一度リストするだけで済みます。セミコロンの後には、配列の長さを示す数字があります。配列のサイズは固定されているため、配列の要素が変更されても、その数は常に同じです。拡大または縮小できません。</p>
<a class="header" href="#a配列要素へのアクセス" id="a配列要素へのアクセス"><h5>配列要素へのアクセス</h5></a>
<p>配列は、スタックに割り当てられたメモリの単一のチャンクです。次のように、インデックスを使用して配列の要素にアクセスできます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>この例では、<code>first</code>という名前の変数は配列のインデックス<code>[0]</code>の値であるため、値<code>1</code>を取得します。<code>second</code>という名前の変数は配列のインデックス<code>[1]</code>から値<code>2</code>を取得します。</p>
<a class="header" href="#a無効な配列要素へのアクセス" id="a無効な配列要素へのアクセス"><h5>無効な配列要素へのアクセス</h5></a>
<p>配列の最後を過ぎた配列の要素にアクセスしようとするとどうなるでしょうか？例を以下のコードに変更します。コンパイルは実行されますが、実行時にエラーが発生して終了します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre>
<p><code>cargo run</code>を使用してこのコードを実行すると、次の結果が得られます。</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>コンパイルでエラーは発生しませんでしたが、プログラムは<em>実行時</em>エラーとなり、正常に終了しませんでした。インデックスを使用して要素にアクセスしようとすると、指定したインデックスが配列の長さよりも小さいかどうかが確認されます。インデックスが長さより大きい場合、Rustはパニックになります。</p>
<p>これは、Rustの安全原則の最初の実例です。多くの低レベル言語では、このようなチェックは行われず、間違ったインデックスを指定すると無効なメモリにアクセスすることができます。Rustはメモリアクセスを許可し続ける代わりにすぐに終了することで、この種のエラーから守ります。第9章では、Rustのエラー処理の詳細について説明します。</p>
<a class="header" href="#a関数の動作" id="a関数の動作"><h2>関数の動作</h2></a>
<p>関数はRustのコードに広がっています。すでに言語の中で最も重要な機能の1つ、すなわち多くのプログラムの入り口である<code>main</code>関数を見てきました。新しい関数を宣言できる<code>fn</code>キーワードも見たことがあります。</p>
<p>Rustコードは、関数名と変数名の従来のスタイルとして<em>snake case</em>を使用します。snakeの場合、すべての文字は小文字で、単語は別々になっています。これは関数定義の例を含むプログラムです。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Rustの関数定義は<code>fn</code>で始まり、関数名の後に括弧が付きます。中括弧は、関数本体の始まりと終わりをコンパイラに伝えます。</p>
<p>定義した関数は、その名前の後ろに括弧を付けて呼び出すことができます。<code>another_function</code>はプログラムで定義されているので、<code>main</code>関数の中から呼び出すことができます。ソースコードの<code>main</code>関数の<em>後</em>に<code>another_function</code>を定義しました。それ以前にも定義できます。Rustはどこで関数を定義するかは気にせず、どこかで定義されているだけです。</p>
<p>関数をさらに探索するために<em>functions</em>という名前の新しいバイナリプロジェクトを開始しましょう。<code>another_function</code>の例を<em>src/main.rs</em>に置き、それを実行してください。次の出力が表示されます。</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>これらの行は、<code>main</code>関数に現れる順に実行されます。まず、<code>Hello, world!メッセージが表示され、次に</code>another_function`が呼び出され、そのメッセージが表示されます。</p>
<a class="header" href="#a関数の引数" id="a関数の引数"><h3>関数の引数</h3></a>
<p>関数はシグニチャの一部である特殊変数である<em>引数</em>を持つように定義することもできます。引数とは、関数シグニチャの一部になる特別な変数のことです。関数に引数があると、引数の位置に実際の値を与えることができます。技術的にはこの実際の値は<em>実引数</em>と呼ばれますが、普段の会話では、仮引数(&quot;parameter&quot;)と実引数(&quot;argument&quot;)を関数定義の変数と関数呼び出し時に渡す実際の値、両方の意味に区別なく使います。</p>
<p>次の例は<code>another_function</code>を引数を使うように書き直しました。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>このプログラムを実行してみてください。 次の出力が得られるはずです。</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>another_function</code>の宣言には、<code>x</code>という名前の引数が1つあります。<code>x</code>の型は<code>i32</code>として指定されます。<code>5</code>が<code>another_function</code>に渡されたとき、<code>println!</code>マクロは中括弧のペアが書式文字列にあったところに<code>5</code>を置きます。</p>
<p>関数のシグニチャでは、各引数の型を宣言する必要があります。これは、Rustの設計における意図的な決定です。関数の定義に型の注釈が必要なことは、コンパイラがコードのどこかでそれらを使用する必要がほとんどないことを意味します。</p>
<p>関数に複数の引数を指定する場合は、引数宣言を次のようにカンマで区切ります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>この例では、2つの引数を持つ関数を作成します。どちらも<code>i32</code>型です。この関数は、両方の引数に値を出力します。関数の引数はすべて同じ型である必要はないことに注意してください。</p>
<p>このコードを実行してみましょう。<em>functions</em>プロジェクトの<em>src/main.rs</em>ファイルにあるプログラムを上記の例に置き換えて、<code>cargo run</code>を使って実行してください。</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p><code>x</code>の値として<code>5</code>, <code>y</code>の値として<code>6</code>が渡されたので、二つの文字列はこれらの値で出力されます。</p>
<a class="header" href="#a関数本体" id="a関数本体"><h3>関数本体</h3></a>
<p>関数本体はオプションで式で終わる一連のステートメントで構成されます。これまでは、式を終了することなく関数のみを扱ってきましたが、式の一部として式を見てきました。Rustは式ベースの言語なのでこれは重要な違いです。他の言語でも同じ区別がないので、どのステートメントや式がどのようなものか、その違いが関数の本体にどのように影響するかを見てみましょう。</p>
<a class="header" href="#aステートメントと式" id="aステートメントと式"><h3>ステートメントと式</h3></a>
<p>実際にはすでにステートメントと式を使用しています。<em>ステートメント</em>は何らかのアクションを実行し、値を返さない命令です。<em>式</em>は結果の値に評価されます。いくつかの例を見てみましょう。</p>
<p>変数を作成し<code>let</code>キーワードを使って変数に値を代入するのはステートメントです。リスト3-1では、<code>let y = 6;</code>はステートメントです。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">リスト 3-1: 1つのステートメントを含む<code>main</code>関数宣言</span></p>
<p>関数定義もステートメントです。前の例全体が単独のステートメントです。</p>
<p>ステートメントは値を返しません。したがって、次のコードが試みるように、<code>let</code>文を別の変数に代入することはできません。エラーが表示されます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>このプログラムを実行すると、次のようなエラーが表示されます。</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p><code>let y = 6</code>ステートメントは値を返さないので、<code>x</code>がバインドするものはありません。これは、代入が代入の値を返すCやRubyなど、他の言語で行われる処理とは異なります。これらの言語では、<code>x = y = 6</code>と書いて、<code>x</code>と<code>y</code>の両方に<code>6</code>という値をつけることができます。これはRustの場合できません。</p>
<p>式は何かに評価され、Rustで書く残りのコードのほとんどを占めます。値<code>11</code>に評価される式である<code>5 + 6</code>のような単純な数学演算を考えてみましょう。式は文の一部です。リスト3-1では<code>let y = 6;</code>という文の<code>6</code>は値<code>6</code>に評価される式です。関数の呼び出しは式です。マクロの呼び出しは式です。新しいスコープ<code>{}</code>を作成するために使用するブロックは、次のような式です。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>この式は、</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>ブロックであり、この場合は<code>4</code>と評価されます。その値は<code>let</code>ステートメントの一部として<code>y</code>に束縛されます。最後にセミコロンを付けない<code>x + 1</code>行に注意してください。これはこれまで見たほとんどの行とは異なります。式には終了セミコロンは含まれません。式の最後にセミコロンを追加すると、ステートメントに変換され、ステートメントに値が返されません。次に関数の戻り値と式を調べるときは、このことを覚えておいてください。</p>
<a class="header" href="#a戻り値を持つ関数" id="a戻り値を持つ関数"><h3>戻り値を持つ関数</h3></a>
<p>関数はそれらを呼び出すコードに値を返すことができます。戻り値の名前は付けませんが、矢印(<code>-&gt;</code>)の後に型を宣言します。Rustでは関数の戻り値は、関数本体のブロック内の最終式の値と同義です。<code>return</code>キーワードを使用して値を指定することで、関数から早期に返ることができますが、ほとんどの関数は最後の式を暗黙的に返します。次に、値を返す関数の例を示します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p><code>five</code>関数には関数呼び出しもマクロも<code>let</code>文もありません。それは単に<code>5</code>だけです。これは、Rustの完全に有効な機能です。関数の戻り値の型も<code>-&gt; i32</code>と指定されていることに注意してください。このコードを実行してみてください。出力は次のようになります。</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>5</code>の<code>5</code>は関数の戻り値です。戻り値の型は<code>i32</code>です。これをより詳細に調べてみましょう。最初に、<code>let x = five();</code>という行は関数の戻り値を使って変数を初期化していることを示しています。関数<code>five</code>は<code>5</code>を返すので、その行は次のようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>第2に<code>five</code>関数は引数を持たず戻り値の型を定義しますが、関数の本体はセミコロンを持たない単独の<code>5</code>です。</p>
<p>別の例を見てみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>このコードを実行すると<code>The value of x is is：6</code>が出力されます。しかし、<code>x + 1</code>を含む行の最後にセミコロンを置いて式から文に変更すると、エラーが発生します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>このコードをコンパイルすると、次のようなエラーが発生します。</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -&gt; i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
</code></pre>
<p>main関数のエラーメッセージ&quot;mismatched types,&quot;では、このコードの中核的な問題が明らかになります。関数<code>plus_one</code>の定義では<code>i32</code>が返されますが、ステートメントは評価されません。この値は空のタプル<code>()</code>で表されます。したがって、何も返されず、関数定義と矛盾し、エラーが発生します。この出力では、Rustはこの問題を解決するためのメッセージを提供します。セミコロンを削除することで、このエラーは修正できます。</p>
<a class="header" href="#aコメント" id="aコメント"><h2>コメント</h2></a>
<p>すべてのプログラマーはコードを分かりやすくするために努力していますが時には説明も必要です。このような場合、プログラマはコンパイラが無視するソースコードにメモや<em>コメント</em>を残しますが、それはソースコードを読んでいる人は役に立つちます。</p>
<p>ここに簡単なコメントがあります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Hello, world.
#}</code></pre></pre>
<p>Rustでは、コメントは2つのスラッシュで始まり行の終わりまで続きます。単一行を越えるコメントについては、次のように各行に<code>//</code>を入れる必要があります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
#}</code></pre></pre>
<p>コメントはコードを含む行の最後に置くこともできます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today.
}
</code></pre></pre>
<p>しかし、次のフォーマットで使用されることがよくあります。コメントを付けるコードの上の行にコメントが表示されます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // I’m feeling lucky today.
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rustにはドキュメンテーションコメントという別の種類のコメントがあります。これについては第14章で説明します。</p>
<a class="header" href="#a制御フロー" id="a制御フロー"><h2>制御フロー</h2></a>
<p>条件が真であるかどうかによっていくつかのコードを実行するかどうかを決定し、条件が真である間に何度かのコードを繰り返し実行することを決定することは、ほとんどのプログラミング言語の基本的なビルディングブロックです。Rustコードの実行フローを制御できる最も一般的な構造は、式とループです。</p>
<a class="header" href="#if式" id="if式"><h3><code>if</code>式</h3></a>
<p><code>if</code>式は、条件に応じてコードを分岐することを可能にします。条件を指定し「この条件が満たされている場合は、このコードブロックを実行します。条件が満たされない場合は、このコードブロックを実行しないでください」ということを行います。</p>
<p><em>projects</em>ディレクトリに<em>branches</em>という名前の新しいプロジェクトを作成して、<code>if</code>式を試します。<em>src/main.rs</em>ファイルに、次のように入力します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>すべての<code>if</code>式はキーワード<code>if</code>で始まり、その後に条件が続きます。この場合、変数<code>number</code>の値が5未満であるかどうかをチェックします。条件が真である場合に実行したいコードのブロックは、中括弧の中の条件の直後に配置されます。<code>if</code>式の条件に関連するコードブロックは、第2章で説明した<code>match</code>式のように、<em>arms</em>と呼ばれることがあります。</p>
<p>オプションで条件をfalseに評価した場合に実行する別のコードブロックをプログラムに与えるためにここで使用した<code>else</code>式を含めることもできます。<code>else</code>式を指定せず条件がfalseの場合、プログラムは<code>if</code>ブロックをスキップして次のコードに移ります。</p>
<p>このコードを実行してみてください。 次の出力が表示されます。</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was true
</code></pre>
<p><code>number</code>の値を<code>false</code>という条件に変更して何が起こるかを見てみましょう。</p>
<pre><code class="language-rust ignore">let number = 7;
</code></pre>
<p>プログラムをもう一度実行し、出力を確認します。</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was false
</code></pre>
<p>このコードの条件は<em>bool</em>でなければなりません。条件が<code>bool</code>でなければエラーになります。例えば、以下の例を見てみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p>今回の <code>if</code>条件は<code>3</code>の値になり、Rustはエラーを投げます。</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<p>このエラーはRustが<code>bool</code>を期待していたのに整数を持っていることを示しています。RubyやJavaScriptなどの言語とは異なり、Rustはブール型以外の型をブール型に自動的に変換しようとはしません。明示的でなければならず、常に条件として<code>if</code>をブール値で与えなければなりません。たとえば<code>if</code>コードブロックが<code>0</code>と等しくないときにのみ実行されるようにするには、<code>if</code>式を次のように変更します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>このコードを実行すると、 <code>number was something other than zero</code>と出力されます。</p>
<a class="header" href="#else-ifによる複数の条件の処理" id="else-ifによる複数の条件の処理"><h4><code>else if</code>による複数の条件の処理</h4></a>
<p><code>else if</code>式に<code>if</code>と <code>else</code>を組み合わせることで、複数の条件を満たすことができます。例えば、以下の例を見てみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>このプログラムには4つの可能なパスがあります。実行後、次の出力が表示されます。</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>このプログラムが実行されると各if式を順にチェックし、条件が真である最初のボディを実行します。6が2で割り切れるにもかかわらず、出力は <code>number is 2 is by divisible by 2</code>ではなく、<code>number is divisible by 3</code>となります。これは、Rustが最初の真の条件のブロックのみを実行し、見つかったら残りの部分をチェックしないからです。</p>
<p>あまりにも多くの<code>else if</code>式を使用するとコードが乱雑になる可能性があります。複数ある場合は、コードをリファクタリングすることができます。第6章では、これらの場合に`match'と呼ばれる強力なRust分岐構造を説明します。</p>
<a class="header" href="#let文でifを使う" id="let文でifを使う"><h4><code>let</code>文で<code>if</code>を使う</h4></a>
<p><code>if</code>は式なので、リスト3-2のように<code>let</code>ステートメントの右側でそれを使うことができます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p><span class="caption">リスト 3-2: <code>if</code>式の結果を変数に代入する</span></p>
<p><code>number</code>変数は、<code>if</code>式の結果に基づいて値にバインドされます。このコードを実行すると、何が起こるかを確認できます。</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>コードブロックはそれらの中の最後の式に評価され数字だけでも式であることを覚えておいてください。この場合、<code>if</code>式全体の値はどのコードブロックが実行されるかによって決まります。つまり、<code>if</code>の各armの結果となる可能性のある値は同じ型でなければなりません。リスト3-2の<code>if</code>アームと<code>else</code>アームの両方の結果は<code>i32</code>の整数でした。次の例のように型が一致しない場合、エラーが発生します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<p>このコードをコンパイルしようとすると、エラーが発生します。<code>if</code>と<code>else</code>には互換性のない値の型があり、Rustはプログラムのどこで問題があったのかを示します。</p>
<pre><code class="language-text">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integral variable, found &amp;str
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<p><code>if</code>ブロックの式は整数に評価され、<code>else</code>ブロックの式は文字列に評価されます。変数は単一の型でなければならないため、これは機能しません。Rustはコンパイル時に<code>number</code>変数がどのタイプのものであるかを知る必要があります。コンパイル時に<code>number</code>を使用するあらゆる場所でそのタイプが有効であることを検証できます。`number 'の型が実行時にのみ決定された場合、Rustはそれを行うことができません。コンパイラはより複雑になり、任意の変数に対して複数の仮説型を追跡しなければならない場合、コードの保証が少なくなります。</p>
<a class="header" href="#aループによる繰り返し" id="aループによる繰り返し"><h3>ループによる繰り返し</h3></a>
<p>1つのコードブロックを複数回実行すると便利なことがよくあります。このタスクでは、Rustはいくつかの<em>ループ</em>を提供します。ループはループ本体内のコードを最後まで実行した後、最初からすぐに開始します。ループを試すには、<em>loop</em>という新しいプロジェクトを作ってみましょう。 Rustにはloop、while、forという3種類のループがあります。それぞれを試してみましょう。</p>
<a class="header" href="#loopを使ってコードを繰り返す" id="loopを使ってコードを繰り返す"><h4><code>loop</code>を使ってコードを繰り返す</h4></a>
<p><code>loop</code>キーワードは、Rustにコードのブロックを何度も何度も何度も何度も実行するよう指示します。</p>
<p>たとえば、<em>loop</em>ディレクトリの<em>src/main.rs</em>ファイルを次のように変更します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>このプログラムを実行すると、プログラムを手動で停止するまで、<code>again!</code>が何度も何度も繰り返し表示されます。ほとんどの端末では、キーボードショートカット<span class="keystroke">ctrl-c</span>がサポートされており、連続したループで停止しているプログラムを停止します。</p>
<p>試してみましょう。</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p><code>^C</code>の記号は<span class="keystroke">ctrl-c&lt;/ span&gt;を押した場所を表します。<code>^C</code>の後ろに<code>again!</code>という単語が表示される場合と表示されない場合があります。停止信号を受け取ったときのループのどこにコードがあるかによって異なります。</p>
<p>Rustはループから抜け出すための信頼性の高いもう1つの方法を提供します。ループ内で<code>break</code>キーワードを使用して、ループの実行をいつ停止するかをプログラムに指示できます。ユーザーが正しい数を推測してゲームに勝ったときにプログラムを終了するには、第2章の「正しい予測の後に終了する」セクションの数あてゲームでこれを実行したことを思い出してください。</p>
<a class="header" href="#loopからの戻り" id="loopからの戻り"><h4><code>loop</code>からの戻り</h4></a>
<p><code>loop</code>の使用法の1つは、スレッドがそのジョブを完了したかどうかを確認するなど、失敗する可能性のある操作を再試行することです。ただし、その操作の結果をコードの残りの部分に渡す必要があるかもしれません。ループを停止するために使用する<code>break</code>式にそれを追加すると、それは<code>break</code>したループによって返されます。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<a class="header" href="#whileによる条件付きループ" id="whileによる条件付きループ"><h4><code>while</code>による条件付きループ</h4></a>
<p>プログラムがループ内の状態を評価することはしばしば有用です。条件が真である間、ループが実行されます。条件が真でなくなると、プログラムは<code>break</code>を呼び出してループを停止します。このループ型は <code>loop</code>、<code>if</code>、 <code>else</code>、<code>break</code>の組み合わせを使って実装できます。</p>
<p>しかし、このパターンは非常に一般的なのでRustにはwhileループと呼ばれるビルトインの言語構造があります。リスト3-3は<code>while</code>を使い3回ループし、毎回カウントダウンしてから、ループの後に別のメッセージを出力して終了します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">リスト 3-3: 条件が真である間、<code>while</code>ループを使ってコードを実行する</span></p>
<p>これにより <code>loop</code>、<code>if</code>、 <code>else</code>、<code>break</code>を使用した場合に必要となるネストをなくし、より明確になります。条件が成立している間はコードが実行されます。それ以外の場合はループを終了します。</p>
<a class="header" href="#forを使ってコレクションをループする" id="forを使ってコレクションをループする"><h4><code>for</code>を使ってコレクションをループする</h4></a>
<p>配列のようなコレクションの要素をループするために<code>while</code>構文を使うことができます。たとえば、リスト3-4を見てみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<p><span class="caption">リスト 3-4: <code>while</code>ループを使ってコレクションの各要素をループする</span></p>
<p>ここでコードは配列内の要素をカウントアップします。それはインデックス<code>0</code>で始まり、配列の最後のインデックスに到達するまで（つまり、<code>index &lt; 5</code>が真でなくなるまで）ループします。このコードを実行すると、配列のすべての要素が出力されます。</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>期待どおり、5つの配列値がすべて端末に表示されます。ある時点で6番目の値をフェッチしようとする前にループは実行を停止します。</p>
<p>しかし、このアプローチはエラーが起こりやすいです。インデックスの長さが間違っていると、プログラムが<code>panic!</code>になる可能性があります。コンパイラーはループを介したすべての反復ですべての要素の条件チェックを実行するためのランタイムコードを追加するため処理速度も遅くなります。</p>
<p>より簡潔な方法として、<code>for</code>ループを使用してコレクション内の各項目に対していくつかのコードを実行することができます。<code>for</code>ループはリスト3-5のコードのようになります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p><span class="caption">リスト 3-5: <code>for</code>ループを使ってコレクションの各要素をループする</span></p>
<p>このコードを実行すると、コードリスト3-4と同じ出力が表示されます。さらに重要なのはコードの安全性を高めたことで、いくつかのアイテムが見つからないことに起因するバグの可能性を排除したことです。</p>
<p>例えば、リスト3-4のコードでは、配列 <code>a</code>から項目を削除したが、条件を<code>while index &lt;4</code>に更新するのを忘れた場合、コードは<code>panic!</code>に陥ります。<code>for</code>ループを使用すると、配列内の値の数を変更した場合、他のコードを変更する必要はありません。</p>
<p><code>for</code>ループの安全性と簡潔さは、それらをRustの中で最も一般的に使用されるループ構造にします。リスト3-3の<code>while</code>ループを使ったカウントダウンの例のように、ある程度のコードをいくつか実行したい場合でも、ほとんどの錆びた人は<code>for</code>ループを使います。これを行う方法は、標準ライブラリによって提供されるタイプで、ある数字から順番にすべての数字を生成し、別の数字より前に終了するタイプの<code>Range</code>を使用することです。</p>
<p>次の例では<code>for</code>ループとまだ説明していないもう一つのメソッド<code>rev</code>を使ってカウントダウンがどのようになるかを示します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<a class="header" href="#aまとめ-2" id="aまとめ-2"><h2>まとめ</h2></a>
<p>変数、スカラーや複合データ型、関数、コメント、<code>if</code>式、ループについて学びました。この章で説明するコンセプトで練習する場合は、以下のことを行うプログラムを作成してみてください。</p>
<ul>
<li>気温を華氏と摂氏の間で変換します。</li>
<li>n番目のフィボナッチ数を生成する。</li>
<li>歌の繰り返しを利用して、クリスマスキャロル「The Twelve Days of Christmas」の歌詞を印出力します。</li>
</ul>
<p>他のプログラミング言語には存在<em>しない</em>所有権というRustの概念について説明します。</p>
<a class="header" href="#a所有権について" id="a所有権について"><h1>所有権について</h1></a>
<p>所有権はRustの最もユニークな機能であり、ガーベッジコレクタを必要とせずにRustでメモリの安全性を保証することができます。したがって、Rustのオーナーシップの仕組みを理解することが重要です。この章では所有権だけでなくいくつかの関連する機能、すなわち、借用、スライス、およびRustがデータをメモリに格納する方法についても説明します。</p>
<a class="header" href="#a所有権とは何か" id="a所有権とは何か"><h2>所有権とは何か？</h2></a>
<p>Rustの中心的な特徴は<em>所有権</em>です。この機能は説明するのは簡単ですが、深い意味があります。</p>
<p>すべてのプログラムは、実行中にコンピュータのメモリを使用する方法を管理する必要があります。一部の言語では、プログラムの実行中にメモリが使用されなくなることを常に検出するガベージコレクションがあります。他の言語ではプログラマはメモリを明示的に割り当てて解放する必要があります。Rustは第3のアプローチを使用しています。メモリはコンパイル時にコンパイラがチェックする一連の規則を持つ所有権システムによって管理されます。所有権機能は、実行中にプログラムの速度を低下させるものではありません。</p>
<p>所有権は多くのプログラマーのための新しいコンセプトなので慣れるまでに時間がかかります。良い情報はRustとオーナーシップシステムのルールにもっと熟練すればするほど、安全かつ効率的なコードを自然に開発できるようになることです。</p>
<p>所有権を理解すると、Rustをユニークにする機能を理解するための強固な基盤が得られます。この章では、非常に一般的なデータ構造(文字列)に焦点を当てたいくつかの例を使って、所有権を学習します。</p>
<blockquote>
<a class="header" href="#aスタックとヒープ" id="aスタックとヒープ"><h3>スタックとヒープ</h3></a>
<p>多くのプログラミング言語では、スタックとヒープについて非常に頻繁に考える必要はありません。しかし、Rustのようなシステムプログラミング言語では、値がスタック上にあるかヒープ上にあるかは、言語の振る舞いや特定の決定を下さなければならない理由に大きな影響を与えます。所有権の一部については、この章の後半でスタックとヒープに関連して説明しますので、ここでは簡単な説明をします。</p>
<p>スタックとヒープは実行時にコードで使用できるメモリの一部ですがさまざまな方法で構造化されています。スタックは値を取得した順に値を格納し、逆の順序で値を削除します。これは<em>last in、first out</em>と呼ばれます。プレートのスタックを考えてみましょう。プレートを追加するときはプレートの上に置きプレートが必要なときはプレートを上から外します。中央や底からのプレートの追加や削除もうまくいかないでしょう。データの追加は<em>pushing onto the stack</em>、データの削除は<em>popping off the stack</em>と呼ばれます。</p>
<p>スタックはデータにアクセスする方法が速いため高速です。新しいデータを置く場所やデータを取得する場所を検索する必要はありません。その場所は常に先頭にあるからです。スタックを高速化するもう1つの特性は、スタック上のすべてのデータが既知の固定サイズを占有しなければならないということです。</p>
<p>コンパイル時にサイズが不明なデータまたは変更される可能性があるサイズのデータは代わりにヒープに格納できます。ヒープは体系化されていません。ヒープ上にデータを置くといくらかの容量を要求します。オペレーティングシステムは、ヒープ内のどこかに空きがあり、十分な大きさの空き領域を見つけ出し、使用中であるとマークし、その場所のアドレスである<em>ポインタ</em>を返します。このプロセスは、<em>ヒープ上での割り当て</em>と呼ばれ、時には単に「割り当て」と略されます。スタックに値をプッシュすることは、割り当てとはみなされません。ポインタは既知の固定サイズなので、スタックにポインタを格納することはできますが、実際のデータが必要な場合はポインタをたどらなければなりません。</p>
<p>レストランに座っていると考えてください。あなたが入店するとグループの人の数を述べ、スタッフは人数に合う空のテーブルを見つけ案内します。あなたのグループの誰かが遅れて来たら、あなたを見つけるためにどこに座っているのかを聞くことができます。</p>
<p>ヒープ内のデータへのアクセスは、そこに到達するためのポインタに従わなければならないため、スタック上のデータにアクセスするよりも時間がかかります。現代のプロセッサはメモリが少なくても飛び越えば高速になります。同様のことを続けると、多くのテーブルから注文を受けているレストランのサーバーを考えてみましょう。1つのテーブルですべての注文を取得してから次のテーブルに移動するのが最も効率的です。テーブルAからの注文を受けると、テーブルBからの注文、次にAからの注文、Bからの注文の順番はずっと遅くなります。同様に、プロセッサは、（ヒープ上にあるように）離れているのではなく、（スタック上にある）他のデータに近いデータで動作する場合、その仕事をより良くすることができます。ヒープ上に大量の領域を割り当てることも時間がかかることがあります。</p>
<p>コードが関数を呼び出すと、関数に渡された値（ヒープ上のデータへのポインタを含む）と関数のローカル変数がスタックにプッシュされます。関数が終了すると、それらの値がスタックからポップされます。</p>
<p>ヒープ上のどのデータを使用しているのかを追跡し、ヒープ上の重複データの量を最小限に抑え、ヒープ上の未使用データをクリーンアップしてスペースを使い果たしないようにすることは、 所有権を理解したら、スタックとヒープを頻繁に考える必要はありませんが、ヒープデータを管理することはオーナーシップが存在する理由で、なぜそれが動作するのかを説明するのに役立ちます。</p>
</blockquote>
<a class="header" href="#a所有権ルール" id="a所有権ルール"><h3>所有権ルール</h3></a>
<p>まず、所有権ルールを見てみましょう。 これらのルールを説明する例で作業するときは、これらのルールを念頭に置いてください。</p>
<blockquote>
<ol>
<li>Rustの各値には、<em>owner</em>という変数があります。</li>
<li>一度に所有できるのは1人だけです。</li>
<li>所有者がスコープ外になるとその値は削除されます。</li>
</ol>
</blockquote>
<a class="header" href="#a可変スコープ" id="a可変スコープ"><h3>可変スコープ</h3></a>
<p>2章ですでに書かれているRustプログラムの例を見てきました。<code>fn main() {</code>のコードは例に含まれていないので、次の例を <code>main</code>関数の中に手動で書かなければなりません。その結果、例は少し簡潔になり、定型コードではなく実際の詳細に焦点を当てることができます。</p>
<p>所有権の最初の例として、いくつかの変数の<em>scope</em>を見ていきます。有効範囲は項目が有効なプログラム内の範囲です。次のような変数があるとします。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;hello&quot;;
#}</code></pre></pre>
<p>変数<code>s</code>は文字列リテラルを参照しています。文字列の値はプログラムのテキストにハードコードされています。変数は宣言されているポイントから現在のスコープ*の終わりまで有効です。リスト4-1には変数<code>s</code>が有効な箇所に注釈を付けるコメントがあります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // sはまだ宣言されていないため、ここでは有効ではありません
    let s = &quot;hello&quot;;   // sはこの時点から有効です。

    // sを利用できます
}                      // このスコープは終了し、sは有効ではありません
#}</code></pre></pre>
<p><span class="caption">リスト 4-1: 変数とそのスコープ</span></p>
<p>つまり、ここでは2つの重要なポイントがあります。</p>
<ul>
<li><code>s</code>がスコープ<em>に来たとき</em>に有効です。</li>
<li><em>スコープ外</em>になるまで有効です。</li>
</ul>
<p>この時点でスコープと変数が有効なときの関係は、他のプログラミング言語と同様です。ここではその理解がある前提で、<code>String</code>型を説明します。</p>
<a class="header" href="#string型" id="string型"><h3><code>String</code>型</h3></a>
<p>所有権の規則を説明するには、第3章の「データ型」のセクションで説明したよりも複雑なデータ型が必要です。以前に説明した型はすべてスタックに格納されスコープ終了しましたが、ヒープに格納されているデータを調べRustがそのデータをいつクリーンアップするかを知りたいです。</p>
<p>ここでは例として<code>String</code>を使用し、所有権に関連する<code>String</code>の部分に集中します。これらの側面は、標準ライブラリによって提供され、作成する他の複雑なデータ型にも適用されます。第8章では<code>String</code>について詳しく説明します。</p>
<p>文字列の値がプログラムにハードコードされている文字列リテラルは既に見てきました。文字列リテラルは便利ですが、テキストを使用したいあらゆる状況には適していません。1つの理由は、それらが不変であるということです。もう1つは、コードを書くときに文字列の値がすべてわかっているわけではないことです。たとえば、ユーザーの入力を受け取り、格納する場合はどうすればいいでしょうか？このような状況の場合、Rustは2つ目の文字列として<code>String</code>型を持っています。この型はヒープ上に割り当てられ、コンパイル時にはわからない量のテキストを格納することができます。<code>from</code>関数を使って文字列リテラルから<code>String</code>を作ることができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);
#}</code></pre></pre>
<p>二重コロン(<code>::</code>)は、<code>String</code>型のような何らかの種類の名前を使うのではなく、<code>String</code>型の下でこの特定の<code>from</code>関数の名前空間を許す演算子です。この構文については、第5章の「メソッドの構文」の節と、第7章の「モジュールツリーの項目を参照するためのパス」のモジュールの名前空間について説明します。</p>
<p>この種の文字列は変更することが<em>できます</em>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str()は文字列にリテラルを追加します

println!(&quot;{}&quot;, s); // これは'hello, world!'を表示します。
#}</code></pre></pre>
<p>違いは何でしょうか？なぜ<code>String</code>は変更することができますが、リテラルはできないのでしょうか？違いは、これらの2つの型がメモリをどう扱うかです。</p>
<a class="header" href="#aメモリと割り当て" id="aメモリと割り当て"><h3>メモリと割り当て</h3></a>
<p>文字列リテラルの場合、コンパイル時に内容がわかるので、テキストは最終実行ファイルに直接ハードコードされます。これが、文字列リテラルが高速で効率的な理由です。しかし、これらのプロパティは文字列リテラルの不変性からのみ発生します。残念ながら、コンパイル時にサイズが不明で、プログラムの実行中にサイズが変更される可能性がある各テキストのバイナリには、一塊のメモリを入れることはできません。</p>
<p><code>String</code>型では変更可能な拡張可能なテキストをサポートするために、コンパイル時には分からないヒープ上に、内容を保持するためのメモリ量を割り当てる必要があります。これの意味は、</p>
<ul>
<li>実行時にオペレーティングシステムからメモリを要求する必要があります。</li>
<li><code>String</code>が終わったらこのメモリをオペレーティングシステムに返す方法が必要です。</li>
</ul>
<p>最初の部分は自分たちの手で行われます。<code>String::from</code>を呼び出すとき、その実装は必要なメモリを要求します。これはプログラミング言語ではかなり普遍的です。</p>
<p>しかし、2つめの部分は異なります。*ガベージコレクタ(GC)*を持つ言語では、GCは使用されていないメモリを追跡してクリーンアップします。したがって、そのことについて考える必要はありません。GCがなければ、メモリが使用されなくなった時点を特定し、明示的に返すためにコードを呼び出すことは、自分が要求したのと同じです。これを正しく行うことは、歴史的にはプログラミング上の困難な問題でした。忘れてしまったら、メモリを浪費します。早すぎると無効な変数が返されます。それを2回行うとそれもバグになります。厳密に1回の<code>free</code>と1回の<code>allocate</code>をペアにする必要があります。</p>
<p>Rustは別の方法をとります。変数がスコープ外になるとメモリは自動的に返されます。リスト4-1のスコープの例は、文字列リテラルの代わりに<code>String</code>を使用したものです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;hello&quot;); // sはこの時点から有効です

    // sを利用できます
}                                  // このスコープは終了し
                                   // sは有効ではありません
#}</code></pre></pre>
<p><code>String</code>が必要とするメモリをオペレーティングシステムに返すことができる自然なポイントがあります。<code>s</code>がスコープ外になるときです。変数がスコープから外れると、Rustは特別な関数を呼び出します。この関数は<code>drop</code>と呼ばれ、<code>String</code>の作成者がメモリを返すためのコードを置く場所です。Rustは<code>}</code>の終了時に<code>drop</code>を自動的に呼び出します。</p>
<blockquote>
<p>注：C++ではアイテムの有効期間の終わりにリソースを解放するこのパターンは「リソース取得初期化(RAII)」と呼ばれることもあります。RAIIパターンを使用していればRustの<code>drop</code>機能はなじみやすいでしょう。</p>
</blockquote>
<p>このパターンはRustのコードが書き方に大きな影響を与えます。今のところ単純に思えるかもしれませんが、ヒープ上に割り当てたデータを複数の変数で使用したい場合、複雑な状況ではコードの動作が予期しないことがあります。これらの例のいくつか見てみましょう。</p>
<a class="header" href="#a変数とデータのやり取り方法移動" id="a変数とデータのやり取り方法移動"><h4>変数とデータのやり取り方法：移動</h4></a>
<p>複数の変数はRustの異なる方法で同じデータとやりとりすることができます。リスト4-2の整数を使用した例を見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">リスト 4-2: 変数<code>x</code>の整数値を<code>y</code>に代入する</span></p>
<p>これが何をしているのかを推測することができます。「値<code>5</code>を<code>x</code>にバインドします。<code>x</code>の値のコピーを作り、これを<code>y</code>にバインドします」。<code>x</code>と<code>y</code>の2つの変数があり、両方とも<code>5</code>になります。整数は既知の固定サイズの単純な値であり、これらの2つの<code>5</code>の値がスタックにプッシュされるということが、実際に起こっていることです。</p>
<p>次に <code>String</code>バージョンを見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>これは前のコードと非常によく似ているので、同じように動作すると仮定します。つまり、2行目は<code>s1</code>の値のコピーを作成し、<code>s2</code>にバインドします。しかし、そうなりません。</p>
<p>図4-1を見て、カバーの下にある <code>String</code>に何が起こっているのかを見てください。<code>String</code>は左に示すように、文字列の内容、長さ、および容量を保持するメモリへのポインタの3つの部分で構成されています。このデータグループはスタックに格納されます。 右側には内容を保持するヒープ上のメモリがあります。</p>
<p><img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">図 4-1: &quot;<code>hello</code>&quot;が<code>s1</code>に束縛されている<code>String</code>のメモリ内の表現</span></p>
<p>長さは、現在使用されている<code>String</code>の内容のバイト単位のメモリ量です。容量は、文字列がオペレーティングシステムから受け取った総メモリ量（バイト単位）です。長さと容量の違いは重要ですが、今のところ容量を無視しても問題ありません。</p>
<p><code>s1</code>を<code>s2</code>に割り当てると、<code>String</code>データがコピーされます。つまり、スタック上にあるポインタ、長さ、および容量をコピーします。ポインタが参照するヒープ上のデータはコピーしません。つまり、メモリ内のデータ表現は図4-2のようになります。</p>
<p><img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">図 4-2: <code>s1</code>のポインタ、長さ、および容量のコピーを持つ変数<code>s2</code>のメモリ内の表現</span></p>
<p>この表現は、図4-3のようにはなりません。Rustがヒープデータを代わりにコピーした場合のメモリの様子です。Rustがこれを行った場合、ヒープ上のデータが大きかった場合、ランタイムパフォーマンスの点で<code>s2 = s1</code>操作は価値が高いです。</p>
<p><img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">図 4-3: Rustがヒープデータを同様にコピーした場合<code>s2 = s1</code>とは別の可能性があります</span></p>
<p>以前、変数がスコープから外れると、Rustは自動的に<code>drop</code>関数を呼び出し、その変数のヒープメモリをクリーンアップすると説明しました。しかし、図4-2は、両方のデータポインタが同じ場所を指していることを示しています。これは問題です。<code>s2</code>と<code>s1</code>がスコープ外になると、彼らは同じメモリを解放しようとします。これは<em>double free</em>エラーとして知られており、これまで説明したメモリの安全性のバグの1つです。メモリを2回解放するとメモリが破損し、セキュリティの脆弱性が発生する可能性があります。</p>
<p>メモリの安全性を確保するために、Rustのこの状況で何が起こるかについてもう少し詳しくみましょう。割り当てられたメモリをコピーしようとするのではなく、Rustは<code>s1</code>がもはや有効ではないと考え<code>s1</code>が有効範囲外になったときにRustは何も解放する必要はありません。<code>s2</code>が作成された後に<code>s1</code>を使用しようとすると何が起きるかを調べてください。それは動作しません。</p>
<pre><code class="language-rust ignore does_not_compile">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<p>Rustは無効化された参照を使用できないため、次のようなエラーが発生します。</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>他の言語で作業しているときに<em>シャローコピー</em>と<em>ディープコピー</em>という言葉を聞いたことがあるならば、データをコピーせずにポインタ、長さ、容量をコピーするというコンセプトはシャローコピーのように聞こえるでしょう。しかし、Rustは最初の変数を無効にするので、シャローコピーと呼ぶ代わりに、<em>移動</em>と呼びます。ここでは<code>s1</code>が<code>s2</code>に移動したといいます。実際に何が起こるかを図4-4に示します。</p>
<p><img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">図 4-4: <code>s1</code>の後のメモリ内の表現は無効にされました</span></p>
<p>これで問題が解決されます。<code>s2</code>だけが有効で範囲外になるとそれだけでメモリが解放され完了です。</p>
<p>さらに、Rustは自動的にデータの「ディープ」コピーを作成することはありません。したがって、<em>自動</em>コピーは、ランタイムパフォーマンスの点で安価であるとみなすことができます。</p>
<a class="header" href="#a変数とデータのやりとり方法クローン" id="a変数とデータのやりとり方法クローン"><h4>変数とデータのやりとり方法：クローン</h4></a>
<p>スタックデータだけでなく、<code>String</code>のヒープデータをディープコピーしたい場合は、<code>clone</code>という一般的なメソッドを使用することができます。第5章ではメソッド構文について説明しますが、メソッドは多くのプログラミング言語で共通の機能です。</p>
<p>実際の<code>clone</code>メソッドの例を以下に示します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>これは正常に動作し、ヒープデータがコピー<em>される</em>図4-3のような動作を明示的に生成します。</p>
<p><code>clone</code>の呼び出しを見ると任意のコードが実行されていてコードが高価になることがあります。これは何か違うことが起こっているという視覚的な指標です。</p>
<a class="header" href="#aスタックオンリーデータコピー" id="aスタックオンリーデータコピー"><h4>スタックオンリーデータ：コピー</h4></a>
<p>まだ説明していない別の問題があります。前述のコードリスト4-2の一部を示した整数を使用するこのコードは機能して有効です。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>しかし、このコードはちょうど学んだことと矛盾しているようです。<code>clone</code>を呼び出していませんが、<code>x</code>はまだ有効で<code>y</code>に移動しませんでした。</p>
<p>その理由はコンパイル時に既知のサイズを持つ整数などの型はスタック全体に格納されるため、実際の値のコピーはすばやく作成できるからです。つまり、変数<code>y</code>を作成した後<code>x</code>を無効にしたいという理由はありません。言い換えれば、ここではディープコピーとシャローコピーの間に違いはないので<code>clone</code>を呼び出すことは、通常のシャローコピーとは何も変わりません。</p>
<p>Rustにはスタックに格納されている整数のような型に置くことができる<code>Copy</code>トレイトという特殊なアノテーションがあります（第10章のトレイトについて詳しく説明します）。型に<code>Copy</code>トレイトがある場合、割り当て後に古い変数を引き続き使用することができます。Rustは型またはその部分のいずれかが<code>Drop</code>トレイトを実装している場合、型に<code>Copy</code>トレイトを付けることはできません。値がスコープ外になり、その型に<code>Copy</code>アノテーションを追加する際に型が特別なことを必要とする場合、コンパイル時エラーが発生します。自分の型に<code>Copy</code>アノテーションを追加する方法については、Appedix Cの「Derivable Traits」を参照してください。</p>
<p>どのようなタイプの<code>コピー</code>かは、与えられた型のドキュメントを確かめることができますが、原則として、単純なスカラー値のグループは<code>Copy</code>であり、割り当てを必要とするものや何らかの形のリソースは<code>Copy</code>です。<code>Copy</code>であるいくつかの型があります。</p>
<ul>
<li><code>u32</code>のようなすべての整数型。</li>
<li>ブール型<code>bool</code>は、値が<code>true</code>と<code>false</code>です。</li>
<li><code>f64</code>のようなすべての浮動小数点型。</li>
<li>文字型、<code>char</code>。</li>
<li>タプル、それらが<code>Copy</code>である型だけを含む場合。たとえば、<code>(i32, i32)</code>は<code>Copy</code>ですが、<code>(i32, String)</code>はそうではありません。</li>
</ul>
<a class="header" href="#a所有権と機能" id="a所有権と機能"><h3>所有権と機能</h3></a>
<p>関数に値を渡すセマンティクスは、変数に値を代入するセマンティクスと同様です。変数に関数を渡すと、割り当てと同じように移動またはコピーされます。コードリスト4-3には、変数がスコープのどこに出入りするかを示すアノテーションの例があります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // sはスコープに入ります

    takes_ownership(s);             // sの値が関数に移ります ...
                                    // ... もう有効ではありません

    let x = 5;                      // xはスコープに入ります

    makes_copy(x);                  // xは関数に移動します
                                    // しかし、i32はコピーなので、後でxを使うことができます

} // ここで、xはスコープ外になり、次にsがスコープ外になります。
  // しかし、sの値が動かされたので、特別なことは起こりません。

fn takes_ownership(some_string: String) { // some_stringがスコープに入ります
    println!(&quot;{}&quot;, some_string);
} // ここで、some_stringはスコープ外になり、`drop`が呼び出されます
  // バッキングメモリが解放されます

fn makes_copy(some_integer: i32) { // some_integerがスコープに入ります
    println!(&quot;{}&quot;, some_integer);
} // ここで、some_integerはスコープ外になりますが、何も特別なことは起こりません
</code></pre></pre>
<p><span class="caption">リスト 4-3: 所有権とスコープがアノテーション付きの関数</span></p>
<p><code>takes_ownership</code>の呼び出しの後に<code>s</code>を使用しようとすると、Rustはコンパイル時エラーを投げます。これらの静的チェックは、間違いから守ります。<code>main</code>に<code>s</code>と<code>x</code>を使うコードを追加して、どこでそれらを使うことができるのか、そして所有権の規則がそうしないところを見てみてください。</p>
<a class="header" href="#a戻り値と範囲" id="a戻り値と範囲"><h3>戻り値と範囲</h3></a>
<p>値を返すことで所有権を譲渡することもできます。リスト4-4は、リスト4-3のアノテーションと似たアノテーションを持つ例です。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // give_ownershipは戻り値をs1に移動します

    let s2 = String::from(&quot;hello&quot;);     // s2がスコープに入ります

    let s3 = takes_and_gives_back(s2);  // s2はtakes_and_gives_backに移動され、
                                        // 戻り値もs3に移動します
} // ここで、s3はスコープ外になり、削除されます。s2はスコープ外になりましたが、
  // 移動されたので何も起こりません。s1はスコープ外になり、削除されます

fn gives_ownership() -&gt; String {             // give_ownershipは戻り値を
                                             // 呼び出し元の関数に返します

    let some_string = String::from(&quot;hello&quot;); // some_stringがスコープに入ります

    some_string                              // some_stringが返され、
                                             // 呼び出し元の関数に移動します
}

// takes_and_gives_backはStringを受けとり、それを返します。
fn takes_and_gives_back(a_string: String) -&gt; String { // a_stringがスコープに入ります

    a_string  // a_stringが返され、呼び出し元の関数に移動します
}
</code></pre></pre>
<p><span class="caption">リスト 4-4: 戻り値の所有権の転送</span></p>
<p>変数の所有権は毎回同じパターンに従います。別の変数に値を代入すると変数が移動します。ヒープ上のデータを含む変数がスコープ外になると、データが別の変数によって所有されるように移動されていない限り値は<code>drop</code>によってクリーンアップされます。</p>
<p>所有権を取得してから、すべての機能で所有権を返すのはちょっと面倒です。関数に値を使用させ、所有権を持たせたくない場合はどうすればよいですか？渡したものも、関数本体から返されるデータに加えてそれを再び使用したい場合には戻す必要があるということはとても厄介です。</p>
<p>リスト4-5に示すように、タプルを使用して複数の値を返すことができます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
</code></pre></pre>
<p><span class="caption">リスト 4-5: 引数の所有権を返す</span></p>
<p>しかし、これはあまりにも多くの手順があり、一般的なことをするためには多くの作業が発生します。幸いなことに、Rustには<em>参照</em>というこのコンセプトの特徴があります。</p>
<a class="header" href="#a参照と借用" id="a参照と借用"><h2>参照と借用</h2></a>
<p>コードリスト4-5のタプルコードの問題は、<code>String</code>を呼び出し関数に返さなければならないということです。なぜなら、<code>calculate_length</code>の呼び出しの後に<code>String</code>を使用できるようにするためです。</p>
<p>値の所有権を取得するのではなく、オブジェクトへの参照を引数として持つ<code>calculate_length</code>関数を定義して使用する方法は次のとおりです。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>最初に変数宣言内のすべてのタプルコードと関数の戻り値がなくなったことに注目してください。次に<code>&amp;s1</code>を<code>calculate_length</code>に渡す定義において、<code>String</code>ではなく<code>&amp;String</code>にしていることに注目してください。</p>
<p>これらのアンパサンドは<em>参照</em>であり、あなたはそれを所有することなく何らかの値を参照することができます。図4-5にダイアグラムを示します。</p>
<p><img alt="`String s1`を指す`&String s`" src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">図 4-5: <code>String s1</code>を指す<code>&amp;String s</code>の図</span></p>
<blockquote>
<p>注：<code>&amp;</code>を使って参照することの逆は<em>逆参照</em>であり、逆参照演算子<code>*</code>で行われます。第8章では逆参照演算子をいくつか使用し、第15章では逆参照の詳細について説明します。</p>
</blockquote>
<p>ここで関数呼び出しを詳しく見てみましょう</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calculate_length(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
#}</code></pre></pre>
<p><code>&amp;s1</code>は<code>s1</code>の値を<em>参照</em>していますが、それを所有していない参照を作成させます。所有していないので、スコープ外になっても、その参照元が指している値は削除されません。</p>
<p>同様に関数のシグニチャは<code>&amp;</code>を使用して、引数<code>s</code>の型が参照であることを示します。説明のコメントを追加しましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calculate_length(s: &amp;String) -&gt; usize { // sは文字列への参照
    s.len()
} // ここで、sはスコープ外になる。しかし、それは所有権を持っていないため
  // 何も起こりません。
#}</code></pre></pre>
<p>変数<code>s</code>が有効なスコープは、関数の引数のスコープと同じですが、所有権を持たないためスコープから外れるときに参照が指すものを削除しません。関数が実際の値ではなく引数として参照を持つ場合、所有権を持たないため、所有権を返すために値を返す必要はありません。</p>
<p>これを関数引数の<em>借用</em>として参照を持つといいます。実際の生活の場合と同様に、人が何かを所有していればその人からそれを借りることができます。使い終わったらそれを返さなければなりません。</p>
<p>借りているものを変更しようとするとどうなりますか？リスト4-6のコードを試してみてください。それは動作しません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">リスト 4-6: 借用した値を変更しようとする</span></p>
<p>次のようなエラーになります。</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
 --&gt; error.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- use `&amp;mut String` here to make mutable
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>デフォルトで変数が不変であるのと同じように参照もそうです。参照しているものを変更することはできません。</p>
<a class="header" href="#a変更可能な参照" id="a変更可能な参照"><h3>変更可能な参照</h3></a>
<p>リスト4-6のコードのエラーを少し修正ことで実現できます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>まず、<code>s</code>を<code>mut</code>に変更しなければなりませんでした。次に<code>&amp;mut s</code>で可変参照を作成し<code>some_string: &amp;mut String</code>で可変参照を受け入れる必要があります。</p>
<p>しかし、変更可能な参照には大きな制限があります。特定のスコープ内の特定のデータに対して、1つの変更可能な参照のみを持つことができます。そのため、次のコードはエラーになります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
</code></pre>
<p>次のようなエラーになります。</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:10
  |
4 | let r1 = &amp;mut s;
  |          ------ first mutable borrow occurs here
5 | let r2 = &amp;mut s;
  |          ^^^^^^ second mutable borrow occurs here
6 | println!(&quot;{}, {}&quot;, r1, r2);
  |                    -- borrow later used here
</code></pre>
<p>この制限は変化を可能にしますが、非常に制御された方法です。新しいRust開発者が苦労しているのは、ほとんどの言語が好きなときにいつでも変更できるからです。</p>
<p>この制限を受ける利点は、Rustがコンパイル時にデータ競合を防止できることです。<em>データ競合</em>は競合状態と似ており、次の3つの動作が発生すると生じます。</p>
<ul>
<li>2つ以上のポインタが同じデータに同時にアクセスします</li>
<li>少なくとも1つのポインタがデータの書き込みに使用されています</li>
<li>データへのアクセスを同期するためのメカニズムはありません</li>
</ul>
<p>データ競合は未定義の動作を引き起こし、実行時にそれらを追跡しようとしているときに診断して修正するのが難しい場合があります。Rustは、データ競合でコードをコンパイルしないのでこの問題が起こらないようにします。</p>
<p>中括弧を使用して新しいスコープを作成することで、<em>同時</em>でなければ複数の変更可能な参照を許可します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1はここで範囲外になるので、問題なく新しい参照を作成できます。

let r2 = &amp;mut s;
#}</code></pre></pre>
<p>可変と不変の参照を組み合わせるための同様の規則が存在します。このコードはエラーになります。</p>
<pre><code class="language-rust ignore does_not_compile">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // 問題なし
let r2 = &amp;s; // 問題なし
let r3 = &amp;mut s; // 大きな問題

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
</code></pre>
<p>次のようなエラーになります。</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:10
  |
4 | let r1 = &amp;s; // 問題なし
  |          -- immutable borrow occurs here
5 | let r2 = &amp;s; // 問題なし
6 | let r3 = &amp;mut s; // 大きな問題
  |          ^^^^^^ mutable borrow occurs here
7 | 
8 | println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                            -- borrow later used here
</code></pre>
<p>また、不変のものがある間<em>も</em>参照を変更することはできません。不変参照のユーザーは値が突然外から変更されることを期待しません。しかし、複数の不変参照は大丈夫です。データを読み込んでいる誰も他の人のデータの読み書きに影響を与えることはできないからです。</p>
<p>これらのエラーは時には苛立つかもしれませんが、Rustコンパイラは潜在的なバグを早期に（実行時ではなくコンパイル時に）発見し、問題のある場所を正確に示しています。そのためデータが思っていたものではない理由を追跡する必要はありません。</p>
<a class="header" href="#aダングリング-リファレンス" id="aダングリング-リファレンス"><h3>ダングリング リファレンス</h3></a>
<p>ポインタを持つ言語では、メモリへのポインタを保持しながらメモリを解放することで、他の人に与えられた可能性のあるメモリ内の位置を参照するポインタ「<em>ダングリング ポインタ</em>」を簡単に誤って作成できてしまいます。対照的にRustでは、コンパイラはダングリング リファレンスが決して参照されないことを保証します。データへの参照がある場合、コンパイラはデータへの参照が範囲外にならないようにします。</p>
<p>Rustがコンパイル時のエラーで防ぐことのできない、手間のかかる参照を作成しようとしましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>次のようなエラーになります。</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; dangle.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p>このエラーメッセージは、<em>ライフタイム</em>というまだ説明していない機能を示しています。第10章ではライフタイムについて詳しく説明します。しかし、ライフタイムについての部分を無視すると、メッセージにはなぜこのコードが問題であるかの鍵が含まれています。</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<p><code>dangle</code>コードの各段階で何が起こっているのかを詳しく見てみましょう。</p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangleはStringへの参照を返します

    let s = String::from(&quot;hello&quot;); // sは新しいString

    &amp;s // String sへの参照を返します。
} // ここでは範囲外になり削除されます。メモリから消える
  // 危険！
</code></pre>
<p><code>dangle</code>の中に<code>s</code>が作成されているので、<code>dangle</code>のコードが終了すると、<code>s</code>は割り当て解除されます。しかし、それへの参照を返そうとしました。これは、この参照が無効な<code>String</code>を指していることを意味します。Rustはこれをさせません。</p>
<p>ここでの解決策は<code>String</code>を直接返すことです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
#}</code></pre></pre>
<p>これは問題なく動作します。所有権が移動され、割り当てが解除されないからです。</p>
<a class="header" href="#a参照ルール" id="a参照ルール"><h3>参照ルール</h3></a>
<p>参照について論じた内容をまとめましょう。</p>
<ul>
<li>任意の時点で、1つの変更可能参照または任意の数の不変参照を持つことができます。</li>
<li>参照は常に有効でなければなりません。</li>
</ul>
<p>次にスライスという異なる種類の参照を見てみましょう。</p>
<a class="header" href="#aスライス" id="aスライス"><h2>スライス</h2></a>
<p>所有権を持たない別のデータ型は<em>スライス</em>です。スライスを使用すると、コレクション全体ではなくコレクション内の要素の連続したシーケンスを参照できます。</p>
<p>小さなプログラミング上の問題があります。文字列をとり、その文字列で見つかった最初の単語を返す関数を書くとします。関数が文字列内にスペースを見つけられない場合は、文字列全体が1つの単語でなければならないため、文字列全体が返されるとします。</p>
<p>この関数のシグニチャについて考えてみましょう。</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>この関数<code>first_word</code>は、引数として<code>&amp;String</code>を持っています。今回は所有権を望まないのでこれは問題ありません。しかし、何を返すべきですか？実際に文字列の<em>部分</em>について話す方法を持っていません。しかし、単語の終わりのインデックスを返すことができます。リスト4-7に示すように、それを試してみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<p><span class="caption">リスト 4-7: <code>String</code>引数のスペースのインデックス値を返す<code>first_word</code>関数</span></p>
<p><code>String</code>要素を要素単位で調べ、値が空白かどうかをチェックする必要があるので、<code>as_bytes</code>メソッドを使って、<code>String</code>をバイトの配列に変換します。</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>次に、<code>iter</code>メソッドを使用してバイト配列のイテレータを作成します。</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>イテレータについては第13章で詳しく説明します。今の段階では<code>iter</code>はコレクション内の各要素を返すメソッドであり、<code>iter</code>の結果を<code>enumerate</code>でラップして、各要素をタプルの一部として返すメソッドであることに注意してください。<code>enumerate</code>から返されたタプルの最初の要素はインデックスであり、2番目の要素は要素への参照です。これは、インデックスを自分で計算するよりも少し便利です。</p>
<p><code>enumerate</code>メソッドはタプルを返すので、Rustの他の場所と同様に、パターンを使ってそのタプルを破棄することができます。したがって、<code>for</code>ループではタプルのインデックスに<code>i</code>を、タプルに1バイトの<code>&amp;item</code>を持つパターンを指定します。<code>.iter().enumerate()</code>から要素への参照を取得するので、パターンには<code>&amp;</code>を使います。</p>
<p><code>for</code>ループの中で、バイトリテラル構文を使ってスペースを表すバイトを検索します。スペースを見つけるとその位置を返します。それ以外の場合は、<code>s.len()</code>を使って文字列の長さを返します。</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>文字列の最初の単語の終わりのインデックスを見つける方法がありますが問題があります。それ自身で<code>usize</code>を返していますが、<code>&amp;String</code>の文脈では意味のある数字です。言い換えれば、<code>String</code>とは別の値なので、それが将来有効であるという保証はありません。リスト4-7の <code>first_word</code>関数を使用するリスト4-8のプログラムを考えてみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // wordは値5を取得します

    s.clear(); // これは文字列を空にし&quot;&quot;と等しくします

    // wordはここでも値5を持っていますが、意味のある値5を使用できるStringはありません。 
    // wordが完全に無効になりました！
}
</code></pre></pre>
<p><span class="caption">リスト 4-8: <code>first_word</code>関数を呼び出して結果を格納し<code>String</code>の内容を変更します</span></p>
<p>このプログラムはエラーなしでコンパイルされ<code>s.clear()</code>を呼び出した後に<code>word</code>を使用した場合も同様です。<code>word</code>は<code>s</code>の状態に全く接続されていないので<code>word</code>は値<code>5</code>を含んでいます。この値に<code>s</code>を変数<code>s</code>で使用して最初の単語を抽出しようとしましたが、<code>word</code>に<code>5</code>を保存してから<code>s</code>の内容が変わったのでバグでしょう。</p>
<p><code>word</code>のインデックスが<code>s</code>のデータと同期しなくなることを心配するのは退屈でエラーが起こりやすいです。<code>second_word</code>関数を書くと、これらのインデックスを管理することはさらに脆弱になります。そのシグニチャは次のようになります。</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>ここでは開始位置と終了位置を追跡していますが、特定の状態のデータから計算された値はさらに多くなりますが、その状態にまったく結びついていません。3つの無関係な変数を浮動させて、同期させておく必要があります。</p>
<p>Rustには文字列スライスというこの問題の解決策があります。</p>
<a class="header" href="#a文字列スライス" id="a文字列スライス"><h3>文字列スライス</h3></a>
<p><em>文字列スライス</em>は<code>String</code>の一部への参照であり次のようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
#}</code></pre></pre>
<p>これは<code>String</code>全体を参照するのと似ていますが、余分な<code>[0..5]</code>ビットが付いています。<code>String</code>全体への参照ではなく<code>String</code>の一部への参照です。<code>start..end</code>構文は、<code>start</code>で始まり<code>end</code>まで続く範囲です。<code>end</code>を含めたい場合、<code>..</code>の代わりに<code>..=</code>を使うことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..=4];
let world = &amp;s[6..=10];
#}</code></pre></pre>
<p><code>=</code>は <code>..</code>と<code>..=</code>の違いは最後の数字を含めるかどうかで覚えておくと良いでしょう。</p>
<p><code>[starting_index..ending_index]</code>を指定することで括弧内のスコープを使用してスライスを作成できます。ここで<code>beginning_index</code>はスライスの最初の位置で、<code>ending_index</code>はスライスの最後の位置より1つ多くなります。内部的にはスライスデータ構造はスライスの開始位置と長さを格納します。これは<code>ending_index</code>から<code>starting_index</code>を差し引いたものに相当します。したがって、<code>let world = &amp;s[6..11];</code>の場合、<code>world</code>は<code>s</code>の7番目のバイトと5の長さの値を指すポインタを含むスライスになります。</p>
<p>図4-6にこれを示します。</p>
<p><img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">図 4-6: <code>String</code>の一部を参照する文字列スライス</span></p>
<p>Rustの<code>..</code>のスコープ構文では、最初のインデックス(ゼロ)から開始する場合は2つのピリオドの前に値をドロップできます。言い換えればこれらは等しいです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>同じトークンでスライスに<code>String</code>の最後のバイトが含まれている場合は、末尾の数字を削除することができます。これは、これらが等しいことを意味します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>両方の値をドロップして、文字列全体をスライスすることもできます。したがって、これらは等しいです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
#}</code></pre></pre>
<blockquote>
<p>注意：文字列スライス範囲のインデックスは有効なUTF-8文字境界で指定する必要があります。マルチバイト文字の途中で文字列スライスを作成しようとすると、プログラムはエラーで終了します。文字列スライスを導入する目的で、このセクションでのみASCIIを仮定しています。UTF-8処理のより詳細な説明は、第8章の「文字列」のセクションにあります。</p>
</blockquote>
<p>この情報を念頭に置いて、スライスを返すために<code>first_word</code>を書き直してみましょう。&quot;string slice&quot;を表す型は<code>&amp;str</code>と書かれています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>リスト4-7と同じ方法で単語の終わりのインデックスを取得します。スペースの最初のオカレンスを探します。スペースを見つけると文字列の始まりとスペースのインデックスを開始と終了のインデックスとして使用して文字列スライスを返します。</p>
<p><code>first_word</code>を呼び出すと、基礎となるデータに結びついた単一の値が返されます。値はスライスの開始点への参照とスライス内の要素の数で構成されます。</p>
<p>スライスを返すことは<code>second_word</code>関数のためにも機能します。</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>コンパイラは<code>String</code>への参照が有効であることを保証するので、簡単なAPIを持っています。リスト4-8のプログラムのバグを覚えておいてください。最初の単語の終わりまでインデックスを取得した後、インデックスを無効にするために文字列をクリアした場合はどうでしょうか？そのコードは論理的に間違っていましたが、即時のエラーは表示されませんでした。空文字列で最初の単語インデックスを使用しようとした場合、問題が後で表示されます。スライスはこのバグを不可能にし、コードの問題がはるかに早いことを知らせます。<code>first_word</code>のスライス版を使用すると、コンパイル時エラーが発生します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // エラー！

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p>コンパイラのエラーは次のとおりです。</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:10:5
   |
8  |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
9  | 
10 |     s.clear(); // エラー！
   |     ^^^^^^^^^ mutable borrow occurs here
11 |     
12 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- borrow later used here
</code></pre>
<p>借用のルールから、何かへの不変な参照があれば、変更可能な参照を取ることができないことを思い出してください。<code>clear</code>は<code>String</code>を切り捨てる必要があるため、変更可能な参照を取得しようとしますが失敗します。RustはAPIを使いやすくしただけでなく、コンパイル時にクラス全体のエラーをなくしました。</p>
<a class="header" href="#a文字列リテラルはスライス" id="a文字列リテラルはスライス"><h4>文字列リテラルはスライス</h4></a>
<p>バイナリの内部に格納されている文字列リテラルについて話したことを思い出してください。スライスについて知ったので、文字列リテラルを正しく理解することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Hello, world!&quot;;
#}</code></pre></pre>
<p><code>s</code>の型は<code>&amp;str</code>です。これはバイナリの特定の点を指すスライスです。これは文字列リテラルが不変である理由です。<code>&amp;str</code>は不変の参照です。</p>
<a class="header" href="#a引数としての文字列スライス" id="a引数としての文字列スライス"><h4>引数としての文字列スライス</h4></a>
<p>リテラルと<code>String</code>のスライスを取ることができることを知っていると、<code>first_word</code>の改善点が1つ増えています。</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>経験豊富なRust開発者は<code>String</code>と<code>str</code>の両方で同じ関数を使うことができるので代わりに次のように書くでしょう。</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>文字列スライスがある場合はそれを直接渡すことができます。<code>String</code>を持っていれば<code>String</code>全体のスライスを渡すことができます。<code>String</code>への参照の代わりに文字列スライスを取る関数を定義することは、APIを機能を失うことなく、より一般的かつ有用なものにします。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word works on slices of `String`s
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word works on slices of string literals
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<a class="header" href="#aその他のスライス" id="aその他のスライス"><h3>その他のスライス</h3></a>
<p>想像の通り、文字列スライスは文字列に固有のものです。しかし、より一般的なスライスタイプもあります。
この配列を考えてみましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>文字列の一部を参照したいのと同じように、配列の一部を参照することもできます。次のようにします。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>このスライスは<code>&amp;[i32]</code>型です。これは最初の要素と長さへの参照を格納することによって、文字列スライスと同じように動作します。この種のスライスをあらゆる種類の他のコレクションに使用します。これらのコレクションについては、第8章のベクトルについて説明します。</p>
<a class="header" href="#aまとめ-3" id="aまとめ-3"><h2>まとめ</h2></a>
<p>所有権、借用、およびスライスの概念は、コンパイル時にRustプログラムにおけるメモリの安全性を保証します。Rust言語は、他のシステムプログラミング言語と同じ方法でメモリ使用量を制御できますが、所有者が範囲外になったときにデータ所有者がデータを自動的にクリーンアップするということは、追加コードを記述したりデバッグする必要なくこの制御を得ることができます。</p>
<p>所有権はRustの他の部分のどれくらいが影響を受けるのかに影響を及ぼします。そのためこれらの概念については残りの部分でさらに詳しく説明します。第5章に進み<code>struct</code>でデータをまとめてみましょう。</p>
<a class="header" href="#a構造体を使用して関係のあるデータを構造化する" id="a構造体を使用して関係のあるデータを構造化する"><h1>構造体を使用して関係のあるデータを構造化する</h1></a>
<p><em>struct</em>または<em>structure</em>は、意味のあるグループを構成する関連する複数の値をまとめて名前を付けてパッケージ化するカスタムデータ型です。オブジェクト指向言語に慣れているなら<em>構造体</em>はオブジェクトのデータ属性に似ています。この章では、タプルと構造体の比較と対比、構造体の使用方法のデモンストレーション、構造体のデータに関連付けられた動作を指定するメソッドと関連する関数の定義方法について説明します。構造体と列挙型（第6章で説明）は、プログラムのドメインに新しい型を作成して、Rustのコンパイル時の型チェックを最大限に活用するためのビルディングブロックです。</p>
<a class="header" href="#a構造体を定義しインスタンス化する" id="a構造体を定義しインスタンス化する"><h2>構造体を定義し、インスタンス化する</h2></a>
<p>構造体は第3章で説明したタプルに似ています。タプルのように構造体の断片は異なる型にすることができます。タプルとは異なり、各データに名前を付けて、値の意味を明確にします。これらの名前の結果、構造体はタプルよりも柔軟性があります。つまり、インスタンスの値を指定またはアクセスするためにデータの順序に頼る必要はありません。</p>
<p>構造体を定義するためにキーワード<code>struct</code>を入力し、構造体全体の名前を付けます。構造体の名前は一緒にグループ化されるデータの重要性を記述する必要があります。次に中括弧の中でデータの名前と型を定義します。これは<em>フィールド</em>と呼ばれます。たとえば、リスト5-1はユーザーアカウントに関する情報を格納する構造体を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
#}</code></pre></pre>
<p><span class="caption">リスト 5-1: <code>User</code>構造体の定義</span></p>
<p>構造体を定義した後でそれを使用するには、各構造体の具体的な値を指定して構造体の<em>インスタンス</em>を作成します。構造体の名前を記述してインスタンスを作成し<code>key：value</code>ペアを含む中括弧を追加します。ここでキーはフィールドの名前であり、値はこれらのフィールドに格納するデータです。構造体で宣言したのと同じ順序でフィールドを指定する必要はありません。言い換えれば、構造体の定義は型の一般的なテンプレートのようであり、インスタンスは型の値を作成するための特定のデータでそのテンプレートを埋めます。たとえば、リスト5-2に示すように特定のユーザーを宣言することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
#}</code></pre></pre>
<p><span class="caption">リスト 5-2: <code>User</code>構造体のインスタンスを作成する</span></p>
<p>構造体から特定の値を取得するには、ドット表記法を使用できます。このユーザの電子メールアドレスだけが必要な場合は、この値を使用したい場合はいつでも<code>user1.email</code>を使用できます。インスタンスが変更可能な場合は、ドット表記を使用して特定のフィールドに値を割り当てることで値を変更できます。リスト5-3は変更可能な<code>User</code>インスタンスの<code>email</code>フィールドの値を変更する方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from(&quot;anotheremail@example.com&quot;);
#}</code></pre></pre>
<p><span class="caption">リスト 5-3: <code>User</code>インスタンスの<code>email</code>フィールドの値を変更する</span></p>
<p>インスタンス全体は変更可能でなければならないことに注意してください。Rustは特定のフィールドだけを変更可能としてマークすることはできません。</p>
<p>任意の式と同様に関数本体の最後の式として構造体の新しいインスタンスを構築して、その新しいインスタンスを暗黙的に返すことができます。コードリスト5-4は与えられた電子メールとユーザ名を持つ<code>User</code>インスタンスを返す<code>build_user</code>関数を示しています。<code>active</code>フィールドは<code>true</code>の値をとり、<code>sign_in_count</code>は<code>1</code>の値を得ます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 5-4: emailとusernameをとり、<code>User</code>インスタンスを返す<code>build_user</code>関数</span></p>
<p>構造体フィールドと同じ名前の関数引数に名前を付けるのは理にかなっていますが、<code>email</code>と<code>username</code>フィールド名と変数を繰り返さなければならないのはちょっと面倒です。構造体にさらにフィールドがある場合は、それぞれの名前を繰り返すとさらに複雑になります。そのため便利な略記があります。</p>
<a class="header" href="#aフィールド初期化の使用変数とフィールドの名前が同じ場合の省略形" id="aフィールド初期化の使用変数とフィールドの名前が同じ場合の省略形"><h3>フィールド初期化の使用変数とフィールドの名前が同じ場合の省略形</h3></a>
<p>引数名と構造体フィールド名はリスト5-4と全く同じですので、<em>フィールド初期化簡略</em>構文を使用して<code>build_user</code>を書き直してまったく同じように動作しますが、リスト5-5に示すように<code>email</code>と<code>username</code>を呼び出します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 5-5: <code>email</code>と<code>username</code>引数がstructフィールドと同じ名前を持つので、フィールド初期化を使う<code>build_user</code>関数</span></p>
<p>ここでは、<code>email</code>という名前のフィールドを持つ<code>User</code>構造体の新しいインスタンスを作成しています。<code>email</code>フィールドの値を<code>build_user</code>関数の<code>email</code>引数の値に設定します。<code>email</code>フィールドと<code>email</code>引数は同じ名前なので、<code>email: email</code>ではなく<code>email</code>と書くだけです。</p>
<a class="header" href="#a構造体のアップデート構文を使用して他のインスタンスからインスタンスを作成する" id="a構造体のアップデート構文を使用して他のインスタンスからインスタンスを作成する"><h3>構造体のアップデート構文を使用して他のインスタンスからインスタンスを作成する</h3></a>
<p>古いインスタンスの値の大部分を使用するが、いくつかを変更する構造体の新しいインスタンスを作成すると便利なことがよくあります。<em>構造体アップデート構文</em>を使用してこれを行います。</p>
<p>まず、リスト5-6はアップデート構文なしで<code>user2</code>に新しい<code>User</code>インスタンスを作成する方法を示しています。<code>email</code>と<code>username</code>に新しい値を設定しますが、リスト5-2で作成した<code>user1</code>と同じ値を使用します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
#}</code></pre></pre>
<p><span class="caption">リスト 5-6: <code>user1</code>からのいくつかの値を使って新しい<code>User</code>インスタンスを作成する</span></p>
<p>構造体アップデート構文を使用すると、リスト5-7に示すようにコードを減らして同じ効果を得ることができます。<code>..</code>構文は、明示的に設定されていない残りのフィールドは、指定されたインスタンスのフィールドと同じ値を持つ必要があることを指定します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
#}</code></pre></pre>
<p><span class="caption">リスト 5-7: 構造体アップデート構文を使って<code>User</code>インスタンスの新しい<code>email</code>と<code>username</code>値を設定しますが、<code>user1</code>変数のインスタンスのフィールドから残りの値を使います</span></p>
<p>コードリスト5-7のコードでは、<code>email2</code>に<code>email</code>と<code>username</code>とは異なる値を持つインスタンスを作成しますが、<code>user1</code>の <code>active</code>と<code>sign_in_count</code>フィールドの値は同じです。</p>
<a class="header" href="#a異なる型を作成するための名前付きフィールドのないタプル構造体" id="a異なる型を作成するための名前付きフィールドのないタプル構造体"><h3>異なる型を作成するための名前付きフィールドのないタプル構造体</h3></a>
<p><em>タプル構造体</em>と呼ばれるタプルに似た構造体を定義することもできます。タプル構造体には、構造体名が提供する追加の意味がありますが、フィールドに関連付けられた名前はありません。むしろ、彼らはフィールドのタイプを持っています。タプル構造体は、タプル全体に名前を付け、タプルを他のタプルとは異なる型にする場合や、通常の構造体のように各フィールドの名前を冗長または冗長にする場合に便利です。</p>
<p>タプル構造体を定義するには<code>struct</code>キーワードと構造体名の後にタプルの型を続けます。例えば<code>Color</code>と<code>Point</code>という2つのタプル構造体の定義と使用法を次に示します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
#}</code></pre></pre>
<p><code>black</code>と<code>origin</code>値は異なるタプル構造体のインスタンスであるため、異なる型であることに注意してください。構造体内のフィールドに同じ型があっても、定義する各構造体は独自の型です。たとえば、<code>Color</code>型の引数をとる関数は、両方の型が3つの<code>i32</code>値で構成されていても、引数として<code>Point</code>を取ることはできません。それ以外は、タプル構造体インスタンスはタプルのように振る舞います。それらを個々の部分に分解することができます。個々の値にアクセスするには、<code>.</code>にインデックスを使用します。</p>
<a class="header" href="#a任意のフィールドを持たないユニット様構造体" id="a任意のフィールドを持たないユニット様構造体"><h3>任意のフィールドを持たないユニット様構造体</h3></a>
<p>また、フィールドを持たない構造体を定義することもできます。これらは、ユニット型の<code>()</code>と同じように動作するため、<em>ユニット様構造体</em>と呼ばれます。ユニット様構造体はある型にトレイトを実装する必要がありますが、型自体に格納するデータはありません。第10章でトレイトについて議論します。</p>
<blockquote>
<a class="header" href="#a構造データの所有権" id="a構造データの所有権"><h3>構造データの所有権</h3></a>
<p>リスト5-1の<code>User</code>構造体定義では、<code>&amp;str</code>文字列スライス型ではなく所有された<code>String</code>型を使用しました。この構造体のインスタンスがすべてのデータを所有し構造体全体が有効である限り、そのデータが有効であることが望ましいため、これは意図的な選択です。</p>
<p>構造体が他のものが所有するデータへの参照を格納することは可能ですが、構造体がある限り第10章で説明するRust機能である<em>ライフタイム</em>を使用する必要があります。ライフタイムを指定せずに構造体の参照を格納すると動作しません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>コンパイラはライフタイム指定子が必要であるとエラーを出します。</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt;
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt;
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>第10章ではこれらのエラーを修正して参照を構造体に格納する方法について説明しますが、現時点では<code>&amp;str</code>のような参照の代わりに<code>String</code>のような所有型を使ってエラーを修正します。</p>
</blockquote>
<a class="header" href="#a構造体を使用したプログラム例" id="a構造体を使用したプログラム例"><h2>構造体を使用したプログラム例</h2></a>
<p>構造体をいつ使用するのかを理解するために、四角形の面積を計算するプログラムを作成してみましょう。単一の変数から始めて、代わりに構造体を使用するまでプログラムをリファクタリングします。</p>
<p>Cargoで<em>rectangles</em>という名前の新しいバイナリプロジェクトを作成しましょう。このプロジェクトでは、ピクセルで指定された矩形の幅と高さをとり、矩形の面積を計算します。リスト5-8に短いプログラムを示します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">リスト 5-8: 個別の幅と高さの変数で指定された矩形の面積を計算する</span></p>
<p>次に<code>cargo run</code>を使ってこのプログラムを実行してください。</p>
<pre><code class="language-text">The area of the rectangle is 1500 square pixels.
</code></pre>
<p>リスト5-8はさまざまな寸法で<code>area</code>関数を呼び出すことによって四角形の面積を計算しても正しい結果が得られます。幅と高さはそれらが一緒に1つの長方形を記述しているため互いに関連しています。</p>
<p>このコードの問題は<code>area</code>のシグニチャです。</p>
<pre><code class="language-rust ignore">fn area(width: u32, height: u32) -&gt; u32 {
</code></pre>
<p><code>area</code>関数は1つの矩形の面積を計算することになっていますが、ここで書いた関数は2つの引数を持っています。引数は関連していますが、プログラムのどこにも表示されません。幅と高さをグループ化すると、読みやすく、管理しやすくなります。第3章の「タプル型」の項でタプルを使用してこれを行う方法の1つについて既に説明しました。</p>
<a class="header" href="#aタプルによるリファクタリング" id="aタプルによるリファクタリング"><h3>タプルによるリファクタリング</h3></a>
<p>リスト5-9にタプルを使用する別のバージョンのプログラムを示します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">リスト 5-9: タプルで四角形の幅と高さを指定する</span></p>
<p>タプルは構造体を少し追加しましたが今では引数を1つだけ渡しています。しかし、このバージョンはあまり明確ではありません。タプルはその要素の名前を指定しないので、タプルの部分にインデックスを付ける必要があるため計算が複雑になります。</p>
<p>面積計算に幅と高さを混ぜても問題はありませんが、画面上に矩形を描きたい場合は問題になります。<code>width</code>はタプルインデックス<code>0</code>で、<code>height</code>はタプルインデックス<code>1</code>です。他の誰かがこのコードで作業した場合、これを把握しておく必要があります。 これらの値を忘れたり、混乱させたり、エラーを引き起こしたりするのは簡単でしょう。コードの中でデータの意味を伝えていないからです。</p>
<a class="header" href="#a構造体によるリファクタリング意味の追加" id="a構造体によるリファクタリング意味の追加"><h3>構造体によるリファクタリング：意味の追加</h3></a>
<p>構造体を使用してデータにラベルを付けることによって意味を追加します。リスト5-10に示すように、使用しているタプルをパーツの名前と名前の両方を持つデータ型に変換することができます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">リスト 5-10: <code>Rectangle</code>構造体の定義</span></p>
<p>ここでは、構造体を定義し、それを<code>Rectangle</code>という名前にしました。中括弧の中でフィールドを<code>width</code>と<code>height</code>として定義しました。どちらも<code>u32</code>型です。そして<code>main</code>では幅<code>30</code>、高さ<code>50</code>の特定の<code>Rectangle</code>インスタンスを作成しました。</p>
<p><code>area</code>関数は<code>rectangle</code>という名前の1つの引数で定義されています。その型は構造体<code>Rectangle</code>インスタンスの不変な借用です。第4章で述べたように、構造体の所有権を取るのではなく、構造体を借りたいと考えています。このように<code>main</code>は所有権を保持しており<code>rect1</code>を使うことができます。なぜなら、関数シグニチャと関数呼び出しのどこに<code>&amp;</code>を使用するのかという理由があります。</p>
<p><code>area</code>関数は<code>Rectangle</code>インスタンスの<code>width</code>と<code>height</code>フィールドにアクセスします。<code>area</code>の関数シグニチャは、<code>width</code>と<code>height</code>フィールドを使って<code>Rectangle</code>の面積を計算することを意味します。これは、幅と高さが互いに関連していることを伝え、<code>0</code>と<code>1</code>のタプルインデックス値を使用するのではなく値に説明的な名前を付けます。これは分かりやすくするための勝利です。</p>
<a class="header" href="#derivable-traitで便利な機能を追加する" id="derivable-traitで便利な機能を追加する"><h3>Derivable Traitで便利な機能を追加する</h3></a>
<p>プログラムをデバッグしている間に<code>Rectangle</code>のインスタンスを出力してすべてのフィールドの値を見ることができればいいと思います。リスト5-11は前の章で使ったように、<code>println!</code>マクロを使って試行しています。ただし、これは動作しません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">リスト 5-11: <code>Rectangle</code>インスタンスを出力しようとしています</span></p>
<p>このコードを実行すると、エラーが発生します。</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
</code></pre>
<p><code>println!</code>マクロは多くの種類の書式設定を行うことができ、デフォルトでは<code>println!</code>は<code>Display</code>と呼ばれる書式を使用するように指示します。これまでに見たようなプリミティブ型は、デフォルトで<code>Display</code>を実装しています。なぜなら、ユーザーに<code>1</code>やその他のプリミティブ型を表示する方法が1つしかないからです。しかし、構造体では、<code>println!</code>の形式は出力のフォーマットがより明確ではありません。なぜなら、表示の可能性が増えているからです。中括弧を印刷しますか？すべてのフィールドを表示する必要がありますか？この曖昧さのために、Rustは望むものを推測しようとせず、構造体には<code>Display</code>の実装がありません。</p>
<p>引き続きエラーを読んでいれば、この有益なメモを見つけることができます。</p>
<pre><code class="language-text">`Rectangle` cannot be formatted with the default formatter; try using
`:?` instead if you are using a format string
</code></pre>
<p><code>println!</code>マクロ呼び出しは<code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>のようになります。指定子<code>:?</code>を中括弧の中に置くと<code>println!</code>は<code>Debug</code>という出力形式を使いたいと言います。<code>Debug</code>は開発者にとって有用な方法で構造体を印刷できるようにするためのトレイトです。コードをデバッグしている間に値を見ることができます。</p>
<p>この変更でコードを実行しますが、まだエラーが発生します。</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Debug` is not satisfied
</code></pre>
<p>しかし、コンパイラは役立つ情報を与えてくれます。</p>
<pre><code class="language-text">`Rectangle` cannot be formatted using `:?`; if it is defined in your
crate, add `#[derive(Debug)]` or manually implement it
</code></pre>
<p>Rustにはデバッグ情報を表示する機能がありますが、構造体にその機能を利用できるように明示的にオプトインする必要があります。これを行うためにリスト5-12に示すように、構造体定義の直前にアノテーション<code>#[derive(Debug)]</code>を追加します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">リスト 5-12: アノテーションを追加して<code>Debug</code>トレイトを導出し、<code>Rectangle</code>インスタンスをデバッグ形式で出力します</span></p>
<p>ここでプログラムを実行すると、エラーは発生せず次の出力が表示されます。</p>
<pre><code class="language-text">rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>これはもっともきれいな出力とはいえませんが、このインスタンスのすべてのフィールドの値を表示しています。これはデバッグ時には役立ちます。より大きな構造体がある場合、読みやすいように出力するのが便利です。そのような場合、<code>println!</code>文字列に<code>{:?}</code>の代わりに<code>{:#?}</code>を使うことができます。この例で<code>{:#?}</code>スタイルを使用すると、出力は次のようになります。</p>
<pre><code class="language-text">rect1 is Rectangle {
    width: 30,
    height: 50
}
</code></pre>
<p>Rustはカスタムタイプに有用な振る舞いを加えることができるアノテーションを「派生」するために、いくつかのトレイトを提供しました。これらの特性とその振る舞いについては、Appendix C「Derivable Traits」を参照してください。これらのトレイトをカスタム動作で実装する方法と、第10章で独自のトレイトを作成する方法について説明します。</p>
<p><code>area</code>関数は四角形の面積だけを計算する非常に特殊なものです。他の型では動作しないので、この動作を<code>Rectangle</code>構造体にもっと密接に結びつけることは役に立ちます。<code>area</code>関数を<code>Rectangle</code>型で定義された<code>area</code><em>メソッド</em>に変換することでこのコードをどのようにリファクタリングすることができるかを見てみましょう。</p>
<a class="header" href="#aメソッド記法" id="aメソッド記法"><h2>メソッド記法</h2></a>
<p><em>メソッド</em>は関数と似ています。<code>fn</code>キーワードとその名前で宣言されています。引数と戻り値を持つことができ、どこか他のところから呼び出されたときに実行されるコードが含まれています。しかし、メソッドは構造体（または第6章と第17章で説明する列挙型または構造体オブジェクト）のコンテキスト内で定義されている点で関数と異なり、最初の引数は常に<code>self</code>でメソッドが呼び出されている構造体のインスタンスを表します。</p>
<a class="header" href="#aメソッドの定義" id="aメソッドの定義"><h3>メソッドの定義</h3></a>
<p>リスト5-13に示すように<code>Rectangle</code>インスタンスを引数とする<code>area</code>関数を変更し、代わりに<code>Rectangle</code>構造体に定義された<code>area</code>メソッドを作ってみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">リスト 5-13: <code>Rectangle</code>構造体に<code>area</code>メソッドを定義する</span></p>
<p><code>Rectangle</code>のコンテキスト内で関数を定義するために、<code>impl</code>（実装）ブロックを開始します。次に<code>impl</code>中括弧内の<code>area</code>関数を移動させ、最初の（そしてこの場合は唯一の）引数をシグニチャ内とボディ内のどこでも<code>self</code>に変更します。<code>area</code>関数を呼び出し、<code>rect1</code>を引数として渡した<code>main</code>では<em>メソッド構文</em>を使用して、<code>Rectangle</code>インスタンスの<code>area</code>メソッドを呼び出すことができます。メソッド構文は、インスタンスの後に続きます。メソッド名、括弧、および引数の後にドットを追加します。</p>
<p><code>area</code>のシグニチャでは<code>rectangle: &amp;Rectangle</code>の代わりに<code>&amp;self</code>を使います。Rustはこのメソッドが<code>impl Rectangle</code>コンテキストの中にあるため、<code>self</code>の型が<code>Rectangle</code>であることを知っています。<code>&amp;Rectangle</code>のように<code>self</code>の前に<code>&amp;</code>を使用する必要があることに注意してください。メソッドは<code>self</code>の所有権を取ることができ、他の引数と同じように<code>self</code>をここで使用しています。</p>
<p>関数バージョンで<code>&amp;Rectangle</code>を使用したのと同じ理由で<code>&amp;self</code>を選択しました。所有権を奪いたくはなく、単に構造体のデータを読み込むだけで、書き込むことはありません。メソッドを呼び出すインスタンスをメソッドの一部として変更したい場合は、最初の引数として <code>&amp;mut self</code>を使用します。最初の引数として<code>self</code>だけを使用してインスタンスの所有権を取得するメソッドを持つことはまれです。このメソッドは、メソッドが<code>self</code>を何か他のものに変換し、呼び出し元が変換後に元のインスタンスを使用しないようにしたい場合に使用されます。</p>
<p>メソッド構文の使用に加えて、関数の代わりにメソッドを使う主な利点は、すべてのメソッドのシグニチャで<code>self</code>の型を繰り返す必要がなく、体系化のためです。提供するライブラリのさまざまな場所で<code>Rectangle</code>の機能をコード検索の将来のユーザーにさせるのではなく、1つの<code>impl</code>ブロックに型のインスタンスを使ってできることをすべて入れました。</p>
<blockquote>
<a class="header" href="#a-演算子はどこですか" id="a-演算子はどこですか"><h3><code>-&gt;</code>演算子はどこですか？</h3></a>
<p>CとC++では、メソッドを呼び出すために2つの異なる演算子が使用されます。オブジェクトのメソッドを直接呼び出す場合は<code>.</code>を、オブジェクトへのポインタでメソッドを呼び出す場合は<code>-&gt;</code>を使います。つまり<code>object</code>がポインタの場合、<code>object-&gt;something()</code>は<code>(*object).something()</code>のようになります。</p>
<p>Rustには<code>-&gt;</code>演算子と同等のものはありません。代わりに、Rustには<em>自動参照と参照解除</em>という機能があります。メソッドを呼び出すことは、この動作を持つRustの数少ない場所の1つです。</p>
<p><code>object.something()</code>でメソッドを呼び出すと、Rustは<code>&amp;</code>、<code>&amp;mut</code>、<code>*</code>を自動的に追加するので、<code>object</code>はメソッドのシグニチャと一致します。言い換えれば、以下は同じです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug,Copy,Clone)]
# struct Point {
#     x: f64,
#     y: f64,
# }
#
# impl Point {
#    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
#        let x_squared = f64::powi(other.x - self.x, 2);
#        let y_squared = f64::powi(other.y - self.y, 2);
#
#        f64::sqrt(x_squared + y_squared)
#    }
# }
# let p1 = Point { x: 0.0, y: 0.0 };
# let p2 = Point { x: 5.0, y: 6.5 };
p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
#}</code></pre></pre>
<p>最初のものははるかにきれいに見えます。この自動参照動作はメソッドが明確な受け取り<code>self</code>型を持っているために機能します。レシーバとメソッドの名前が与えられると、メソッドはメソッドが読み込み(<code>&amp;self</code>)、変更する(<code>&amp;mut self</code>)、または消費する(<code>self</code>)かどうかを決定することができます。Rustがメソッド受信者に暗黙的に借り入れるという事実は、実際に人間工学に基づいて所有することの大きな部分です。</p>
</blockquote>
<a class="header" href="#aより多くの引数を持つメソッド" id="aより多くの引数を持つメソッド"><h3>より多くの引数を持つメソッド</h3></a>
<p><code>Rectangle</code>構造体に2つ目のメソッドを実装して、メソッドを使って練習しましょう。今回は<code>Rectangle</code>のインスタンスが<code>Rectangle</code>の別のインスタンスを取得し、<code>Rect</code>が<code>self</code>の中に完全に収まる場合は<code>true</code>を返します。それ以外の場合は<code>false</code>を返します。つまり、<code>can_hold</code>メソッドを定義したら、リスト5-14に示すプログラムを書くことができます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption"> リスト 5-14: 未だに書かれていない <code>can_hold</code>メソッドの使用</span></p>
<p><code>rect2</code>の両方の寸法が<code>rect1</code>の寸法よりも小さいので、<code>rect3</code>は<code>rect1</code>よりも広いので、期待される出力は次のようになります：</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>メソッドを定義したいので、<code>impl Rectangle</code>ブロックの中にあります。メソッド名は<code>can_hold</code>になり、別の<code>Rectangle</code>を引数として不変借用をとります。<code>rect1.can_hold(&amp;rect2)</code>は<code>rect2</code>への不変借用である<code>&amp;rect2</code>を渡します。これは<code>Rectangle</code>のインスタンスです。これは意味があります。なぜなら、<code>rect2</code>を読む必要があるからです（書き込みではなく、変更可能な借用が必要なことを意味します）。<code>main</code>が<code>rect2</code>の所有権を保持して呼び出し後に再び使用できるようにします<code>can_hold</code>メソッドです。 <code>can_hold</code>の戻り値はブール値になり、実装は<code>self</code>の幅と高さが両方とも<code>Rectangle</code>の幅と高さよりも大きいかどうかをチェックします。リスト5-15に示すリスト5-13の<code>impl</code>ブロックに新しい<code>can_hold</code>メソッドを追加しましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 5-15: 別の<code>Rectangle</code>インスタンスを引数として取る<code>Rectangle</code>に<code>can_hold</code>メソッドを実装する</span></p>
<p>リスト5-14の<code>main</code>関数でこのコードを実行すると、希望の出力が得られます。メソッドは、<code>self</code>引数の後でシグニチャに追加する複数の引数を取ることができ、それらの引数は関数の引数と同様に機能します。</p>
<a class="header" href="#a関連関数" id="a関連関数"><h3>関連関数</h3></a>
<p><code>impl</code>ブロックのもう一つの便利な機能は<code>self</code>を引数と<em>しない</em><code>impl</code>ブロック内の関数を定義することが許されていることです。これらは構造体に関連付けられているため<em>関連関数</em>と呼ばれます。それらは関数であり、メソッドではありません。構造体のインスタンスがないからです。既に<code>String::from</code>関連関数を使用しています。</p>
<p>関連関数は構造体の新しいインスタンスを返すコンストラクタでよく使用されます。たとえば、一次元の引数を1つ持ち、幅と高さの両方として使用する関連関数を定義すると、同じ値を2回指定するのではなく、正方形の<code>Rectangle</code>を作成しやすくなります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
#}</code></pre></pre>
<p>この関連する関数を呼び出すには、構造体名に<code>::</code>構文を使用します。<code>let sq = Rectangle::square(3);</code>は例です。この関数は構造体によって名前空間を持ちます。<code>::</code>構文はモジュールによって作成された関連関数と名前空間の両方に使われます。モジュールについては第7章で説明します。</p>
<a class="header" href="#a複数のimplブロック" id="a複数のimplブロック"><h3>複数の<code>impl</code>ブロック</h3></a>
<p>各構造体は複数の<code>impl</code>ブロックを持つことができます。例えば、コードリスト5-15はコードリスト5-16に示すコードと同じ意味です。これはそれぞれのメソッドが独自の<code>impl</code>ブロックにあります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 5-16: 複数の<code>impl</code>ブロックを使ってリスト5-15を書き直す</span></p>
<p>これらのメソッドを複数の<code>impl</code>ブロックに分割する理由はありませんが、これは有効な構文です。第10章では複数の<code>impl</code>ブロックが有用な場合を説明します。ここではジェネリック型と特性について説明します。</p>
<a class="header" href="#aまとめ-4" id="aまとめ-4"><h2>まとめ</h2></a>
<p>構造体を使用すると、ドメインにとって意味のあるカスタムタイプを作成できます。構造体を使用することにより、関連するデータを相互に接続し、各部分に名前を付けてコードを明確にすることができます。メソッドを使用すると、構造体のインスタンスが持つ動作を指定できます。また、関連関数を使用すると、インスタンスを使用せずに構造体に固有の名前空間機能を使用できます。</p>
<p>しかし、構造体はカスタムタイプを作成する唯一の方法ではありません。ツールボックスに別のツールを追加するために、Rustの列挙型に切り替えましょう。</p>
<a class="header" href="#a列挙型とパターンマッチング" id="a列挙型とパターンマッチング"><h1>列挙型とパターンマッチング</h1></a>
<p>この章では、<em>列挙型</em>とも呼ばれる<em>enumerations</em>を見ていきます。列挙型では可能な値を列挙して型を定義できます。まず、列挙型を定義して使用し列挙型がデータとともに意味をどのようにエンコードするかを示します。次に<code>Option</code>と呼ばれる特に有用な列挙型を探索します。この列挙型は、値が何かと何もないことを表現しています。次に、<code>match</code>式のパターンマッチングがどのようにenumの異なる値に対して異なるコードを実行するかを見ていきます。最後に<code>if let</code>構造体がコード内の列挙型を扱うために利用できる便利で簡潔な別のイディオムであることを説明します。</p>
<p>列挙型は多くの言語の機能ですが、機能は言語ごとに異なります。Rustの列挙型は、F#、OCaml、Haskellなどの関数型言語の<em>代数型</em>に最もよく似ています。</p>
<a class="header" href="#a列挙型とパターンマッチング-1" id="a列挙型とパターンマッチング-1"><h2>列挙型とパターンマッチング</h2></a>
<p>この例ではコードで表現したいと思う状況を見て列挙型が構造体よりも有用で適切な理由を見てみましょう。IPアドレスで作業する必要があるとします。現在、IPアドレスにはバージョン4とバージョン6の2つの主要な標準が使用されています。これらは、プログラムが遭遇するIPアドレスのための唯一の可能性です。列挙がその名前を取得するところのすべての可能な値を<em>列挙</em>できます。</p>
<p>どのIPアドレスもバージョン4またはバージョン6のいずれかのアドレスにすることができますが、同時に両方を使用することはできません。列挙型の値は変種の1つに過ぎないため、IPアドレスのそのプロパティは列挙型のデータ構造を適切にします。バージョン4とバージョン6の両方のアドレスは基本的にはIPアドレスなので、コードがあらゆる種類のIPアドレスに適用される状況を処理する場合、同じタイプとして扱う必要があります。</p>
<p>この概念をコードで表現するには、<code>IpAddrKind</code>列挙を定義し、IPアドレスが<code>V4</code>と<code>V6</code>で可能な種類を列挙します。これらは列挙型の<em>変種</em>として知られています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>IpAddrKind</code>は、コードのどこかで使用できるカスタムデータ型になりました。</p>
<a class="header" href="#a列挙型の値" id="a列挙型の値"><h3>列挙型の値</h3></a>
<p>次のように<code>IpAddrKind</code>の2つの変種のそれぞれのインスタンスを作成することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#}</code></pre></pre>
<p>列挙型のバリアントはその識別子の下に名前空間があり、二重のコロンを使用してそれらを区切ることに注意してください。これが便利な理由は、<code>IpAddrKind::V4</code>と<code>IpAddrKind::V6</code>の両方の値が同じタイプである、つまり<code>IpAddrKind</code>です。たとえば<code>IpAddrKind</code>をとる関数を定義することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
fn route(ip_type: IpAddrKind) { }
#}</code></pre></pre>
<p>そして、この関数をどちらかのバリアントで呼び出すことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
# fn route(ip_type: IpAddrKind) { }
#
route(IpAddrKind::V4);
route(IpAddrKind::V6);
#}</code></pre></pre>
<p>列挙型を使用するとさらに利点があります。実際のIPアドレス<em>データ</em>を格納する方法がない瞬間、IPアドレスタイプについてもっと考えてみてください。どんな種類であるかを知っているだけです。第5章で構造体について学んだことを考えると、リスト6-1に示すように、この問題に取り組むことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">リスト 6-1: <code>struct</code>を使ってIPアドレスのデータと<code>IpAddrKind</code>バリアントを保存する</span></p>
<p>ここでは<code>IpAddrKind</code>型（これまでに定義した列挙型）の<code>kind</code>フィールドと<code>String</code>型の<code>address</code>フィールドの2つのフィールドを持つ<code>struct IpAddr</code>を定義しました。この構造体には2つのインスタンスがあります。最初の<code>home</code>は、関連するアドレスデータが<code>127.0.0.1</code>で<code>kind</code>が<code>IpAddrKind::V4</code>であるという値を持っています。2番目のインスタンス<code>loopback</code>は<code>kind</code>値として<code>IpAddrKind</code>のバリアント<code>V6</code>を持ち、<code>::1</code>というアドレスを持っています。構造体を使って<code>kind</code>と<code>address</code>の値を束ねていますので、このバリアントは値に関連付けられます。</p>
<p>構造体内の列挙型ではなく単に列挙型を使用して、各列挙型バリアントに直接データを入れて、同じ概念をより簡潔な方法で表現できます。<code>IpAddr</code>列挙型のこの新しい定義では、<code>V4</code>と<code>V6</code>の両方のバリエーションに<code>String</code>値が関連付けられていると言われています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>列挙型の各変種にデータを直接添付するので、余分な構造体は必要ありません。</p>
<p>構造体ではなく列挙型を使用することには別の利点があります。それぞれのバリアントは、関連するデータのタイプと量を異ならせることができます。バージョン4のIPアドレスは常に4つの数値コンポーネントを持ち、0から255までの値を持ちます。もし<code>V4</code>アドレスを4つの<code>u8</code>値として保存したいが<code>V6</code>アドレスを<code>String</code>値として表現したいのであれば構造体ではできません。列挙型は簡単にこのケースを処理できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>バージョン4とバージョン6のIPアドレスを格納するためにデータ構造を定義するいくつかの異なる方法を示しました。しかし、IPアドレスを保存して、どのような種類のものをエンコードしたいのかは、<a href="../../std/net/enum.IpAddr.html">標準ライブラリには使用できる定義があります</a><!-- ignore --> と共通しています。標準ライブラリが<code>IpAddr</code>をどのように定義しているかを見ていきましょう。定義し使用した正確な列挙型と変種を持っていますが、アドレスデータを2つの異なる構造体の形でバリアント内に埋め込みます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>このコードは列挙型の内部に任意の種類のデータ（文字列、数値型、または構造体など）を入れることができることを示しています。別の列挙型を含めることもできます。</p>
<p>標準ライブラリに<code>IpAddr</code>の定義が含まれていても、標準ライブラリの定義をスコープに持たないので、独自の定義を作成して使用することができます。第7章では型をスコープ内に持ち込む方法について詳しく説明します。</p>
<p>リスト6-2の列挙型の別の例を見てみましょう。これはそのバリエーションに埋め込まれた多種多様な型を持っています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">リスト 6-2: <code>Message</code>列挙体でそれぞれ異なる量と値の型を格納します。</span></p>
<p>この列挙型にはさまざまな種類の4つのバリアントがあります。</p>
<ul>
<li><code>Quit</code>には、それに関連するデータは全くありません</li>
<li><code>Move</code>はその内部に無名の構造体を含みます</li>
<li><code>Write</code>は単一の<code>String</code>を含みます</li>
<li><code>ChangeColor</code>は3つの<code>i32</code>値を含みます</li>
</ul>
<p>リスト6-2のような変形を持つ列挙型を定義することは列挙型が<code>struct</code>キーワードを使用せず、すべてのバリアントが<code>Message</code>型の下で一緒にグループ化される点を除いて、異なる種類の構造体を定義することと似ています。次の構造体は前の列挙型が保持するデータと同じデータを保持できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>しかし、それぞれ独自の型を持つ異なる構造体を使用した場合、リスト6-2で定義されている<code>Message</code>列挙型でできるように、これらのメッセージのいずれかを取る関数を一つの型で簡単に定義することはできませんでした。</p>
<p>列挙型と構造体の間にはもう1つの類似点があります。つまり<code>impl</code>を使って構造体にメソッドを定義できるのと同様に、enumでメソッドを定義することもできます。<code>call</code>という名前のメソッドがあり、<code>Message</code>列挙型で定義することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
#     Quit,
#     Move { x: i32, y: i32 },
#     Write(String),
#     ChangeColor(i32, i32, i32),
# }
#
impl Message {
    fn call(&amp;self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
#}</code></pre></pre>
<p>メソッドの本体はメソッドを呼び出した値を取得するために<code>self</code>を使います。この例では値<code>Message::Write(String::from(&quot;hello&quot;))</code>を持つ変数<code>m</code>を作成しました。これは<code>self</code>が<code>m.call()</code>が実行されたときに<code>call</code>メソッドを呼び出します。</p>
<p>標準ライブラリの別の列挙型をよく見てみましょう。まずは<code>Option</code>です。</p>
<a class="header" href="#option列挙型とそのnull値に対する利点" id="option列挙型とそのnull値に対する利点"><h3><code>Option</code>列挙型とそのNull値に対する利点</h3></a>
<p>前のセクションではIpAddr列挙型がRustの型システムを使ってプログラムのデータだけでなくより多くの情報をエンコードする方法を見てきました。このセクションでは、標準ライブラリによって定義された別の列挙型である<code>Option</code>のケーススタディについて説明します。 <code>Option</code>型は値が何かになる可能性がある、あるいは何もできないという非常に一般的なシナリオをエンコードするので、多くの場所で使用されます。この概念を型システムの観点から表現すると、コンパイラは処理する必要があるすべてのケースを処理したかどうかをチェックできます。この機能により、他のプログラミング言語で非常に一般的なバグを防ぐことができます。</p>
<p>プログラミング言語の設計はどの機能を含むかという点ではよく考えられますが除外する機能も重要です。Rustには他の多くの言語が持つNull機能はありません。<em>Null</em>はそこに値がないことを意味する値です。nullを持つ言語では、変数は常にnullまたはnot-nullの2つの状態のいずれかになります。</p>
<p>2009年のプレゼンテーション「Null References：The Billion Dollar Mistake」では、nullの発明者であるTony Hoareがこう言っています。</p>
<blockquote>
<p>それは10億ドルにも相当する私の誤りだ。null参照を発明したのは1965年のことだった。当時、私はオブジェクト指向言語 (ALGOL W) における参照のための包括的型システムを設計していた。目標は、コンパイラでの自動チェックで全ての参照が完全に安全であることを保証することだった。しかし、私は単にそれが容易だというだけで、無効な参照を含める誘惑に抵抗できなかった。これは、後に数え切れない過ち、脆弱性、システムクラッシュを引き起こし、過去40年間で10億ドル相当の苦痛と損害を引き起こしたとみられる。</p>
</blockquote>
<p>ull値の問題は、null値をnull値として使用しようとすると、何らかのエラーが発生することです。このnullまたはnot-nullプロパティは広く使用されているため、この種のエラーは非常に簡単です。</p>
<p>しかし、nullが表現しようとしている概念はまだ有用なものです。nullは何らかの理由で現在無効であるか存在しない値です。</p>
<p>問題は実際にはコンセプトではなく、特定の実装である。 そのため、Rustにはnullはありませんが、値の存在または不在をエンコードできる列挙型があります。この列挙型は<code>Option &lt;T&gt;</code>であり、<a href="../../std/option/enum.Option.html">標準ライブラリで定義されたもの</a><!-- ignore -->では次のようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p><code>Option&lt;T&gt;</code>列挙型は非常に有用であり、それを明示的にスコープに入れる必要はありません。加えてそのバリアントもそうです。<code>Some</code>と<code>None</code>を<code>Option::</code>プレフィックスなしで直接使うことができます。<code>Option &lt;T&gt;</code>列挙型はまだ普通の列挙型であり、<code>Some(T)</code>と<code>None</code>は<code>Option&lt;T&gt;</code>型のバリアントです。</p>
<p><code>&lt;T&gt;</code>構文はまだ説明していないRustの特徴です。これはジェネリック型引数です。ジェネリックについては第10章で詳しく説明します。今のところ、<code>&lt;T&gt;</code>は<code>Option</code>列挙型の<code>Some</code>バリアントが一つのピースを保持できることを意味します。任意の型のデータの数値型と文字列型を保持するための<code>Option</code>値の使用例をいくつか示します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p><code>Some</code>ではなく<code>None</code>を使用する場合、<code>Some</code>バリアントが保持する型をコンパイラが推測することができないので、<code>Option&lt;T&gt;</code>の型をRustに伝える必要があります。</p>
<p><code>Some</code>値があるとき値が存在しその値が<code>Some</code>内に保持されていることがわかります。ある意味で「None」という値があるときは、有効な値がないためnullと同じ意味です。では、なぜ<code>Option&lt;T&gt;</code>はnullよりも優れているのでしょうか？</p>
<p><code>Option&lt;T&gt;</code>と<code>T</code>（ここで<code>T</code>は任意の型とすることができる）は異なる型であるため（<code>Option&lt;i8&gt;</code>に<code>i8</code>を追加しようとしている）、このコードはコンパイルされません。</p>
<pre><code class="language-rust ignore does_not_compile">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<p>このコードを実行すると、次のようなエラーメッセージが表示されます。</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>このエラーメッセージは異なる型のため<code>i8</code>と<code>Option&lt;i8&gt;</code>の加算ができないことを意味します。Rustに<code>i8</code>のような型の値があるとき、コンパイラは常に正しい値を持つことを保証します。その値を使用する前に、nullをチェックする必要はありません。<code>Option&lt;i8&gt;</code>（あるいは扱っている値の種類）があるときだけ、値を持たない可能性について心配する必要があります。コンパイラは値を使う前にそのケースを処理するようにします。</p>
<p>つまり、<code>Option&lt;T&gt;</code>を<code>T</code>に変換してから<code>T</code>演算を実行する必要があります。一般に、これはnullに関する最も一般的な問題の1つをキャッチするのに役立ちます。実際には何かがnullではないと仮定します。</p>
<p>値がNULLではないと心配する必要はなく、コードに自信を持たせることができます。nullになる可能性のある値を持つためには、その値の型を<code>Option&lt;T&gt;</code>にすることによって明示的にオプトインする必要があります。次に、その値を使用するときは、値がnullの場合に明示的に処理する必要があります。値に<code>Option&lt;T&gt;</code>以外の型がある場合は、値がnullではないとみなすことができます。これは、Rustがnullの普及を制限し、Rustコードの安全性を高めるための意図的な設計決定でした。</p>
<p>そのため<code>Option&lt;T&gt;</code>型の値を持っているときに、<code>Some</code>バリアントから<code>T</code>値をどのように取得すれば、その値を使うことができるのでしょうか？<code>Option&lt;T&gt;</code>列挙型は、さまざまな状況で便利な多数のメソッドを持っています。<a href="../../std/option/enum.Option.html">このドキュメント</a><!-- ignore -->でそれらをチェックすることができます。<code>Option&lt;T&gt;</code>のメソッドに慣れると、非常に役立ちます。</p>
<p><code>Option&lt;T&gt;</code>の値を使うためには、それぞれのバリアントを扱うコードが必要です。<code>Some(T)</code>値を持っているときにのみ実行されるいくつかのコードを必要とし、このコードは<code>T</code>を使用することができます。<code>None</code>の値を持っていて、そのコードに<code>T</code>の値がない場合、他のコードを実行します。<code>match</code>式は、列挙型で使用されるときにこれを行うコントロールフロー構造です。列挙型のバリアントに応じて異なるコードを実行し、一致する値の中でデータを使用することができます。</p>
<a class="header" href="#match制御フロー演算子" id="match制御フロー演算子"><h2><code>match</code>制御フロー演算子</h2></a>
<p>Rustには非常に強力な制御フロー演算子<code>match</code>があり、一連のパターンと値を比較しどのパターンが一致するかに基づいてコードを実行することができます。パターンはリテラル値、変数名、ワイルドカード、その他多くのもので構成できます。第18章では、さまざまな種類のパターンとそのパターンについて説明します。<code>match</code>の威力は、パターンの表現力とコンパイラがすべての可能なケースが処理されることを確認するという事実から来ます。</p>
<p><code>match</code>はコイン選別機のように考えることができます。コインはさまざまなサイズの穴があるトラックを滑り落ち、各コインは遭遇する最初の穴から落ちます。同様に値は<code>match</code>の各パターンを通り、最初のパターンでは「適合」の値は実行中に使用される関連コードブロックに入ります。</p>
<p>先ほどのコインについて言及したので、<code>match</code>を使ってコインを例にします。リスト6-3に示すように、未知の米国のコインを受け取ることができる関数を書くことができます。これは計数機と同様にコインがどれであるかを判定しその値をセントで返します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 6-3: 列挙型とそのパターンとして列挙型のバリアントを持つ<code>match</code>式</span></p>
<p><code>value_in_cents</code>関数の<code>match</code>を分解してみましょう。まず、<code>match</code>キーワードとそれに続く式を列挙しますこの場合、値は<code>coin</code>です。これは<code>if</code>で使われる式と非常によく似ていますが、<code>if</code>では式がブール値を返す必要がありますが、ここでは任意の型にすることができます。この例の<code>coin</code>の型は、第1行で定義した<code>Coin</code>列挙型です。</p>
<p>次は <code>match</code>armです。armにはパターンとコードの2つの部分があります。最初のarmは<code>Coin::Penny</code>の値を持つパターンとパターンと実行するコードを分離する<code>=&gt;</code>演算子です。この場合のコードはちょうど値<code>1</code>です。各armは次のarmとカンマで区切られています。</p>
<p><code>match</code>式が実行されると、結果の値と各armのパターンが順番に比較されます。パターンが値と一致する場合、そのパターンに関連付けられたコードが実行されます。そのパターンが値と一致しない場合、コイン選別機と同様に次のarmに実行が継続されます。リスト6-3では、<code>match</code>には4つのarmがあります。</p>
<p>各armに関連付けられたコードは式であり、一致するarmの式の結果の値は<code>match</code>式全体に対して返される値です。</p>
<p>中括弧はmatch armコードが短い場合は通常は使用されません。スト6-3のように、各armが値を返すだけです。match armで複数行のコードを実行する場合は、中括弧を使用できます。たとえば、次のコードはメソッドが <code>Coin::Penny</code>で呼び出されるたびに<code>Lucky penny!</code>を出力しますが、ブロックの最後の値'1'を返します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="#a値にバインドするパターン" id="a値にバインドするパターン"><h3>値にバインドするパターン</h3></a>
<p>match armのもう1つの便利な機能は、パターンにマッチする値の部分にバインドできることです。これは列挙型から値を抽出する方法です。</p>
<p>例として、enumバリアントの1つを内部に保持するように変更しましょう。1999年から2008年にかけて、米国は50の州ごとにデザインの異なる25セント硬貨を作りました。他の硬貨は国家がデザインをしていないため、25セント硬貨には特別な値があります。この情報を<code>enum</code>に追加するには、<code>Quarter</code>バリアントを変更して内部に格納された <code>UsState</code>値をインクルードするようにします。これはコードリスト6-4で行っています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
#}</code></pre></pre>
<p><span class="caption">リスト 6-4: Quarterバリアントも<code>UsState</code>値を保持する<code>Coin</code>列挙型</span></p>
<p>友人が全50州の25セント硬貨を収集しようとしているとしましょう。コインタイプで緩やかな変更を並べ替える間に、各四半期に関連する州の名前も呼び出すので、友達が持っていない場合はコレクションに追加することができます。</p>
<p>このコードのmatch式では、<code>Coin::Quarter</code>バリアントの値と一致するパターンに<code>state</code>という変数を追加します。<code>Coin::Quarter</code>が一致すると、<code>state</code>変数はその25セント硬貨の状態の値にバインドされます。次にそのようなコードのために<code>state</code>を使用することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
#}</code></pre></pre>
<p><code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>を呼び出す場合、<code>coin</code>は<code>Coin::Quarter(UsState::Alaska)</code>になります。その値を各match armと比較すると、<code>Coin::Quarter(state)</code>に達するまで一致するものはありません。その時点で、<code>state</code>のバインディングは<code>UsState::Alaska</code>の値になります。<code>println!</code>式でそのバインディングを使うことができるので、<code>Quarter</code>の<code>Coin</code>列挙型から内部状態値を取得できます。</p>
<a class="header" href="#optiontとのマッチング" id="optiontとのマッチング"><h3><code>Option&lt;T&gt;</code>とのマッチング</h3></a>
<p>前のセクションでは、<code>Option&lt;T&gt;</code>を使うとき、<code>Some</code>の場合の内部の<code>T</code>値を得たいと思っていました。<code>Coin</code>列挙型で行ったように<code>match</code>を使って<code>Option&lt;T&gt;</code>を扱うこともできます。コインを比較するのではなく、<code>Option&lt;T&gt;</code>のバリエーションを比較しますが、 <code>match</code>式の働きは変わりません。</p>
<p><code>Option&lt;i32&gt;</code>を引数に受けとる関数を書いて、内部に値があればその値に1を加えたいとしましょう。内部に値がない場合、関数は <code>None</code>値を返し、何も操作を行わないようにしなければなりません。</p>
<p>この関数は<code>match</code>のおかげで非常に書きやすく、リスト6-5のようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#}</code></pre></pre>
<p><span class="caption">リスト 6-5: <code>Option&lt;i32&gt;</code>で<code>match</code>式を使う関数</span></p>
<p><code>plus_one</code>の最初の実行をもっと詳しく調べてみましょう。<code>plus_one(five)</code>を呼び出すと、<code>plus_one</code>の本体の変数<code>x</code>は <code>Some(5)</code>という値になります。次に、それを各match armと比較します。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p><code>Some(5)</code>の値はパターン<code>None</code>と一致しませんので次のarmに進みます。</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5)</code>は<code>Some(i)</code>にマッチします。同じバリアントを持っています。<code>i</code>は<code>Some</code>に含まれる値に束縛されるので、<code>i</code>は値 <code>5</code>をとります。マッチアーム内のコードが実行されるので、<code>i</code>の値に1を加えて内部に<code>6</code>という値を新しい<code>Some</code>値を作ります。</p>
<p>リスト6-5の<code>plus_one</code>の2番目の呼び出しを考えてみましょう。ここで<code>x</code>は<code>None</code>です。<code>match</code>に入り、最初のarmと比較します。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>これは一致します。追加する値はないのでプログラムは停止し、<code>=&gt;</code>の右側に<code>None</code>値を返します。最初のarmが一致したので、他のarmは比較されません。</p>
<p><code>match</code>とenumを組み合わせることは多くの状況で役に立ちます。このパターンはenumに対する<code>match</code>、変数を内部のデータにバインドし、それに基づいてコードを実行するなどRustコードに多く見られます。最初はややこしいですが、慣れてしまえばすべての言語でそれを使いたいと思うでしょう。</p>
<a class="header" href="#matchの網羅性" id="matchの網羅性"><h3>matchの網羅性</h3></a>
<p>ここで議論する必要のある<code>match</code>のもう一つの側面があります。バグがありコンパイルされない<code>plus_one</code>関数のバージョンを考えてみましょう。</p>
<pre><code class="language-rust ignore does_not_compile">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p><code>None</code>の場合の扱いがないのでこのコードはバグを引き起こします。このコードをコンパイルしようとすると、このエラーが発生します。</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>Rustはあらゆる可能なケースをカバーしていないことを知っています。Rustのマッチは<em>網羅的</em>です。コードが有効であるためには、すべての可能性を排除しなければなりません。特に<code>Option&lt;T&gt;</code>の場合、Rustが明示的に<code>None</code>を扱うことを忘れないようにすると、nullを持っていると仮定することから守ります。</p>
<a class="header" href="#a_プレースホルダ" id="a_プレースホルダ"><h3><code>_</code>プレースホルダ</h3></a>
<p>Rustにはすべての可能な値をリストしたくないときに使用できるパターンもあります。例えば、<code>u8</code>は0から255までの有効な値を持つことができます.1,3,5,7の値だけを扱う場合、0,2,4,6,7,8のいずれかをリストアップする必要はありません。その場合、特別なパターン<code>_</code>を代わりに使うことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><code>_</code>パターンは任意の値と一致します。他の武器の後ろに置くことによって、<code>_</code>はその前に指定されていない可能性のあるすべてのケースに一致します。<code>()</code>は単なる単価であるので、<code>_</code>の場合は何も起こりません。結果として、<code>_</code>プレースホルダの前にリストされていないすべての可能な値に対して何もしたくないと言うことができます。</p>
<p>しかし、<code>match</code>式は<em>一つの</em>ケースだけを気にしている状況では違う記述をします。その場合、Rustは<code>if let</code>を提供します。</p>
<a class="header" href="#if-letによる簡潔な制御フロー" id="if-letによる簡潔な制御フロー"><h2><code>if let</code>による簡潔な制御フロー</h2></a>
<p><code>if let</code>構文は<code>if</code>と<code>let</code>を組み合わせて、あるパターンにマッチする値を処理し、残りのものは無視します。コードリスト6-6のプログラムが<code>Option&lt;u8&gt;</code>の値と一致するが、値が3の場合にのみコードを実行したいと考えているプログラムです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">リスト 6-6: 値が <code>Some(3)</code>のときに実行するコードだけを扱う<code>match</code></span></p>
<p><code>Some(3)</code>のマッチで何かをしたいですが、他の<code>Some&lt;u8&gt;</code>の値や<code>None</code>の値では何もしません。<code>match</code>式を満たすために、一つのバリアントだけを処理した後に<code>_ =&gt; ()</code>を追加する必要があります。これは、追加する定型コードです。</p>
<p>代わりに、<code>if let</code>を使ってこれをより短い方法で書くことができます。次のコードはコードリスト6-6の<code>match</code>と同じように動作します：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
#}</code></pre></pre>
<p><code>if let</code>の構文はパターンと<code>=</code>で区切られた式を取ります。<code>match</code>と同じように動作します。式は<code>match</code>に与えられ、パターンは最初のarmです。</p>
<p><code>if let</code>を使うと入力が少なく、インデントが少なくなり、定型化されたコードが少なくなりますが、<code>match</code>が強制する徹底的なチェックを失います。<code>match</code>と<code>let</code>のどちらかを選択するかどうかは、特定の状況で何をしているのか、簡潔さを得ることが網羅的なチェックを失うための適切なトレードオフであるかによって異なります。</p>
<p>言い換えると、値が1つのパターンと一致したときにコードを実行し、その後他のすべての値を無視する<code>match</code>の場合、<code>let</code>を等位構文と考えることができます。</p>
<p><code>else</code>に<code>if let</code>を含めることができます。<code>else</code>と一緒になるコードブロックは、<code>if</code>と<code>else</code>と同等の<code>match</code>式で<code>_</code>ケースと一緒になるコードブロックと同じです。リスト6-4の<code>Coin</code>列挙型の定義を思い出してください。ここで<code>Quarter</code>バリアントも<code>UsState</code>値を保持しています。私たちが見ている25セント硬貨を数えたいと思ったら、25セント硬貨の状態をアナウンスすると、このような<code>match</code>式でそれを行うことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}
#}</code></pre></pre>
<p>あるいは次のように<code>if let</code>と<code>else</code>式を使うことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
#}</code></pre></pre>
<p>プログラムが<code>match</code>を使って表現するのが冗長すぎるロジックを持っている状況があるなら、<code>let</code>がRustのツールボックスにあることを忘れないでください。</p>
<a class="header" href="#aまとめ-5" id="aまとめ-5"><h2>まとめ</h2></a>
<p>ここでは、enumを使用して列挙値のセットの1つであるカスタムタイプを作成する方法について説明しました。標準ライブラリの <code>Option&lt;T&gt;</code>型がエラーを防ぐために型システムをどのように使うのかを示しました。列挙型の値にデータが含まれている場合、処理する必要があるケースの数に応じて、それらの値を抽出して使用するには<code>match</code>または<code>if let</code>を使用できます。</p>
<p>ここまででRustプログラムは構造体と列挙型を使用して、ドメイン内の概念を表現できるようになりました。APIで使用するカスタム型を作成すると、型の安全性が保証されます。コンパイラは各関数が期待する型の値のみを取得するようにします。</p>
<p>ユーザーに必要なものだけが公開されるように、使いやすいAPIをユーザーに提供するために、Rustのモジュールに目を向けるようにしましょう。</p>
<a class="header" href="#aパッケージクレートモジュール" id="aパッケージクレートモジュール"><h1>パッケージ、クレート、モジュール</h1></a>
<p>プログラムを書くときの重要な点は<em>スコープ</em>で。コード内のこの場所でコンパイラが知っている名前は？どんな機能を呼び出せるのか？この変数は何を参照しているのか？</p>
<p>Rustにはスコープに関連するいくつかの機能があります。これは「モジュールシステム」と呼ばれることもありますが、モジュールだけではありません。</p>
<ul>
<li><em>パッケージ</em>はクレートを構築、テスト、共有できるCargoの機能です</li>
<li><em>クレート</em>はライブラリや実行可能ファイルを生成するモジュールのツリーです</li>
<li><em>モジュール</em>と<em>use</em>キーワードを使用すると、パスのスコープとプライバシーを制御できます</li>
<li><em>パス</em>は構造体、関数、モジュールなどの項目に名前を付ける方法です</li>
</ul>
<p>この章では、これらのすべての概念について説明します。スコープに名前を持たせ、スコープを定義し、すぐにプロのようにスコープに名前をエクスポートします。</p>
<a class="header" href="#aライブラリと実行可能ファイルを作成するためのパッケージと" id="aライブラリと実行可能ファイルを作成するためのパッケージと"><h2>ライブラリと実行可能ファイルを作成するためのパッケージと</h2></a>
<p><em>パッケージ</em>と<em>クレート</em>についてお話しましょう。</p>
<ul>
<li><em>クレート</em>はバイナリまたはライブラリです</li>
<li><em>クレートルート</em>は、クレートの作り方を知るためのソースファイルです</li>
<li><em>パッケージ</em>には1つ以上のを作る方法を説明する<em>Cargo.toml</em>があります。多くの場合、パッケージ内の1つのクレートはライブラリになります。</li>
</ul>
<p><code>cargo new</code>と入力すると、パッケージを作成します。</p>
<pre><code class="language-text">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Cargoは<em>Cargo.toml</em>を作成したので、パッケージがあることを意味します。<em>Cargo.toml</em>の内容を見ると、<em>src/main.rs</em>の記述はありません。しかし、Cargoの規則は、パッケージの<em>Cargo.toml</em>と同じディレクトリに<em>main.rs</em>を含む<em>src</em>ディレクトリがある場合、このパッケージにはパッケージと同じ名前のバイナリクレートが含まれていることがわかります。<em>src/main.rs</em>はクレートルートです。Cargoのもう1つのコンベンションでは、パッケージディレクトリに<em>src/lib.rs</em>が含まれている場合、パッケージにはパッケージと同じ名前のライブラリクレートが含まれ、<em>src/lib.rs</em>はクレートルートです。クレートルートファイルは、実際にライブラリやバイナリをビルドするためにCargoによって<code>rustc</code>に渡されます。</p>
<p>パッケージには、0個または1個のライブラリクレートと、必要な数のバイナリクレートを含めることができます。パッケージには少なくとも1つのクレート（ライブラリまたはバイナリ）が必要です。</p>
<p>パッケージに<em>src/main.rs</em>と<em>src/lib.rs</em>の両方が含まれている場合は、同じ名前のライブラリとバイナリの2つのテンプレートがあります。 我々が2つのうちの1つしか持っていなかった場合、パッケージには単一のライブラリかバイナリクレートのいずれかがあります。パッケージには、<em>src/bin</em>ディレクトリにファイルを置くことによって、複数のバイナリクレートを持つことができます。各ファイルは別々のバイナリクレートになります。</p>
<p>次はモジュールについてです。</p>
<a class="header" href="#aスコープとプライバシーを制御するモジュールシステム" id="aスコープとプライバシーを制御するモジュールシステム"><h2>スコープとプライバシーを制御するモジュールシステム</h2></a>
<p>Rustには「モジュールシステム」と呼ばれる機能がありますが、モジュールにもいくつかの機能があります</p>
<ul>
<li>モジュール、コードを整理し、パスのプライバシーを制御する方法</li>
<li>パス、アイテムに名前を付ける方法</li>
<li>パスをスコープに入れるための<code>use</code>キーワード</li>
<li><code>pub</code>はアイテムを公開するためのキーワードです</li>
<li>アイテムを<code>as</code>キーワードでスコープに入れるときにアイテムの名前を変更する</li>
<li>外部パッケージを使用する</li>
<li>大きな<code>use</code>リストをクリーンアップするネストされたパス</li>
<li>glob演算子を使用して、モジュール内のすべてをスコープに入れる</li>
<li>モジュールを個々のファイルに分割する方法</li>
</ul>
<p>モジュールはコードをグループにまとめることができます。コードリスト7-1は<code>guitar</code>という名前の関数を含む<code>sound</code>モジュールを定義するコードの例です。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    fn guitar() {
        // Function body code goes here
    }
}

fn main() {

}
</code></pre></pre>
<p><span class="caption">リスト 7-1: <code>sound</code>モジュールは<code>guitar</code>関数と<code>main</code>関数を含んでいます</span></p>
<p>2つの関数<code>guitar</code>と<code>main</code>を定義しました。<code>mod</code>ブロック内で<code>guitar</code>関数を定義しました。このブロックは <code>sound</code>という名前のモジュールを定義します。</p>
<p>コードをモジュールの階層に編成するにはリスト7-2に示すように他のモジュールの内部にモジュールをネストできます。</p>
<p><span class="filename"> ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    mod instrument {
        mod woodwind {
            fn clarinet() {
                // Function body code goes here
            }
        }
    }

    mod voice {

    }
}

fn main() {

}
</code></pre></pre>
<p><span class="caption">リスト 7-2: モジュール内のモジュール</span></p>
<p>この例では、リスト7-1と同じ方法で<code>sound</code>モジュールを定義しました。次に、<code>sound</code>モジュール内に<code>instrument</code>と<code>voice</code>という2つのモジュールを定義しました。<code>instrument</code>モジュールには別のモジュール<code>woodwind</code>が定義されており、そのモジュールには<code>clarinet</code>という名前の関数が含まれています。</p>
<p><em>src/main.rs</em>と<em>src/lib.rs</em>は<em>クレートルート</em>と呼ばれている「ライブラリと実行可能ファイルを作るためのパッケージとクレート」セクションで述べました。これらの2つのファイルのいずれかの内容は、クレートのモジュールツリーのルートに<code>crate</code>という名前のモジュールを形成するので、クレートルートと呼ばれます。リスト7-2には、リスト7-3のようなモジュールツリーがあります。</p>
<pre><code class="language-text">crate
 └── sound
     └── instrument
        └── woodwind
     └── voice
</code></pre>
<p><span class="caption">リスト 7-3: リスト7-2のコードのモジュールツリー</span></p>
<p>このツリーは、モジュールのいくつかが互いに内部でどのように入れ子になっているかを示しています（<code>instrument</code>の中に<code>woodwind</code>ネストなど）、そしていくつかのモジュールがどのように兄弟同士であるか（<code>instrument</code>と<code>voice</code>は<code>sound</code>で定義されています。モジュールツリー全体は<code>crate</code>という暗黙のモジュールの下にあります。</p>
<p>このツリーはコンピュータ上にあるファイルシステムのディレクトリツリーを思い出させるかもしれません。ファイルシステムのディレクトリと同様に、望む組織を作成するモジュールの中にコードを配置します。もう1つの類似点は、ファイルシステムまたはモジュールツリー内の項目を参照するには<em>パス</em>を使用します。</p>
<a class="header" href="#aモジュールツリー内のアイテムを参照するためのパス" id="aモジュールツリー内のアイテムを参照するためのパス"><h3>モジュールツリー内のアイテムを参照するためのパス</h3></a>
<p>関数を呼び出す場合は、その<em>パス</em>を知る必要があります。「パス」は「名前」の同義語ですが、ファイルシステムのメタファを呼び起こします。さらに、関数、構造体、およびその他の項目は、同じ項目を参照する複数のパスを持つことがあるため、「名前」はあまり適切な概念ではありません。</p>
<p><em>パス</em>には次の2つの形式があります。</p>
<ul>
<li><em>絶対パス</em>はクレート名かリテラル<code>crate</code>を使ってクレートルートから始まります。</li>
<li><em>相対パス</em>は、現在のモジュールから始まり、<code>self</code>、<code>super</code>、または現在のモジュールの識別子を使用します。</li>
</ul>
<p>絶対パスと相対パスの後には、二重コロン（<code>::</code>）で区切られた1つ以上の識別子が続きます。</p>
<p>コードリスト7-2の<code>main</code>関数で<code>clarinet</code>関数をどのように呼び出すのでしょうか？つまり、<code>clarinet</code>関数のパスは何ですか？リスト7-4では、いくつかのモジュールを削除してコードを少し簡略化し、<code>main</code>から<code>clarinet</code>関数を呼び出す2つの方法を示します。この例はまだコンパイルされませんが、少し説明します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod sound {
    mod instrument {
        fn clarinet() {
            // Function body code goes here
        }
    }
}

fn main() {
    // Absolute path
    crate::sound::instrument::clarinet();

    // Relative path
    sound::instrument::clarinet();
}
</code></pre>
<p><span class="caption">リスト 7-4: 絶対パスと相対パスを使用して<code>main</code>関数から単純化されたモジュールツリーで<code>clarinet</code>関数を呼び出す</span></p>
<p><code>main</code>関数からclarinet関数を呼び出す最初の方法は、絶対パスを使います。<code>clarinet</code>関数は<code>main</code>と同じクレート内で定義されているので、<code>crate</code>キーワードを使用して絶対パスを開始します。 次に<code>clarinet</code>関数に進むまで、それぞれのモジュールをインクルードします。  これは<code>/sound/instrument/clarinet</code>というパスを指定してコンピュータ上のその場所でプログラムを実行するのと同様です。クレートルートから始めるために<code>crate</code>という名前を使うのは、<code>/</code>を使ってシェルのファイルシステムルートから始めるのと同じです。</p>
<p><code>main</code>関数からclarinet関数を呼び出す2番目の方法は相対パスを使います。パスは<code>sound</code>という名前で始まります。モジュールは<code>main</code>関数と同じレベルのモジュールツリーで定義されています。これは、コンピュータのその場所でプログラムを実行するためのパス <code>sound/instrument/clarinet</code>を指定するのと同様です。名前で始まる場合は、パスが相対パスであることを意味します。</p>
<p>リスト7-4はまだコンパイルされませんが、コンパイルしてみましょう。リスト7-5にエラーを示します。</p>
<pre><code class="language-text">$ cargo build
   Compiling sampleproject v0.1.0 (file:///projects/sampleproject)
error[E0603]: module `instrument` is private
  --&gt; src/main.rs:11:19
   |
11 |     crate::sound::instrument::clarinet();
   |                   ^^^^^^^^^^

error[E0603]: module `instrument` is private
  --&gt; src/main.rs:14:12
   |
14 |     sound::instrument::clarinet();
   |            ^^^^^^^^^^
</code></pre>
<p><span class="caption">リスト 7-5: リスト7-4のコード作成によるコンパイラエラー</span></p>
<p>エラーメッセージではモジュール<code>instrument</code>はプライベートであると言いっています。<code>instrument</code>モジュールと<code>clarinet</code>関数の正しいパスがあることがわかりますが、プライベートなので使用できません。</p>
<a class="header" href="#aプライバシー境界としてのモジュール" id="aプライバシー境界としてのモジュール"><h3>プライバシー境界としてのモジュール</h3></a>
<p>ここまででモジュールの構文について説明しそれらを体系的に使用することができました。Rustにはモジュールがあります。モジュールはRustの<em>プライバシー境界</em>です。関数や構造体のような項目をプライベートにしたい場合はそれをモジュールに入れます。プライバシールールは次のとおりです。</p>
<ul>
<li>すべての項目（関数、メソッド、構造体、列挙型、モジュール、annd定数）はデフォルトではプライベートです</li>
<li><code>pub</code>キーワードを使って項目を公開することができます</li>
<li>現在のモジュールの子であるモジュールで定義されたプライベートコードを使用することはできません</li>
<li>祖先モジュールまたは現在のモジュールで定義されたコードを使用することができます</li>
</ul>
<p>言い換えれば、<code>pub</code>キーワードを持たない項目は、現在のモジュールからモジュールツリーを見る際にプライベートですが、<code>pub</code>キーワードのない項目は、現在のモジュールからツリーを<code>見上げる</code>ときにpublicです。また、ファイルシステムを考えてみましょう。ディレクトリへのアクセス権がない場合は、親ディレクトリからそのディレクトリを調べることはできません。ディレクトリへのアクセス権を持っている場合、そのディレクトリとその祖先ディレクトリを見ることができます。</p>
<p>###<code>pub</code>キーワードを使ってアイテムを公開する</p>
<p>リスト7-5のエラーは、<code>instrument</code>モジュールはプライベートであると言いました。<code>instrument</code>モジュールに<code>pub</code>キーワードを付けて、 <code>main</code>関数から使用できるようにしましょう。この変更はリスト7-6に示されていますが、まだコンパイルされませんが、別のエラーが発生します：</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod sound {
    pub mod instrument {
        fn clarinet() {
            // Function body code goes here
        }
    }
}

fn main() {
    // Absolute path
    crate::sound::instrument::clarinet();

    // Relative path
    sound::instrument::clarinet();
}
</code></pre>
<p><span class="caption">リスト 7-6: <code>instrument</code>モジュールを<code>pub</code>と宣言して<code>main</code>から使用できるようにしました</span></p>
<p><code>mod instrument</code>の前に<code>pub</code>キーワードを追加すると、モジュールが公開されます。この変更により、<code>sound</code>にアクセスすることができれば、<code>instrument</code>にアクセスすることができます。<code>instrument</code>の内容はまだプライベートです。モジュールをパブリックにしても内容は公開されません。モジュールの<code>pub</code>キーワードは親モジュールのコードを参照します。</p>
<p>ただし、リスト7-6のコードでは、コードリスト7-7に示すようにエラーが発生します。</p>
<pre><code class="language-text">$ cargo build
   Compiling sampleproject v0.1.0 (file:///projects/sampleproject)
error[E0603]: function `clarinet` is private
  --&gt; src/main.rs:11:31
   |
11 |     crate::sound::instrument::clarinet();
   |                               ^^^^^^^^

error[E0603]: function `clarinet` is private
  --&gt; src/main.rs:14:24
   |
14 |     sound::instrument::clarinet();
   |                        ^^^^^^^^
</code></pre>
<p><span class="caption">リスト 7-7: コードリスト7-6のコンパイラエラー</span></p>
<p>エラーは<code>clarinet</code>関数がプライベートであるといっています。プライバシールールは、構造体、列挙型、関数、およびメソッドとモジュールに適用されます。</p>
<p>リスト7-8に示すように、定義の前に<code>pub</code>キーワードを追加することで<code>clarinet</code>関数をpublicにしましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

fn main() {
    // Absolute path
    crate::sound::instrument::clarinet();

    // Relative path
    sound::instrument::clarinet();
}
</code></pre></pre>
<p><span class="caption">リスト 7-8: <code>pub</code>キーワードを<code>mod instrument</code>と<code>fn clarinet</code>に追加すると<code>main</code>から関数を呼び出すことができます</span></p>
<p>これでコンパイルできます。絶対パスと相対パスの両方を見てみましょう。なぜ<code>pub</code>キーワードを追加すると<code>main</code>でこれらのパスを使うのかを再確認します。</p>
<p>絶対パスの場合、クレートルートである<code>crate</code>で始まります。そこから、<code>sound</code>を持っており、クレートルートに定義されているモジュールです。 <code>sound</code>モジュールはpublicではありませんが、<code>main</code>関数は<code>sound</code>が定義されている同じモジュールで定義されているので、<code>main</code>から <code>sound</code>を参照することができます。次は<code>instrument</code>です。これは<code>pub</code>でマークされたモジュールです。<code>instrument</code>の親モジュールにアクセスできるので、<code>instrument</code>にアクセスすることができます。最後に<code>clarinet</code>は<code>pub</code>とマークされた関数であり、親モジュールにアクセスできるので、この関数呼び出しは機能します。</p>
<p>相対パスの場合、ロジックは最初のステップを除いて絶対パスと同じです。クレートルートから始めるのではなく、パスは<code>sound</code>から始まります。<code>sound</code>モジュールは<code>main</code>と同じモジュール内に定義されているので、<code>main</code>が定義されているモジュールからの相対パスが動作します。そして<code>instrument</code>と<code>clarinet</code>が<code>pub</code>でマークされているので、残りのパスが動作し、この関数呼び出しも有効です。</p>
<a class="header" href="#superによる相対パスの開始" id="superによる相対パスの開始"><h3><code>super</code>による相対パスの開始</h3></a>
<p><code>super</code>で始まる相対パスを構築することもできます。そうすることは<code>..</code>でファイルシステムパスを開始するようなものです。パスは現在のモジュールではなく、<em>parent</em>モジュールから始まります。これはリスト7-9の例のように<code>clarinet</code>関数が<code>breathe_in</code>のパスを<code>super</code>で始まるように指定することで<code>breathe_in</code>関数を呼び出す場合に便利です。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#
mod instrument {
    fn clarinet() {
        super::breathe_in();
    }
}

fn breathe_in() {
    // Function body code goes here
}
</code></pre></pre>
<p><span class="caption">リスト 7-9: 親モジュールを見るために<code>super</code>で始まる相対パスを使って関数を呼び出す</span></p>
<p><code>clarinet</code>関数は<code>instrument</code>モジュールに入っていますので<code>super</code>を使って<code>instrument</code>の親モジュールに行きます。この場合、ルートは <code>crate</code>です。そこから<code>breathe_in</code>を探して見つけます</p>
<p><code>crate</code>で始まる絶対パスではなく<code>super</code>で始まる相対パスを選択したい理由は<code>super</code>を使うとコードを更新して別のモジュール階層にすることが容易になるからです。アイテムとアイテムを呼び出すコードが一緒に移動されます。たとえば<code>instrument</code>モジュールと<code>breathe_in</code>関数を<code>sound</code>という名前のモジュールに入れることにした場合、リスト7-10に示すように<code>sound</code>モジュールを追加するだけです。</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod sound {
    mod instrument {
        fn clarinet() {
            super::breathe_in();
        }
    }

    fn breathe_in() {
        // Function body code goes here
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 7-10: <code>sound</code>という名前の親モジュールを追加しても、相対パス<code>super::breathe_in</code>には影響しません</span></p>
<p><code>clarinet</code>関数からの<code>super::breathe_in</code>への呼び出しは、リスト7-9のようにパスを更新せずに引き続きリスト7-10で機能します。<code>clarinet</code>関数で<code>super::breathe_in</code>の代わりに<code>crate::breathe_in</code>を使用した場合、親の<code>sound</code>モジュールを追加するときに <code>clarinet</code>関数を更新して<code>crate::sound::breathe_in</code>の代わりにします。相対パスを使用すると、モジュールを並べ替えるときに必要な更新が少なくなる可能性があります。</p>
<a class="header" href="#a構造体とenumでpubを使う" id="a構造体とenumでpubを使う"><h3>構造体とEnumで<code>pub</code>を使う</h3></a>
<p>モジュールと関数で示したのと同様の方法で、構造体とenumをpublicに指定することができます。詳細はいくつかあります。</p>
<p>struct定義の前に<code>pub</code>を使うと、構造体をpublicにします。ただし、構造体のフィールドはまだプライベートです。それぞれのフィールドを公開するかどうかは、ケースバイケースで選択することができます。リスト7-11では、パブリック<code>name</code>フィールドを持つpublic<code>plant::Vegetable</code>構造体を定義しましたが、プライベートの<code>id</code>フィールドを定義しました。</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod plant {
    pub struct Vegetable {
        pub name: String,
        id: i32,
    }

    impl Vegetable {
        pub fn new(name: &amp;str) -&gt; Vegetable {
            Vegetable {
                name: String::from(name),
                id: 1,
            }
        }
    }
}

fn main() {
    let mut v = plant::Vegetable::new(&quot;squash&quot;);

    v.name = String::from(&quot;butternut squash&quot;);
    println!(&quot;{} are delicious&quot;, v.name);

    // The next line won't compile if we uncomment it:
    // println!(&quot;The ID is {}&quot;, v.id);
}
</code></pre></pre>
<p><span class="caption">リスト 7-11: いくつかのパブリックフィールドといくつかのプライベートフィールドを持つ構造体
</span></p>
<p><code>plant::Vegetable</code>構造体の<code>name</code>フィールドはpublicであるため、<code>main</code>ではドット表記を使って<code>name</code>フィールドに書き込んで読み込むことができます。プライベートであるため<code>main</code>の<code>id</code>フィールドは使用できません。<code>id</code>フィールドの値を表示している行のコメントを外して、どのようなエラーが発生しているのかを確認してください。また、<code>plant::Vegetable</code>はプライベートフィールドを持っているので、構造体は<code>Vegetable</code>のインスタンスを構築するパブリック関連関数を提供する必要があることに注意してください。<code>Vegetable</code>にそのような機能がなければ<code>main</code>に<code>Vegetable</code>のインスタンスを作成することはできません。なぜなら<code>main</code>のプライベート<code>id</code>フィールドの値を設定できないからです 。</p>
<p>対照的に、パブリックな列挙型を作成すると、そのバリエーションはすべて公開されます。リスト7-12に示すように<code>enum</code>キーワードの前に<code>pub</code>をつけることが必要です。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod menu {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

fn main() {
    let order1 = menu::Appetizer::Soup;
    let order2 = menu::Appetizer::Salad;
}
</code></pre></pre>
<p><span class="caption">リスト 7-12: enumをパブリックとして指定すると、そのすべてのバリアントが公開されます。</span></p>
<p><code>Appetizer</code>enumを公開したので、<code>main</code>に<code>Soup</code>と<code>Salad</code>の亜種を使用することができました。</p>
<p><code>pub</code>にはもう一つの状況があります。これは、最後のモジュールシステムの機能である<code>use</code>キーワードです。<code>use</code>を単独でカバーし<code>pub</code>と <code>use</code>をどのように組み合わせるかを見ていきましょう。</p>
<a class="header" href="#aスコープにパスを渡すためのuseキーワード" id="aスコープにパスを渡すためのuseキーワード"><h3>スコープにパスを渡すための<code>use</code>キーワード</h3></a>
<p>この章のリストにある関数を呼び出すために書いた多くのパスが長くて繰り返していると考えているかもしれません。たとえば、リスト7-8では、<code>clarinet</code>関数の絶対パスか相対パスかを選択したかどうかにかかわらず、<code>clarinet</code>を呼び出すたびに<code>sound</code>と<code>instrument</code>も指定しなければなりませんでした。しかし、パスを一度スコープに入れてから、そのパスのアイテムをローカルアイテムのように呼び出す方法があります。<code>use</code>キーワードです。リスト7-13では、<code>main</code>関数のスコープに<code>crate::sound::instrument</code>モジュールを持っています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

use crate::sound::instrument;

fn main() {
    instrument::clarinet();
    instrument::clarinet();
    instrument::clarinet();
}
</code></pre></pre>
<p><span class="caption">リスト 7-13: モジュールを<code>use</code>と絶対パスでスコープに入れて、モジュール内の項目を呼び出すために指定しなければならないパスを短縮します</span></p>
<p>スコープに<code>use</code>とパスを追加することは、ファイルシステムにシンボリックリンクを作成することに似ています。クレートルートに<code>use crate::sound::instrument</code>を追加することにより、<code>instrument</code>モジュールがクレートルートに定義されているかのように、<code>instrument</code>がその有効範囲内の有効な名前になりました。<code>instrument</code>モジュール内のアイテムは、より古い、完全なパスを通して到達することができます。あるいは、<code>use</code>で作成した新しい、より短いパスを通してアイテムに到達することができます。<code>use</code>でスコープに入れられたパスは、他のパスと同様にプライバシーをチェックします。</p>
<p>アイテムを<code>use</code>と相対パスでスコープに入れたいのであれば、相対パスを使ってアイテムを直接呼び出すのとは少し違いがあります。現在のスコープ内の名前から始めるのではなく、<code>use</code>と<code>self</code>を使います。リスト7-14は、絶対パスを使用したリスト7-13と同じ動作を得るために相対パスを指定する方法を示しています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

use self::sound::instrument;

fn main() {
    instrument::clarinet();
    instrument::clarinet();
    instrument::clarinet();
}
</code></pre></pre>
<p><span class="caption">リスト 7-14: <code>use</code>でモジュールをスコープに入れ、<code>self</code>で始まる相対パス</span></p>
<p><code>use</code>の後に指定されたときに<code>self</code>で相対パスを開始することは、将来不要になるかもしれません。それは人々が取り除くことに取り組んでいる言語の不一致です。</p>
<p><code>use</code>で絶対パスを指定すると、アイテムを呼び出すコードがモジュールツリー内の別の場所に移動しても、アイテムを定義するコードが変更されたときとは異なり、更新が容易になります。たとえば、リスト7-13のコードを実行する場合、<code>main</code>関数の動作を<code>clarinet_trio</code>という関数に抽出し、その関数を<code>performance_group</code>という名前のモジュールに移動します。これはリスト7-15に示すように、<code>use</code>を変更する必要はありません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

mod performance_group {
    use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
        instrument::clarinet();
        instrument::clarinet();
    }
}

fn main() {
    performance_group::clarinet_trio();
}
</code></pre></pre>
<p><span class="caption">リスト 7-15: 項目を呼び出すコードを移動するときに絶対パスを更新する必要はありません</span></p>
<p>対照的に、相対パスを指定するリスト7-14のコードに同じ変更を加えた場合、 <code>use self::sound::instrument</code>を<code>use super::sound::instrument</code>に変更する必要があります。モジュールツリーが将来どのように変更されるかわからない場合、相対パスまたは絶対パスのどちらを更新するかを選択すると推測できますが、作成者は<code>crate</code>で始まる絶対パスを指定する傾向があります。リスト7-10で見たように、モジュールツリーの周りを互いに独立して移動するのではなく、モジュールツリーの周りを移動する可能性が高くなります。</p>
<a class="header" href="#a他のアイテムと関数の慣用的なuseパス" id="a他のアイテムと関数の慣用的なuseパス"><h3>他のアイテムと関数の慣用的な<code>use</code>パス</h3></a>
<p>リスト7-13では、リスト7-16に示すコードではなく、<code>use crate::sound::instrument</code>を指定してから、<code>main</code>で<code>instrument::clarinet</code>と呼びだしたのはなぜでしょうか。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

use crate::sound::instrument::clarinet;

fn main() {
    clarinet();
    clarinet();
    clarinet();
}
</code></pre></pre>
<p><span class="caption">リスト 7-16: <code>クラリネット</code>関数を<code>use</code>で呼び出し独自のユニークなものにする</span></p>
<p>関数の場合、関数の親モジュールを<code>use</code>で指定し、その関数を呼び出すときに親モジュールを指定するのは慣用的です。リスト7-16のように、<code>use</code>で関数へのパスを指定するのではなく、関数がローカルに定義されていないことを確認しながら、フルパスの繰り返しを最小限に抑えます。</p>
<p>構造体、列挙型、およびその他の項目の場合、<code>use</code>で項目へのフルパスを指定することは慣用的です。例えば、リスト7-17は、標準ライブラリの<code>HashMap</code>構造体をスコープに持ち込む慣用的な方法を示しています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">リスト 7-17: HashMapを慣用的な方法でスコープに持ち込む</span></p>
<p>対照的にリスト7-18のコードでは、HashMapの親モジュールをスコープに入れても慣用的ではありません。このイディオムには強い理由はありません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::collections;

fn main() {
    let mut map = collections::HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">リスト 7-18: 独自の方法で <code>HashMap</code>をスコープに持ち込む</span></p>
<p>このイディオムの例外は、<code>use</code>ステートメントが同名の2つの項目をスコープに持ち込むことができない場合です。リスト7-19は、異なる親モジュールを持つ2つの<code>Result</code>型をスコープに持ち込んで参照する方法を示しています。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
#     Ok(())
}
fn function2() -&gt; io::Result&lt;()&gt; {
#     Ok(())
}
#}</code></pre></pre>
<p><span class="caption">リスト 7-19: 同じ名前の2つの型を同じスコープに組み込むには、親モジュールを使用する必要があります</span></p>
<p>代わりに、<code>use std::fmt::Result</code>と<code>use std::io::Result</code>を指定した場合、同じスコープ内に2つの<code>Result</code>型があり、<code>Result</code>を使いました。それを試してみて、どのコンパイラエラーが発生したかを見てください。</p>
<a class="header" href="#asキーワードで型名の名前を変更する" id="asキーワードで型名の名前を変更する"><h3><code>as</code>キーワードで型名の名前を変更する</h3></a>
<p>同じ名前の2つの型を同じスコープに持たせる問題のもう1つの解決方法があります。型の新しいローカル名を<code>use</code>の後に<code>as</code>を追加し、新しい名前を指定することで指定できます。リスト7-20は、リスト7-19のコードを<code>as</code>を使って2つの<code>Result</code>型の名前を変更して書くもう1つの方法を示しています。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
#     Ok(())
}
fn function2() -&gt; IoResult&lt;()&gt; {
#     Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-20: 型が<code>as</code>キーワードで有効範囲に入ったときに型の名前を変更する</span></p>
<p>2番目の<code>use</code>ステートメントでは、<code>std::io: Result</code>型の新しい名前<code>IoResult</code>を選択しました。これは、<code>std::fmt</code>の<code>Result</code>と競合しません またスコープに持ち込まれる。これはまた慣用的であると考えられている。コードリスト7-19とリスト7-20のコードの選択は自分次第です。</p>
<a class="header" href="#pub-useで名前を再エクスポートする" id="pub-useで名前を再エクスポートする"><h3><code>pub use</code>で名前を再エクスポートする</h3></a>
<p><code>use</code>キーワードでスコープに名前を付けると、新しいスコープで使用できる名前はprivateになります。コードを呼び出すコードが、同じようにその型で定義されているかのように型を参照できるようにしたい場合は、<code>pub</code>と<code>use</code>を組み合わせることができます。このテクニックは、アイテムを範囲に入れているだけでなく、そのアイテムを他の人が自分のスコープに持ち込むことができるようにするために<em>再エクスポート</em>と呼ばれます。</p>
<p>たとえば、リスト7-21は、リスト7-15のコードを示し、<code>performance_group</code>モジュール内の<code>use</code>が <code>pub use</code>に変更されています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

mod performance_group {
    pub use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
        instrument::clarinet();
        instrument::clarinet();
    }
}

fn main() {
    performance_group::clarinet_trio();
    performance_group::instrument::clarinet();
}
</code></pre></pre>
<p><span class="caption">リスト 7-21: <code>pub use</code>で新しいスコープから使用するコードに名前を付ける</span></p>
<p><code>pub use</code>を使うことで、<code>main</code>関数は<code>performance_group::instrument::clarinet</code>でこの新しいパスを通して<code>clarinet</code>関数を呼び出すことができます。<code>pub use</code>を指定しなかった場合、<code>clarinet_trio</code>関数はその範囲で<code>instrument::clarinet</code>を呼び出すことができますが、<code>main</code>はこの新しいパスを利用することができません。</p>
<a class="header" href="#a外部パッケージの使用" id="a外部パッケージの使用"><h3>外部パッケージの使用</h3></a>
<p>第2章では、数当てゲームをプログラミングしました。このプロジェクトでは、乱数を得るために外部パッケージ<code>rand</code>を使いました。プロジェクトで<code>rand</code>を使うために、この行を<em>Cargo.toml</em>に追加しました。</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p><em>Cargo.toml</em>の依存関係として<code>rand</code>を追加すると、Cargoは<code>rand</code>パッケージとその依存関係を<em>https://crates.io</em>からダウンロードし、そのコードをプロジェクトに利用できるようにします。</p>
<p>次に、<code>rand</code>定義をパッケージのスコープに持たせるために、パッケージの名前<code>rand</code>で始まる<code>use</code>行を追加し、スコープに入れたい項目をリストアップしました。第2章の「乱数の生成」の節では、<code>Rng</code>トレイトをスコープに持ち込み、<code>rand::thread_rng</code>関数を呼び出したことを思い出してください。</p>
<pre><code class="language-rust ignore">use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1, 101);
}
</code></pre>
<p>コミュニティのメンバーが<em>https://crates.io</em>で公開しているパッケージがたくさんあり、そのいずれかをパッケージに引っ張るのは、パッケージの<em>Cargo.toml</em>にリストして項目を定義するために、それらを<code>use</code>でパッケージのスコープに入れます。</p>
<p>標準ライブラリ（<code>std</code>）もパッケージの外部にあるクレートです。標準ライブラリにはRust言語が付属しているので、<em>Cargo.toml</em>を <code>std</code>をインクルードするように変更する必要はありませんが、<code>use</code>で参照して標準ライブラリが定義した項目をパッケージのスコープに持ち込み、<code>HashMap</code>のように書くこともできます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;
#}</code></pre></pre>
<p>これは標準ライブラリクレートの名前である<code>std</code>で始まる絶対パスです。</p>
<a class="header" href="#a大規模なuseリストを整理するためのネストされたパス" id="a大規模なuseリストを整理するためのネストされたパス"><h3>大規模な<code>use</code>リストを整理するためのネストされたパス</h3></a>
<p>同じパッケージまたは同じモジュールで定義された多数の項目を使用する場合、各項目を独自の行にリストすると、ファイル内に多くの縦方向のスペースが必要になります。たとえば、リスト2-4の数あてゲームで使用したこれら2つの<code>use</code>ステートメントは、<code>std</code>の項目をスコープに持ち込みます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cmp::Ordering;
use std::io;
// ---snip---
#}</code></pre></pre>
<p>リスト7-22のようにネストしたパスを使用して、パスの共通部分を指定し、次に2つのコロンを指定し、異なるパスの部分のリストを中括弧で囲むことで、同じ項目を2つではなく1つの行に1つのスコープにすることができます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::{cmp::Ordering, io};
// ---snip---
#}</code></pre></pre>
<p><span class="caption">リスト 7-22:ネストされたパスを指定して、同じプレフィックスを持つ複数の項目を2つではなく1行にスコープに入れる</span></p>
<p>同じパッケージやモジュールから多くの項目をスコープに入れたプログラムでは、ネストされたパスを使うと、たくさんの<code>use</code>ステートメントの数を減らすことができます。</p>
<p>また、あるパスが完全に共有されているパスを別のパスの一部と重複排除することもできます。たとえば、リスト7-23は2つの<code>use</code>文を示しています。一つは<code>std::io</code>をスコープに持ち、もう一つは <code>std::io::Write</code>をスコープに持ちます。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Write;
#}</code></pre></pre>
<p><span class="caption">リスト 7-23: 2つのパスを2つの<code>use</code>ステートメントのスコープに入れます。1つはもう一方のサブパスです</span></p>
<p>これら2つのパスの共通部分は<code>std::io</code>であり、これが完全な最初のパスです。これらの2つのパスを1つの<code>use</code>ステートメントに重複排除するには、リスト7-24に示すように、ネストされたパスに<code>self</code>を使用できます。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::{self, Write};
#}</code></pre></pre>
<p><span class="caption">リスト 7-24: リスト7-23のパスを1つの <code>use</code>文に重複除外します</span></p>
<p>これは <code>std::io</code>と<code>std::io::Write</code>の両方をスコープに持ち込みます。</p>
<a class="header" href="#aすべてのpublic定義をglob演算子でスコープに変換する" id="aすべてのpublic定義をglob演算子でスコープに変換する"><h3>すべてのPublic定義をglob演算子でスコープに変換する</h3></a>
<p>パスに定義された<em>すべて</em>のパブリックアイテムをスコープに持たせたい場合は、そのパスの後にglob演算子<code>*</code>を指定することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::*;
#}</code></pre></pre>
<p>この<code>use</code>ステートメントは、<code>std::collections</code>で定義されたすべてのパブリックアイテムを現在のスコープに持ち込みます。</p>
<p>glob演算子の使用には注意してください。どの名前がスコープにあり、どの名前がプログラムで使用されているかを知るのが難しくなります。</p>
<p>glob演算子は、テスト中の全てを<code>tests</code>モジュールに持っていくためにテストするときによく使われます。第11章の「テストの書き方」の節でそれについて話します。glob演算子は、初期化処理の一部として使用されることもあります。そのパターンの詳細については、<a href="../../std/prelude/index.html%EF%BC%83other-preludes">標準ライブラリのドキュメント</a>を参照してください。</p>
<a class="header" href="#aモジュールを別々のファイルに分ける" id="aモジュールを別々のファイルに分ける"><h3>モジュールを別々のファイルに分ける</h3></a>
<p>ここまでの例では、1つのファイルに複数のモジュールを定義していました。モジュールが大きくなると、その定義を別のファイルに移動して、コードをナビゲートしやすくなります。</p>
<p>例えば、リスト7-8のコードから始めれば、クレートルートファイル(この場合は<em>src/main.rc</em>)を変更して、リストに示すコードを含むように、<code>sound</code>モジュールを独自のファイル<em>src/sound.rs</em>に移動できます</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">mod sound;

fn main() {
    // 絶対パス
    crate::sound::instrument::clarinet();

    // 相対パス
    sound::instrument::clarinet();
}
</code></pre>
<p><span class="caption">リスト 7-25: 本体が<em>src/sound.rs</em>にある<code>sound</code>モジュールを宣言します。</span></p>
<p><em>src/sound.rs</em>は、リスト7-26に示す<code>sound</code>モジュールの本体から定義を取得します。</p>
<p><span class="filename">ファイル名: src/sound.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod instrument {
    pub fn clarinet() {
        // Function body code goes here
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 7-26: <em>src/sound.rs</em>の<code>sound</code>モジュールの中の定義</span></p>
<p>ブロックの代わりに<code>mod sound</code>の後にセミコロンを使うと、モジュールの内容をモジュールと同じ名前の別のファイルからロードするようにRustに指示します。</p>
<p>この例を続行し、<code>instrument</code>モジュールをそれ自身のファイルに抽出するために、<code>instrument</code>モジュールの宣言だけを含むように<em>src/sound.rs</em>を変更します。</p>
<p><span class="filename">ファイル名: src/sound.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod instrument;
#}</code></pre></pre>
<p>次に、<code>instrument</code>モジュールで定義された定義を格納する<em>src/sound</em>ディレクトリとファイル<em>src/sound/instrument.rs</em>を作成します。</p>
<p><span class="filename">ファイル名: src/sound/instrument.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn clarinet() {
    // Function body code goes here
}
#}</code></pre></pre>
<p>モジュールツリーは同じままであり、定義が異なるファイルに存在していても、<code>main</code>の関数呼び出しは何の変更もなしに機能し続けます。これにより、モジュールのサイズが大きくなるにつれてモジュールを新しいファイルに移動できます。</p>
<a class="header" href="#aまとめ-6" id="aまとめ-6"><h2>まとめ</h2></a>
<p>Rustは、パッケージをクレートに編成し、モジュールをクレートにモジュール化し、絶対パスまたは相対パスを指定することによって、あるモジュールで定義されたアイテムを別のモジュールから参照する方法を提供します。これらのパスは<code>use</code>ステートメントでスコープに入れられ、そのスコープ内のアイテムの複数の使用に短いパスを使用できます。モジュールはデフォルトで非公開のコードを定義しますが、<code>pub</code>キーワードを追加することで定義を公開することもできます。</p>
<p>次に、標準ライブラリのコレクションデータ構造を見ていきます。これは、きちんとしたきれいなコードで使用できます。</p>
<a class="header" href="#a共通コレクション" id="a共通コレクション"><h1>共通コレクション</h1></a>
<p>Rustの標準ライブラリには、<em>collections</em>という非常に有用なデータ構造がいくつか含まれています。他のほとんどのデータ型は1つの特定の値を表しますが、コレクションには複数の値を含めることができます。組み込みの配列型やタプル型とは異なり、これらのコレクションが指し示すデータはヒープに格納されるため、コンパイル時にデータの量を知る必要はなく、プログラムの実行に伴って拡大または縮小することができます。各種類のコレクションには異なる機能とコストがあり、現在の状況に適したものを選択することは、時間の経過とともに発展するスキルです。この章では、Rustプログラムで頻繁に使用される3つのコレクションについて説明します。</p>
<ul>
<li><em>vector</em>を使うと、可変数の値を並べて格納することができます</li>
<li><em>string</em>は文字の集合です。これまでは<code>String</code>型について触れましたが、この章ではそれについて詳しく説明します</li>
<li><em>hash map</em>を使用すると、値を特定のキーに関連付けることができます。これは、<em>map</em>と呼ばれる、より一般的なデータ構造の特定の実装です</li>
</ul>
<p>標準ライブラリが提供する他の種類のコレクションについては、<a href="../../std/collections/index.html">ドキュメント</a>を参照してください。</p>
<p>vector、string、hash mapの作成と更新の方法と、それぞれの特殊なものを作成する方法について説明します。</p>
<a class="header" href="#vectorで一連の値を保持する" id="vectorで一連の値を保持する"><h2>vectorで一連の値を保持する</h2></a>
<p>最初に取り上げるコレクションの型は<code>Vec &lt;T&gt;</code>で、これは<em>vector</em>とも呼ばれます。vectorを使用すると、複数の値を1つのデータ構造体に格納して、すべての値を互いに隣り合うメモリに格納することができます。vectorには同じ型の値しか格納できません。ファイル内のテキスト行やショッピングカート内のアイテムの価格など、アイテムのリストがある場合に便利です。</p>
<a class="header" href="#a新しいvectorの作成" id="a新しいvectorの作成"><h3>新しいvectorの作成</h3></a>
<p>新しい空のvectorを作成するには、リスト8-1に示すように、<code>Vec::new</code>関数を呼び出すことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p><span class="caption">リスト 8-1: <code>i32</code>型の値を保持する新しい空vectorを作成する</span></p>
<p>型アノテーションをここに追加したことに注意してください。このvectorに値を挿入しないため、Rustは格納する要素の種類を知りません。これは重要なポイントです。vectorはジェネリックを使用して実装されます。現在のところ、標準ライブラリによって提供される<code>Vec &lt;T&gt;</code>型は任意の型を保持することができ、特定の型が特定の型を保持している場合、型は山括弧で指定します。リスト8-1では、<code>v</code>の<code>Vec&lt;T&gt;</code>が<code>i32</code>型の要素を保持することをRustに伝えました。</p>
<p>もっと現実的なコードでは、Rustは一度値を挿入すると保存したい値の型を推論することができるので、この型の注釈を行う必要はほとんどありません。初期値を持つ <code>Vec&lt;T&gt;</code>を作成する方が一般的です.Rustは便宜上<code>vec!</code>マクロを提供します。マクロは、与えた値を保持する新しいvectorを作成します。リスト8-2は <code>1</code>、<code>2</code>、<code>3</code>という値を保持する新しい<code>Vec &lt;i32&gt;</code>を作成します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p><span class="caption">リスト 8-2: 値を含む新しいvectorを作成する</span></p>
<p>最初に<code>i32</code>型の値を与えたのでRustは<code>v</code>の型が<code>Vec&lt;i32&gt;</code>であると推論でき、型名は必要ありません。次に、vectorを変更する方法を見ていきます。</p>
<a class="header" href="#vectorの更新" id="vectorの更新"><h3>vectorの更新</h3></a>
<p>リスト8-3に示すように、vectorを作成して要素を追加するには、pushメソッドを使用します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p><span class="caption">リスト 8-3: <code>push</code>メソッドを使ってvectorに値を追加する</span></p>
<p>変数と同様に、値を変更できるようにするには、第3章で説明したように、<code>mut</code>キーワードを使用して変数を変更できるようにする必要があります。内部に置かれる数値はすべて、<code>i32</code>型の値から推測するので、<code>Vec&lt;i32&gt;</code>アノテーションは必要ありません。</p>
<a class="header" href="#vectorを削除するとその要素が削除される" id="vectorを削除するとその要素が削除される"><h3>vectorを削除するとその要素が削除される</h3></a>
<p>他の<code>struct</code>と同様に、リスト8-4で注釈をつけたように、vectorがスコープから外れると解放されます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v

} // &lt;- v goes out of scope and is freed here
#}</code></pre></pre>
<p><span class="caption">リスト 8-4: vectorとその要素がどこにドロップされたかを表示する</span></p>
<p>vectorが削除されると、その内容もすべて削除されます。つまり、保持している整数はクリーンアップされます。これは簡単な点のように思えるかもしれませんが、vectorの要素への参照を導入するときに少し複雑になることがあります。</p>
<a class="header" href="#vectorの要素を読む" id="vectorの要素を読む"><h3>vectorの要素を読む</h3></a>
<p>vectorを作成、更新、破棄する方法を知ったので、内容を読む方法を知っておくことは、次の良いステップです。vectorに格納された値を参照するには、2つの方法があります。例では、わかりやすくするために、これらの関数から返される値の型に注釈を付けました。</p>
<p>リスト8-5は索引付け構文を使用してvector内の値にアクセスする方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
#}</code></pre></pre>
<p><span class="caption">リスト 8-5: 索引付け構文を使用してvector内の項目にアクセスする</span></p>
<p>リスト8-6は<code>get</code>メソッドを使ってvectorの値にアクセスする方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];
let v_index = 2;

match v.get(v_index) {
    Some(_) =&gt; { println!(&quot;Reachable element at index: {}&quot;, v_index); },
    None =&gt; { println!(&quot;Unreachable element at index: {}&quot;, v_index); }
}
#}</code></pre></pre>
<p><span class="caption">リスト 8-6:<code>get</code>メソッドを使ってvectorの項目にアクセスする</span></p>
<p>ここで2つの詳細を注意してください。 まず、インデックス値「2」を使用して3番目の要素を取得します。vectorはゼロから始まる番号でインデックスされます。次に、3番目の要素を取得する2つの方法は、<code>＆</code>と<code>[]</code>を使用して参照を与えたり、インデックスとして引数を渡して <code>get</code>メソッドを使うことで、<code>Option&lt;&amp;T&gt;</code>を得ることができます。</p>
<p>Rustには要素を参照する2つの方法がありますので、vectorが要素を持たないインデックス値を使用しようとしたときにプログラムがどのように動作するかを選択できます。例として、リスト8-7に示すように、プログラムが5つの要素を保持し、次にインデックス100の要素にアクセスしようとするvectorを持つ場合、プログラムが何をするかを見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p><span class="caption">リスト 8-7: 5つの要素を含むvectorのインデックス100にある要素にアクセスしようとしています</span></p>
<p>このコードを実行すると、存在しない要素を参照するため、最初の <code>[]</code>メソッドはプログラムにパニックを引き起こします。 このメソッドは、vectorの最後を過ぎた要素にアクセスしようとするとプログラムがクラッシュするようにしたいときに最適です。</p>
<p><code>get</code>メソッドがベクトルの外側にあるインデックスを渡されると、panicしないで<code>None</code>を返します。通常の状況下で時々起こるvectorの範囲を超えた要素にアクセスする場合は、このメソッドを使用します。コードには、第6章で説明したように、<code>Some(&amp;element)</code>や<code>None</code>のいずれかを扱うロジックがあります。誤って大きすぎる数値を入力し、プログラムが<code>None</code>の値を取得した場合、現在のvectorに含まれる項目の数をユーザに通知し、有効な値を入力する別の機会を与えることができます。それは打ち間違いのためにプログラムをクラッシュさせる方がユーザーフレンドリーになります。</p>
<p>プログラムに有効な参照がある場合、貸借チェッカーは所有権と借用の規則（第4章で説明）を強制して、この参照とvecorの内容への他の参照が有効であることを保証します。変更可能な不変の参照を同じスコープ内に持つことはできないというルールを思い出してください。このルールはリスト8-8に当てはまります。ここでは、vectorの最初の要素への不変参照を保持し、最後に要素を追加しようとしますが、これはうまくいきません。</p>
<pre><code class="language-rust ignore does_not_compile">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;The first element is: {}&quot;, first);
</code></pre>
<p><span class="caption">リスト 8-8: アイテムへの参照を保持しながらベクトルに要素を追加しようとしています</span></p>
<p>このコードをコンパイルすると、このエラーが発生します。</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:10:5
   |
8  |     let first = &amp;v[0];
   |                  - immutable borrow occurs here
9  |
10 |     v.push(6);
   |     ^^^^^^^^^ mutable borrow occurs here
11 |
12 |     println!(&quot;The first element is: {}&quot;, first);
   |                                          ----- borrow later used here
</code></pre>
<p>リスト8-8のコードは、うまくいくように見えるかもしれません。なぜ、最初の要素への参照は、vectorの最後に何が変わるかを気にする必要があるのでしょうか？このエラーはvectorの仕組みに起因しています。vectorの最後に新しい要素を追加すると、新しいメモリを割り当て、古い要素を新しい空間にコピーする必要があります。この場合、vectorの最初の要素への参照は解放されたメモリを指しています。借用ルールは、プログラムがその状況で終わるのを防ぎます。</p>
<blockquote>
<p>注意： <code>Vec&lt;T&gt;</code>型の実装の詳細については、https://doc.rust-lang.org/stable/nomicon/vec.htmlの&quot;The Rustonomicon&quot;を参照してください。</p>
</blockquote>
<a class="header" href="#vectorの値を反復する" id="vectorの値を反復する"><h3>vectorの値を反復する</h3></a>
<p>vectorの各要素に順番にアクセスしたい場合は、インデックスを使用して一度に1つずつアクセスするのではなく、すべての要素を繰り返し処理できます。リスト8-9は<code>for</code>ループを使って<code>i32</code>値のvectorの各要素への不変参照を取得して出力する方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<p><span class="caption">リスト 8-9: <code>for</code>ループを使って要素を反復することで、各要素をvectorに出力する</span></p>
<p>また、すべての要素を変更するために、変更可能なベクトル内の各要素への可変参照を反復処理することもできます。リスト8-10の<code>for</code>ループは各要素に<code>50</code>を追加します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
#}</code></pre></pre>
<p><span class="caption">リスト 8-10: vector内の要素への変更可能な参照の反復処理</span></p>
<p>mutable参照が参照する値を変更するには、<code>+=</code>演算子を使用する前に逆参照演算子(<code>*</code>)を使用して<code>i</code>の値を取得する必要があります。第15章で<code>*</code>について詳しく説明します。</p>
<a class="header" href="#a列挙型を使用して複数の型を格納する" id="a列挙型を使用して複数の型を格納する"><h3>列挙型を使用して複数の型を格納する</h3></a>
<p>この章の冒頭では、vectorには同じ型の値しか格納できないと述べました。これは不便なことがあります。異なるタイプのアイテムのリストを格納する必要があることは間違いありません。幸いにも、列挙型の変種は同じ列挙型で定義されているので、異なる型の要素をvectorに格納する必要があるときは、列挙型を定義して使用することができます。</p>
<p>たとえば、行の一部の列に整数、浮動小数点数、および一部の文字列が含まれているスプレッドシートの行から値を取得するとします。バリアントが異なる値の型を保持する列挙型を定義できます。次に、すべての列挙型が同じ型とみなされます。列挙型の型とみなされます。その列挙型を保持するベクトルを作成し、最終的には異なる型を保持することができます。リスト8-11でこれを実証しました。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">リスト 8-11: 1つのvectorに異なる型の値を格納するための<code>enum</code>の定義</span></p>
<p>Rustはコンパイル時にどの型がvectorに含まれるかを知る必要があるため、各要素を格納するためにヒープ上のメモリの量が正確に分かります。2番目の利点は、このvectorでどのような型が許可されているかを明示できることです。Rustがvectorの型を保持できる場合、vectorの要素に対して実行される操作で1つ以上の型がエラーを引き起こす可能性があります。列挙型と<code>match</code>式を使うことは、第6章で説明したように、Rustがコンパイル時にすべての可能なケースが確実に処理されることを保証することを意味します。</p>
<p>プログラムを書くときに、プログラムが実行時にvectorに格納されるタイプの完全な型がわからない場合、enum技法は機能しません。代わりに、第17章で説明する特性オブジェクトを使用することができます。</p>
<p>vectorを使う最も一般的な方法のいくつかについて議論したところで、標準ライブラリが<code>Vec&lt;T&gt;</code>で定義した多くの有用なメソッドのAPIドキュメントを確認してください。例えば、<code>push</code>に加えて<code>pop</code>メソッドは最後の要素を取り除いて返します。</p>
<a class="header" href="#utf-8でエンコードされた文字列を格納する" id="utf-8でエンコードされた文字列を格納する"><h2>UTF-8でエンコードされた文字列を格納する</h2></a>
<p>第4章で文字列について説明しましたが、ここではそれらをさらに詳しく見ていきます。可能性のあるエラーを表示するためのRustの傾向、多くのプログラマーが信用できるデータ構造よりも複雑な文字列、UTF-8の3つの理由のため、新しいRust開発者は一般的に文字列に固執します。これらの要素は、他のプログラミング言語から来ているときには難しいように見えます。</p>
<p>文字列はバイトの集合として実装されているので、コレクションのコンテキストで文字列を議論すると便利です。さらに、これらのバイトがテキストとして解釈されるときに便利な機能を提供するいくつかのメソッドがあります。このセクションでは、作成、更新、および読み込みなど、すべてのコレクション型が持つ<code>String</code>の操作について説明します。<code>String</code>が他のコレクションとどのように異なっているか、すなわち<code>String</code>への索引付けが人とコンピュータが<code>String</code>データをどのように解釈するかの違いによってどのように複雑になるかを議論します。</p>
<a class="header" href="#a文字列とは" id="a文字列とは"><h3>文字列とは？</h3></a>
<p>最初に、<em>string</em>という用語の意味を定義します。Rustはコア言語では文字列型が1つしかありません。これは、通常は借用された形式の<code>&amp;str</code>で見られる文字列スライス<code>str</code>です。第4章では、他の場所に格納されたUTF-8でエンコードされた文字列データへの参照である<em>文字列スライス</em>について説明しました。たとえば、文字列リテラルはプログラムのバイナリ出力に格納されるため、文字列スライスです。</p>
<p>コア言語にコード化されるのではなく、Rustの標準ライブラリによって提供される<code>String</code>型は、拡張可能で、変更可能な、所有されたUTF-8でエンコードされた文字列型です。Rust開発者がRustの&quot;strings&quot;を参照するとき、それらは通常、それらの型の1つだけではなく、<code>String</code>型と文字列slice<code>&amp;str</code>型を意味します。このセクションは主に<code>String</code>について書かれていますが、どちらのタイプもRustの標準ライブラリで頻繁に使用されています。また、<code>String</code>と文字列スライスの両方がUTF-8でエンコードされています。</p>
<p>Rustの標準ライブラリには、<code>OsString</code>、<code>OsStr</code>、<code>CString</code>、<code>CStr</code>といった他の多くの文字列型も含まれています。ライブラリのテンプレートは、文字列データを格納するためのさらに多くのオプションを提供します。それらの名前が<code>String</code>や<code>Str</code>でどのように終わるかを見てください。以前に見た<code>String</code>や<code>str</code>のように、所有し、借用しているバリアントを参照します。 これらの文字列型は、異なるエンコーディングでテキストを格納したり、異なる方法でメモリに表現することができます。この章では、他の文字列型については説明しません。APIの使用方法とそれぞれが適切な場合のAPIドキュメントを参照してください。</p>
<a class="header" href="#a新しい文字列の作成" id="a新しい文字列の作成"><h3>新しい文字列の作成</h3></a>
<p>リスト8-11に示す<code>Vec&lt;T&gt;</code>で利用可能な操作の多くは、文字列を作成する<code>new</code>関数から始まる<code>String</code>でも利用できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p><span class="caption">リスト 8-11: 新しい空の<code>String</code>を作成する</span></p>
<p>この行は、<code>s</code>という新しい空文字列を作成し、データを読み込むことができます。多くの場合、文字列を開始する初期データがあります。そのためには、文字列リテラルのように、<code>Display</code>トレイトを実装する任意の型で利用できる<code>to_string</code>メソッドを使用します。リスト8-12に2つの例を示します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p><span class="caption">リスト 8-12: <code>to_string</code>メソッドを使って文字列リテラルから<code>String</code>を作成する</span></p>
<p>このコードは <code>initial contents</code>を含む文字列を作成します。</p>
<p>文字列リテラルから<code>String</code>を生成するために<code>String::from</code>関数を使うこともできます。リスト8-13のコードは、リスト8-12のコードに<code>to_string</code>を使用したコードに相当します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p><span class="caption">リスト 8-13: <code>String::from</code>関数を使って文字列リテラルから<code>String</code>を作成する</span></p>
<p>文字列は非常に多くのものに使用されているため、文字列にはさまざまな汎用APIを使用でき、多くのオプションが用意されています。それらのいくつかは冗長に見えるかもしれませんが、彼らはすべて自分の場所を持っています。この場合、<code>String::from</code>と<code>to_string</code>は同じことをするので、どちらを選んでもかまいません。</p>
<p>文字列はUTF-8でエンコードされているので、リスト8-14に示すように、適切にエンコードされたデータをエンコードすることができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
#}</code></pre></pre>
<p><span class="caption">リスト 8-14: 文字列の異なる言語での挨拶の保存</span></p>
<p>これらはすべて有効な <code>String</code>値です。</p>
<a class="header" href="#a文字列の更新" id="a文字列の更新"><h3>文字列の更新</h3></a>
<p><code>Vec&lt;T&gt;</code>の内容と同じように、<code>String</code>のサイズが大きくなり、内容を変更することができます。さらに、<code>+</code>演算子や <code>format!</code>マクロを使うと、<code>String</code>値を連結することができます。</p>
<a class="header" href="#push_strとpushを使って文字列に追加する" id="push_strとpushを使って文字列に追加する"><h4><code>push_str</code>と<code>push</code>を使って文字列に追加する</h4></a>
<p>リスト8-15に示すように、文字列スライスを追加するために<code>push_str</code>メソッドを使って<code>String</code>を拡張することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><span class="caption">リスト 8-15: <code>push_str</code>メソッドを使って文字列スライスを<code>String</code>に追加する</span></p>
<p>これらの2行の後に、<code>s</code>は<code>foobar</code>を含みます。<code>push_str</code>メソッドは文字列スライスを取るので、必ずしも引数の所有権を取る必要はありません。例えば、リスト8-16のコードでは内容を<code>s1</code>に追加した後に<code>s2</code>を使用できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);
#}</code></pre></pre>
<p><span class="caption">リスト 8-16: 文字列スライスの内容を <code>String</code>に追加した後で使用する</span></p>
<p><code>push_str</code>メソッドが<code>s2</code>の所有権を取った場合、最後の行にその値を出力することはできません。しかし、このコードは期待どおりに動作します。</p>
<p><code>push</code>メソッドは引数として単一の文字をとり、それを<code>String</code>に追加します。コードリスト8-17は<code>push</code>メソッドを使って<code>String</code>に文字lを追加するコードを示しています：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p><span class="caption">リスト 8-17: <code>push</code>を使って<code>String</code>値に一つの文字を追加する</span></p>
<p>このコードの結果として、<code>s</code>は<code>lol</code>を含みます。</p>
<a class="header" href="#a演算子やformatマクロとの連結" id="a演算子やformatマクロとの連結"><h4><code>+</code>演算子や<code>format!</code>マクロとの連結</h4></a>
<p>しばしば、2つの既存の文字列を結合したいと思うでしょう。1つの方法は、リスト8-18に示すように、<code>+</code>演算子を使うことです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note s1 has been moved here and can no longer be used
#}</code></pre></pre>
<p><span class="caption">Listing 8-18: <code>+</code>演算子を使って2つの<code>String</code>値を新しい<code>String</code>値に結合します</span></p>
<p>文字列<code>s3</code>はこのコードの結果として<code>Hello、world!</code>を含みます。なぜなら<code>s1</code>は加算の後にもはや有効でなく、<code>s2</code>への参照を使用した理由は、<code>+</code>演算子を使用したときに呼び出されるメソッドのシグニチャと関係しているからです。<code>+</code>演算子は <code>add</code>メソッドを使います。そのシグニチャは次のようになります。</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>これは標準ライブラリにある正確な署名ではありません。標準ライブラリでは、<code>add</code>はジェネリックを使って定義されています。ここでは、一般的なものに代わる具体的な型の<code>add</code>のシグニチャを見ています。これは、このメソッドを<code>String</code>値で呼び出すときに起こります。第10章でジェネリックについて説明します。このシグニチャは、<code>+</code>演算子のトリッキーなビットを理解するために必要な手がかりを与えてくれます。</p>
<p>まず、<code>s2</code>は<code>&amp;</code>を持ちます。つまり、<code>add</code>関数の<code>s</code>引数のために、2番目の文字列の<em>参照</em>を最初の文字列に追加しています。<code>&amp;str</code>を<code>String</code>に変換します。2つの<code>String</code>値を一緒に追加することはできません。<code>&amp;s2</code>の型は、<code>&amp;str</code>ではなく、<code>add</code>への2番目の引数で指定された<code>&amp;String</code>です。なぜ、リスト8-18はコンパイルされるのでしょうか？</p>
<p><code>add</code>の呼び出しで<code>&amp;s2</code>を使うことができるのは、コンパイラが<code>&amp;String</code>引数を<code>&amp;str</code>に強制することができるからです。 <code>add</code>メソッドを呼び出すと、Rustは<em>deref強制</em>を使用します。ここで<code>&amp;s2</code>は<code>&amp;s2[..]</code>になります。第15章でより深く説明します。<code>add</code>は<code>s</code>引数の所有権を取らないので、<code>s2</code>はこの操作の後でも有効な<code>String</code>です。</p>
<p>次に、<code>self</code>は<code>&amp;</code>を持たないので、<code>add</code>は<code>self</code>の所有権を取ります。これは、リスト8-18の<code>s1</code>が<code>add</code>コールに移動し、それ以降は無効になることを意味します。したがって、<code>s3 = s1 + &amp;s2;</code>は両方の文字列をコピーして新しい文字列を作成するように見えますが、実際に、<code>s1</code>の所有権を取得し<code>s2</code>の内容のコピーを追加し、その後の所有権を返します。言い換えれば、それはコピーをたくさん作っているように見えますが、そうではありません。実装はコピーよりも効率的です。</p>
<p>複数の文字列を連結する必要がある場合、<code>+</code>演算子の動作は扱いにくくなります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p>この時点で、<code>s</code>は<code>tic-tac-toe</code>になります。 <code>+</code>と<code>&quot;</code>の文字はすべて、何が起こっているのかを見るのは難しいです。複雑な文字列を組み合わせるには、<code>format！</code>マクロを使うことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>このコードは<code>s</code>を<code>tic-tac-toe</code>に設定します。<code>format!</code>マクロは<code>println!</code>と同じように動作しますが、出力を画面に出力するのではなく、その内容を含む<code>String</code>を返します。<code>format!</code>を使ったコードのバージョンははるかに読みやすく、その引数の所有権を取ることはありません。</p>
<a class="header" href="#aストリングへの索引付け" id="aストリングへの索引付け"><h3>ストリングへの索引付け</h3></a>
<p>他の多くのプログラミング言語では、文字列内の個々の文字にインデックスで参照してアクセスすることは、有効かつ一般的な操作です。しかし、Rustの索引構文を使用して<code>String</code>の部分にアクセスしようとすると、エラーが発生します。リスト8-19の無効なコードを考えてみましょう。</p>
<pre><code class="language-rust ignore does_not_compile">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p><span class="caption">リスト 8-19: 文字列でIndex構文を使用しようとする</span></p>
<p>このコードでは、次のエラーが発生します。</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{integer}&gt;` is not satisfied
 --&gt;
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`
</code></pre>
<p>エラーとノートはストーリーに伝えます。Rust文字列はインデックス作成をサポートしていません。しかし、どうしてですか？ その質問に答えるために、Rustが文字列をメモリにどのように格納するかについて議論する必要があります。</p>
<a class="header" href="#a内部表現" id="a内部表現"><h4>内部表現</h4></a>
<p><code>String</code>は<code>Vec&lt;u8&gt;</code>のラッパーです。リスト8-14の適切にエンコードされたUTF-8のサンプル・ストリングのいくつかを見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>この場合、lenは4であり、これは文字列&quot;Hola&quot;を格納するベクトルが4バイト長であることを意味する。これらの文字のそれぞれは、UTF-8でエンコードされたときに1バイトをとります。しかし、次の行はどうでしょうか？（この行は、アラビア数字3ではなく、キリル文字Zeで始まることに注意してください）</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Здравствуйте&quot;).len();
#}</code></pre></pre>
<p>Rustの答えは24です。これは、文字列の各Unicodeスカラー値が2バイトの記憶域を取るため、UTF-8で&quot;文字列をエンコードする&quot;バイト数です。したがって、文字列のバイトへのインデックスは、有効なUnicodeスカラー値と必ずしも相関しません。実証するために、この無効な錆のコードを考えてみましょう。</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p><code>answer</code>の値はどうあるべきでしょう？最初の文字は<code>З</code>でしょうか？UTF-8でエンコードされている場合、<code>З</code>の最初のバイトは<code>208</code>で、二番目のバイトは<code>151</code>です。したがって、<code>answer</code>は実際には<code>208</code>ですが、<code>208</code>はそれ自身で有効な文字ではありません。<code>208</code>を返すことは、ユーザーがこの文字列の最初の文字を尋ねた場合、ユーザーが望むものではない可能性があります。しかし、それはRustがバイトインデックス0で持つ唯一のデータです。文字列にラテン文字だけが含まれていても、一般的には返されるバイト値は望ましくありません。<code>&amp;&quot;hello&quot;[0]</code>が<code>h</code>ではなく<code>104</code>を返します。予期しない値を返さず、直ちに発見されない可能性のあるバグを引き起こさないように、Rustはこのコードをまったくコンパイルせず、開発プロセスの初期段階で誤解を防止します。</p>
<a class="header" href="#aバイトとスカラの値とグレーフェームクラスタ" id="aバイトとスカラの値とグレーフェームクラスタ"><h4>バイトとスカラの値とグレーフェームクラスタ</h4></a>
<p>UTF-8についてのもう一つの点は、実際にはRustの観点から、文字列をバイト、スカラー値、および文字列クラスター（<em>文字</em>と呼ぶものに最も近いもの）として見るための3つの関連する方法があるということです。</p>
<p>Devanagariスクリプトに書かれたヒンディー語の&quot;नमस्ते&quot;を見ると、これは次のような<code>u8</code>値のベクトルとして格納されます。</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>これは18バイトで、コンピュータが最終的にこのデータをどのように格納するかです。Rustの<code>char</code>型のUnicodeスカラー値として見れば、それらのバイトは次のようになります。</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>ここには6つの<code>char</code>値がありますが、第4と第6は文字ではありません。それは特に意味をなさない発音区別記号です。最後に、それらを書記官クラスターとして見ると、ヒンズー語を構成する4つの文字を人が何と呼ぶかを知ることができます。</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rustはデータがどのような人間言語であっても、各プログラムが必要とする解釈を選択できるように、コンピュータが格納する生の文字列データを解釈するさまざまな方法を提供します。</p>
<p>Rustの最終的な理由は、文字列を取得するために<code>String</code>にインデックスを付けることができないということです。なぜなら、インデックス処理は常に一定の時間(0(1))を取ることが予想されるからです。しかし、Rustは有効な文字がいくつあるのかを判断するために、最初からインデックスまで内容を通らなければならないので、<code>String</code>でそのパフォーマンスを保証することはできません。</p>
<a class="header" href="#aスライシング文字列" id="aスライシング文字列"><h3>スライシング文字列</h3></a>
<p>文字列インデクシング操作の戻り値の型は、バイト値、文字、グラフェンクラスター、または文字列スライスのどれであるべきかが明確でないため、文字列へのインデックス付けはしばしば悪い考えです。したがって、実際にインデックスを使用して文字列スライスを作成する必要がある場合、Rustはより具体的になるように指示します。具体的にはインデックス作成で文字列スライスが必要であることを示すには、単一の数値で<code>[]</code>を使用してインデックスを作成するのではなく、<code>[]</code>を使用して範囲を指定して特定のバイトを含む文字列スライスを作成します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>ここで、<code>s</code>は文字列の最初の4バイトを含む<code>&amp;str</code>です。以前は、これらの文字のそれぞれが2バイトであることに言及しました。これは<code>s</code>が<code>Зд</code>であることを意味します。</p>
<p><code>&amp;hello [0..1]</code>を使うとどうなりますか？答えはvectorで無効なインデックスがアクセスされたのと同じ方法で、実行時にRustがパニックに陥ります。</p>
<pre><code class="language-text">thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
</code></pre>
<p>文字列スライスを作成するには、プログラムをクラッシュさせる可能性があるため、範囲を使用して慎重に文字列スライスを作成する必要があります。</p>
<a class="header" href="#a文字列を反復処理するための方法" id="a文字列を反復処理するための方法"><h3>文字列を反復処理するための方法</h3></a>
<p>文字列内の要素には他の方法でアクセスできます。</p>
<p>個々のUnicodeスカラー値に対して操作を行う必要がある場合は、<code>chars</code>メソッドを使用するのが最良の方法です。&quot;नमस्ते&quot;で <code>chars</code>を呼び出すと、<code>char</code>型の6つの値が分離され、各要素にアクセスするために結果を繰り返し処理できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>このコードは以下を出力します。</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p><code>bytes</code>メソッドはドメインにふさわしいかもしれない生のバイトを返します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>このコードは、この <code>String</code>を構成する18バイトを出力します。</p>
<pre><code class="language-text">224
164
// --snip--
165
135
</code></pre>
<p>しかし、有効なUnicodeスカラ値は1バイト以上で構成されることを覚えておいてください。</p>
<p>文字列から書記素クラスタを得ることは複雑なので、この機能は標準ライブラリでは提供されていません。この機能が必要な場合は、 <a href="https://crates.io">crates.io</a>でcrateを利用できます</p>
<a class="header" href="#a文字列は単純ではありません" id="a文字列は単純ではありません"><h3>文字列は単純ではありません</h3></a>
<p>まとめると、文字列は複雑です。異なるプログラミング言語は、この複雑さをどのようにプログラマに提示するかについて異なる選択をします。RustはすべてのRustプログラムのデフォルトの動作である<code>String</code>データの正しい処理を行うことを選択しました。これは、プログラマがUTF-8データを先に処理することをもっと考慮する必要があることを意味します。このトレードオフは、他のプログラミング言語よりも複雑なストリングを提供しますが、開発ライフサイクルの後半で非ASCII文字を含むエラーを処理する必要がなくなります。</p>
<a class="header" href="#a関連付けられた値を持つキーをhash-mapに格納する" id="a関連付けられた値を持つキーをhash-mapに格納する"><h2>関連付けられた値を持つキーをhash mapに格納する</h2></a>
<p>一般的なコレクションの最後は<em>hash map</em>です。<code>HashMap&lt;K、V</code>&gt;型は、型<code>K</code>のキーを型<code>V</code>の値にマッピングします。これらのキーと値をどのようにメモリに格納するかを決める<em>ハッシュ関数</em>を使ってこれを行います。多くのプログラミング言語はこの種のデータ構造をサポートしていますが、ハッシュ、マップ、オブジェクト、ハッシュテーブル、ディクショナリ、連想配列などの異なる名前を使用することがよくあります。</p>
<p>hash mapは、vectrを使用する場合と同じように、インデックスを使用せずに任意のタイプのキーを使用してデータをルックアップする場合に便利です。 たとえば、ゲームでは、各キーがチームの名前で値が各チームのスコアであるhash mapで各チームのスコアを追跡できます。チーム名を指定するとスコアを取得できます。</p>
<p>このセクションでは、hash mapの基本的なAPIについて説明しますが、標準ライブラリでは<code>HashMap&lt;K、V&gt;</code>で定義されている関数にはもっと多くの機能が隠されています。詳細は標準ライブラリのマニュアルを参照してください。</p>
<a class="header" href="#a新しいhash-mapの作成" id="a新しいhash-mapの作成"><h3>新しいhash mapの作成</h3></a>
<p><code>new</code>で空のhash mapを作成し、<code>insert</code>で要素を追加することができます。リスト8-20では、名前がBlueとYellowの2つのチームの得点を記録しています。ブルーチームは10ポイントでスタートし、イエローチームは50ポイントでスタートします。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p><span class="caption">リスト 8-20:新しいhash mapを作成し、いくつかのキーと値を挿入する</span></p>
<p>標準ライブラリのコレクション部分から<code>HashMap</code>を最初に<code>使用する</code>必要があることに注意してください。3つの一般的なコレクションのうち、これは最も頻繁に使用されるものではないため、プレリュードに自動的に適用される機能には含まれていません。 hash map、標準ライブラリからのサポートも少なくなっています。例えば、それらを構築するための組み込みマクロはありません。</p>
<p>vectorと同様に、hash mapはヒープ上にデータを格納します。この<code>HashMap</code>は<code>String</code>型のキーと<code>i32</code>型の値を持っています。 vectorと同様に、hash mapはすべてのキーは同じタイプでなければならず、すべての値は同じタイプでなければなりません。</p>
<p>hash mapを構築する別の方法は、タプルのベクトルに対して<code>collect</code>メソッドを使うことです。ここで、各タプルはキーとその値から成ります。<code>collect</code>メソッドは<code>HashMap</code>を含む多くのコレクション型にデータを集めます。たとえば、チーム名と初期スコアが2つの別々のベクトルであれば、<code>zip</code>メソッドを使用して&quot;Blue&quot;が10とペアになっているタプルのベクトルを作成することができます。リスト8-21に示すように、<code>collect</code>メソッドを使ってタプルのベクトルをhash mapにすることができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p><span class="caption">リスト 8-21: チームのリストと得点のリストからhash mapを作成する</span></p>
<p><code>HashMap&lt;_, _&gt;</code>型の注釈はここで必要です。なぜなら、指定しない限り何を望んでいるのかわからないため、さまざまなデータ構造に<code>collect</code>することができるからです。ただし、キーと値の型の引数では、アンダースコアを使用し、hash mapに含まれるデータの型に基づいて型を推測できます。</p>
<a class="header" href="#hash-mapと所有権" id="hash-mapと所有権"><h3>hash mapと所有権</h3></a>
<p><code>Copy</code>特性を実装する型の場合、<code>i32</code>のように、値はhash mapにコピーされます。リスト8-22に示すように、<code>String</code>のような所有値の場合、値は移動され、hash mapはそれらの値の所有者になります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
#}</code></pre></pre>
<p><span class="caption">リスト 8-22: hash mapが挿入されると、そのキーと値が所有されていることを示す</span></p>
<p>変数<code>field_name</code>と<code>field_value</code>を、<code>insert</code>を呼び出してhash mapに移動した後で使用することはできません。</p>
<p>値への参照をhash mapに挿入すると、値はhash mapに移動されません。 参照が指す値は、少なくともhash mapが有効である限り有効でなければなりません。これらの問題については、第10章の「ライフタイムを使用した参照の検証」のセクションで詳しく説明します。</p>
<a class="header" href="#hash-mapの値へのアクセス" id="hash-mapの値へのアクセス"><h3>hash mapの値へのアクセス</h3></a>
<p>リスト8-23に示すように、キーを<code>get</code>メソッドに渡すことで、hash mapから値を取得できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p><span class="caption">リスト 8-23: hash mapに保存されているBlueチームのスコアにアクセスする</span></p>
<p>ここでは、<code>スコア</code>はBlueチームに関連付けられた値を持ち、結果は<code>Some(&amp;10)</code>になります。<code>get</code>は<code>Option&lt;&amp;V&gt;</code>を返すので、結果は<code>Some</code>でラップされます。そのキーの値がhash mapにない場合、<code>get</code>は<code>None</code>を返します。プログラムは、第6章で取り上げた方法の1つで、<code>Option</code>を処理する必要があります。</p>
<p><code>for</code>ループを使って、vectorと同様の方法でhash mapの各キー/値の組を繰り返し処理できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>このコードは各ペアを任意の順序で出力します。</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="#hash-mapの更新" id="hash-mapの更新"><h3>hash mapの更新</h3></a>
<p>キーと値の数は増えますが、各キーは一度に1つの値しか関連付けられません。hash mapのデータを変更する場合は、キーにすでに値が割り当てられている場合に、そのケースの処理方法を決定する必要があります。古い値を新しい値に置き換えて、古い値を完全に無視することができます。古い値を保持して新しい値を無視し、キーにすでに値が<em>ない場合</em>にのみ新しい値を追加することができます。または、古い値と新しい値を組み合わせることもできます。これらのそれぞれを行う方法を見てみましょう。</p>
<a class="header" href="#a値を上書きする" id="a値を上書きする"><h4>値を上書きする</h4></a>
<p>hash mapにキーと値を挿入し、同じキーに別の値を挿入すると、そのキーに関連付けられた値が置き換えられます。リスト8-24のコードでは<code>insert</code>を2回呼び出していますが、Blueチームのキーの値を両方とも挿入するため、hash mapには1つのキーと値のペアしか含まれません。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p><span class="caption">リスト 8-24:特定のキーに格納されている値を置き換える</span></p>
<p>このコードは<code>{&quot;Blue&quot;: 25}</code>を出力します。<code>10</code>の元の値は上書きされています。</p>
<a class="header" href="#aキーに値がない場合にのみ値を挿入する" id="aキーに値がない場合にのみ値を挿入する"><h4>キーに値がない場合にのみ値を挿入する</h4></a>
<p>特定のキーに値があるかどうかをチェックし、キーに値がない場合は値を挿入するのが一般的です。hash mapには、これと呼ばれる<code>entry</code>という特別なAPIがあります。このAPIは、チェックしたいキーを引数として受け取ります。<code>entry</code>関数の戻り値は、存在するかもしれないし、存在しないかもしれない値を表す<code>Entry</code>と呼ばれるenumです。Yellowチームのキーに関連する値があるかどうかを確認したいとします。そうでない場合は、値50を挿入し、Blueチームに同じ値を挿入します。<code>entry</code> APIを使用すると、コードはリスト8-25のようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p><span class="caption">リスト 8-25: キーがまだ値を持っていない場合にのみ挿入する<code>entry</code>メソッドの使用
</span></p>
<p><code>Entry</code>の<code>or_insert</code>メソッドは、対応する<code>Entry</code>キーが存在すればその値への変更可能な参照を返すように定義され、そうでなければこのキーの新しい値として引数を挿入し、変更可能な参照を返します。このテクニックは、ロジックを書くよりもはるかにクリーンで、さらに、借用チェッカーでうまく機能します。</p>
<p>リスト8-25のコードを実行すると<code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>が出力されます。黄色のチームにはすでに値がないので、<code>entry</code>への最初の呼び出しは、値が<code>50</code>のYellowチームのキーを挿入します。ブルーチームが既に値<code>10</code>を持っているので、 <code>entry</code>への2回目の呼び出しはhash mapを変更しません。</p>
<a class="header" href="#a古い値に基づく値の更新" id="a古い値に基づく値の更新"><h4>古い値に基づく値の更新</h4></a>
<p>hash mapの別の一般的な使用例は、キーの値をルックアップし、古い値に基づいてキーの値を更新することです。たとえば、リスト8-26は、各単語がテキストに何回出現するかを数えるコードを示しています。単語をキーとしてhash mapを使用し、その単語を何回見たかを追跡するために値を増やします。単語を見たのが初めての場合は、最初に値<code>0</code>を挿入します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p><span class="caption">リスト 8-26: 単語とカウントを格納するhash mapを使って単語の出現を数える</span></p>
<p>このコードは <code>{&quot;world&quot;: 2、&quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>を出力します。<code>or_insert</code>メソッドは実際にこのキーの値に変更可能な参照（<code>&amp;mut V</code>）を返します。ここでは、その可変参照を<code>count</code>変数に格納しています。その値に代入するには、まずアスタリスク（<code>*</code>）を使って<code>count</code>を参照解除する必要があります。変更可能な参照は<code>for</code>ループの終わりで範囲外になるので、これらの変更はすべて安全であり、借用ルールによって許可されます。</p>
<a class="header" href="#aハッシュ関数" id="aハッシュ関数"><h3>ハッシュ関数</h3></a>
<p>デフォルトでは、<code>HashMap</code>はサービス拒否（DoS）攻撃に抵抗することができる&quot;暗号的に強力&quot;<sup class="footnote-reference"><a href="#siphash">1</a></sup>なハッシュ関数を使用します。 利用可能な最速のハッシングアルゴリズムではありませんが、パフォーマンスの低下に伴うより良いセキュリティのトレードオフが価値があります。コードをプロファイリングして、デフォルトのハッシュ関数が遅すぎると分かったら、別の<em>hasher</em>を指定して別の関数に切り替えることができます。hasherは<code>BuildHasher</code>特性を実装する型です。第10章では、特性とその実装方法について説明します。必ずしも独自のhasherをゼロから実装する必要はありません。[crates.io]（https://crates.io）には、多くの一般的なハッシュアルゴリズムを実装しているハッシャーを提供する他のRustユーザーが共有するライブラリがあります。</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.131002.net/siphash/siphash.pdf">https://www.131002.net/siphash/siphash.pdf</a></p>
</div>
<a class="header" href="#aまとめ-7" id="aまとめ-7"><h2>まとめ</h2></a>
<p>vector、文字列、およびhash mapは、データを格納、アクセス、および変更する必要がある場合に、プログラムに必要な大量の機能を提供します。ここで解決する必要があるいくつかの演習があります。</p>
<ul>
<li>整数のリストが与えられた場合、vectorを使用して平均値（平均値）、中央値（ソートされたとき、中央の値）、およびモード（最も頻繁に発生する値、hash mapはここで役立ちます ）のリスト</li>
<li>文字列をPig Latinに変換します。 各単語の最初の子音が単語の末尾に移動し、&quot;ay&quot;が追加されるので、&quot;最初&quot;は &quot;irst-fay&quot;になります。母音で始まる単語は末尾に&quot;hay&quot;が追加されます (“apple”は“apple-hay”になります)。UTF-8エンコーディングの詳細を覚えておいてください</li>
<li>hash mapとvectorを使用して、ユーザーが社内の部門に従業員名を追加できるようにするテキストインタフェースを作成します。たとえば、Sallyをエンジニアリングに追加する」または「AmirをSalesに追加する」などとします。部門内の全員または部門内の全員のリストをアルファベット順に並べ替えることができます</li>
</ul>
<p>標準ライブラリのAPIドキュメントでは、これらの演習に役立つベクトル、文字列、およびhash mapのメソッドについて説明しています。</p>
<p>操作が失敗するより複雑なプログラムになってきているので、エラー処理について議論するのに最適なタイミングです。</p>
<a class="header" href="#aエラー処理" id="aエラー処理"><h1>エラー処理</h1></a>
<p>Rustへの信頼性の取り組みは、エラー処理にも及びます。ソフトウェアではエラーは生きている証なので、Rustには何かがうまくいかない状況を処理するための多くの機能があります。多くの場合、Rustはエラーの可能性を認識し、コードがコンパイルされる前に何らかのアクションをとることを要求します。この要求により、コードを本番環境に導入する前にエラーを発見して適切に処理することで、プログラムをより堅牢にします。</p>
<p>Rustは、エラーを<em>回復可能</em>なエラーと<em>回復不可能</em>なエラーの2つの主要なカテゴリに分類します。ファイルが見つからないなどの回復可能なエラーの場合、問題をユーザーに報告して操作を再試行するのが妥当です。回復不可能なエラーは、常にバグの症状で、例えば配列の終わりを超えた場所にアクセスしようとするときなどです。</p>
<p>ほとんどの言語は、例外などのメカニズムを使用してこれらの2種類のエラーを区別せず同じ方法で両方を処理します。Rustには例外がありません。代わりに、回復可能なエラーの場合は<code>Result&lt;T, E&gt;</code>型、回復不能なエラーが発生した場合は実行を停止する<code>panic!</code>マクロがあります。この章では<code>panic!</code>の呼び出しを最初に説明し、それから<code>Result&lt;T, E&gt;</code>の値を返す方法について説明します。さらに、エラーからの回復を試みるか、実行を停止するかを決定する際に考慮すべき点について検討します。</p>
<a class="header" href="#panicで回復不能なエラー" id="panicで回復不能なエラー"><h2><code>panic!</code>で回復不能なエラー</h2></a>
<p>時として、コードに悪いことが起こることもあります。それに対して、できることは何もありません。このような場合、Rustには<code>panic!</code>マクロがあります。<code>panic!</code>マクロが実行されると、プログラムは失敗メッセージを出力し、スタックの巻き戻しとクリーンアップを行い、終了します。これは最も一般的には、ある種のバグが検出されたときに発生し、プログラマーにエラーを処理する方法が明確でない場合に発生します。</p>
<blockquote>
<a class="header" href="#aパニックに対してスタックを巻き戻すか異常終了するか" id="aパニックに対してスタックを巻き戻すか異常終了するか"><h3>パニックに対してスタックを巻き戻すか異常終了するか</h3></a>
<p>デフォルトでは、パニックが発生するとプログラムは<em>巻き戻し</em>を開始します。これは、Rustがスタックをさかのぼり、遭遇した各関数からデータをクリーンアップすることを意味します。しかし、このさかのぼってクリーンアップするには多くの仕事が発生します。代わりに、即座に<em>異常終了する</em>があります。これは、クリーンアップせずにプログラムを終了します。この場合、プログラムが使用していたメモリは、オペレーティングシステムによってクリーンアップする必要があります。プロジェクトでバイナリを可能な限り小さくする必要がある場合は、の<em>Cargo.toml</em>ファイルの適切な<code>[profile]</code>セクションに<code>panic='abort'</code>を追加することで、パニック時に巻き戻しから異常終了に切り替えることができます。たとえば、リリースモードでパニックを中止する場合は、次のように追加します。</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>単純なプログラムでpanic!の呼び出しを試してみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>プログラムを実行すると、次のように表示されます。</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p><code>panic!</code>を呼び出すと、最後の2行に含まれるエラーメッセージが表示されます。最初の行は、パニックメッセージとパニックが発生したソースコード内の場所を示しています。<em>src/main.rs:2:4</em>は、<em>src/main.rs</em>ファイルの2行目4文字目であることを示します。</p>
<p>この場合、示された行はコードの一部で、その行に行くと<code>panic!</code>マクロ呼び出しが表示されます。panic!呼び出しが、自分のコードが呼び出しているコードの一部になっている可能性もあります。エラーメッセージで報告されるファイル名と行番号が、結果的に<code>panic!</code>呼び出しに導いた自分のコードの行ではなく、<code>panic!</code>マクロが呼び出されている他人のコードになるでしょう。問題の原因となっているコードの部分を理解するために、<code>panic!</code>呼び出しが出てきた関数のバックトレースを使うことができます。次に、バックトレースの詳細を次に説明します。</p>
<a class="header" href="#panicバックトレースを使用する" id="panicバックトレースを使用する"><h3><code>panic!</code>バックトレースを使用する</h3></a>
<p>マクロを直接呼び出すコードではなく、コードのバグのために、ライブラリから<code>panic!</code>呼び出されたときの様子を見てみましょう。コードリスト9-1に、vectorのインデックスで要素にアクセスしようとするコードがあります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">リスト 9-1: vectorの境界を超えて要素へのアクセスを試み、<code>panic!</code>の呼び出しを発生させる</span></p>
<p>ここでは、vectorの100番目の要素(インデックスがゼロから始まるため、インデックス99にあります)にアクセスしようとしていますが、要素は3つしかありません。この状況では、Rustはパニックします。<code>[]</code>を使うと要素を返すことになっていますが、無効なインデックスを渡すとRustが返すことのできる要素がなくなります。</p>
<p>C言語など他の言語は、この場面で欲しいものではないにもかかわらず、要求したものを返そうとしてきます。例えば、vectorの要素に対応するメモリ上の場所、たとえメモリがvectorに属していなくても、返してきます。これは<em>buffer overread</em>と呼ばれ、攻撃者が配列の後に格納されるべきではないデータを読み取るような方法でインデックスを操作することができれば、セキュリティ脆弱性につながる可能性があります。</p>
<p>この種の脆弱性からプログラムを保護するために、存在しないインデックスの要素を読み込もうとすると、Rustは実行を停止し続行を拒否します。それを試して見てみましょう。</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
99', /checkout/src/liballoc/vec.rs:1555:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>このエラーは、自分のファイルではなくファイル<em>vec.rs</em>を指しています。これが標準ライブラリの<code>Vec&lt;T&gt;</code>の実装です。vector<code>v</code>で<code>[]</code>を使ったときに実行されるコードは<em>vec.rs</em>の中にあり、それは<code>panic!</code>が実際に起こっている場所です。</p>
<p>次の注釈行は、<code>RUST_BACKTRACE</code>環境変数を設定して、エラーの原因となったもののバックトレースを取得できることを示しています。<em>バックトレース</em>は、この時点までに呼び出されたすべての関数のリストです。Rustのバックトレースは他の言語と同じように動作します。バックトレースを読むためのコツは、先頭から始め、書き込んだファイルが見えるまで読むことです。そこが問題が発生した場所です。自分のファイルに言及している行の上の行は、自分のコードが呼び出しているコードです。以下の行は自分のコードを呼び出すコードです。これらの行には、Rustの核となる標準ライブラリのコード、または使用しているクレートが含まれている場合があります。<code>RUST_BACKTRACE</code>環境変数を0以外の任意の値に設定して、バックトレースを取得します。リスト9-2と同様の出力が得られます。</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /checkout/src/liballoc/vec.rs:1555:10
stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
             at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::_print
             at /checkout/src/libstd/sys_common/backtrace.rs:71
   2: std::panicking::default_hook::{{closure}}
             at /checkout/src/libstd/sys_common/backtrace.rs:60
             at /checkout/src/libstd/panicking.rs:381
   3: std::panicking::default_hook
             at /checkout/src/libstd/panicking.rs:397
   4: std::panicking::rust_panic_with_hook
             at /checkout/src/libstd/panicking.rs:611
   5: std::panicking::begin_panic
             at /checkout/src/libstd/panicking.rs:572
   6: std::panicking::begin_panic_fmt
             at /checkout/src/libstd/panicking.rs:522
   7: rust_begin_unwind
             at /checkout/src/libstd/panicking.rs:498
   8: core::panicking::panic_fmt
             at /checkout/src/libcore/panicking.rs:71
   9: core::panicking::panic_bounds_check
             at /checkout/src/libcore/panicking.rs:58
  10: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;usize&gt;&gt;::index
             at /checkout/src/liballoc/vec.rs:1555
  11: panic::main
             at src/main.rs:4
  12: __rust_maybe_catch_panic
             at /checkout/src/libpanic_unwind/lib.rs:99
  13: std::rt::lang_start
             at /checkout/src/libstd/panicking.rs:459
             at /checkout/src/libstd/panic.rs:361
             at /checkout/src/libstd/rt.rs:61
  14: main
  15: __libc_start_main
  16: &lt;unknown&gt;
</code></pre>
<p><span class="caption">リスト 9-2: <code>RUST_BACKTRACE</code>環境変数をセットした時に表示される、<code>panic!</code>呼び出しが生成するバックトレース</span></p>
<p>出力がとても多いです。お使いのオペレーティングシステムとRustバージョンによって出力は異なる場合があります。この情報でバックトレースを取得するには、デバッグシンボルを有効にする必要があります。<code>--release</code>フラグを付けずに<code>cargo build</code>や<code>cargo run</code>を使うと、デフォルトでデバッグシンボルが有効になります。</p>
<p>リスト9-2の出力では、バックトレースの11行目が、問題を引き起こしているプロジェクトの行を指しています。<em>src/main.rs</em>の4行目です。プログラムがパニックするのを避けたいのであれば、自分の書いたファイルに言及している最初の行で指し示されている場所が調査を開始する場所です。リスト9-1では、バックトレースを使用する方法を示すためにパニックになるコードを意図的に記述したましたが、パニックを修正する方法は、3つの項目のみを含むvectorからインデックス99の要素を要求しないことです。将来、コードがパニックに陥った場合、パニックを引き起こす値とそのコードが何をすべきかをコードがどのような動作を取っているのか把握する必要があります。</p>
<p>また、この章の後ほど、「<code>panic!</code>するかするまいか」節で<code>panic!</code>とエラー状態を扱うのにpanic!を使うべき時と使わぬべき時に戻ってきます。次は、<code>Result</code>を使用してエラーから回復する方法を見ましょう。</p>
<a class="header" href="#resultで回復可能なエラー" id="resultで回復可能なエラー"><h2>Resultで回復可能なエラー</h2></a>
<p>多くのエラーは、プログラムを完全にストップさせるほど深刻ではありません。時には関数が失敗すると容易に解釈し、対応できるからです。例えば、ファイルを開こうとしてファイルが存在しないために処理が失敗した場合、プロセスを殺すのではなくファイルを作成することができます。</p>
<p>第2章の「<code>Result</code>型による潜在的な障害の処理」で<code>Result</code>列挙型が以下のように、OkとErrの2値からなるよう定義されていることを思い出してください。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p><code>T</code>と<code>E</code>はジェネリック型の引数です。ジェネリックについては第10章で詳しく説明します。今知る必要があるのは、<code>T</code>が成功した時に<code>Ok</code>バリアントに含まれて返される値の型を表すことと、<code>E</code>は失敗した時に<code>Err</code>バリアントに含まれて返されるエラーの型を表すことです。<code>Result</code>はこのようなジェネリックな型引数を含むので、 標準ライブラリ上に定義されている<code>Result</code>型や関数などを、成功した時とエラーの値が異なるような様々な場面で使用できるのです。</p>
<p>関数が失敗する可能性があるために<code>Result</code>値を返す関数を呼び出しましょう。リスト9-3では、ファイルを開こうとしています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">リスト 9-3: ファイルを開く</span></p>
<p><code>File::open</code>が<code>Result</code>を返すことをどうやって知ることができるでしょうか？ <a href="https://doc.rust-lang.org/std/">標準ライブラリAPIドキュメント</a><!--ignore-->を見るか、コンパイラに尋ねることでできます。関数の戻り値ではない型注釈を与えてコンパイルしようとすると、コンパイラはその型が一致しないことを知らせます。エラーメッセージは<code>f</code>の型が何であるかを教えてくれます。<code>File::open</code>の戻り値の型は<code>u32</code>型ではないので、<code>let f</code>文をこれに変更しましょう。</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>コンパイルしようとすると、以下のように出力されます。</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>これは <code>File::open</code>関数の戻り値の型が<code>Result&lt;T, E&gt;</code>であることを示しています。ジェネリック引数<code>T</code>は成功値の型<code>std::fs::File</code>で埋められています。これはファイルハンドルです。エラー値に使用される<code>E</code>の型は<code>std::io::Error</code>です。</p>
<p>この戻り値の型は<code>File::open</code>の呼び出しが成功し、読み書きできるファイルハンドルを返すことを意味します。また関数呼び出しは失敗する可能性もあります。たとえば、ファイルが存在しないか、ファイルにアクセスする権限がないなどです。<code>File::open</code>関数には、成功したか失敗したかを知らせる方法と、同時にファイルハンドルまたはエラー情報を与える方法が必要です。この情報は正確に<code>Result</code>列挙型が伝えるものです。</p>
<p><code>File::open</code>が成功した場合、変数<code>f</code>の値はファイルハンドルを含む<code>Ok</code>のインスタンスになります。失敗した場合、<code>f</code>の値は発生したエラーの種類に関するより多くの情報を含む<code>Err</code>のインスタンスになります。</p>
<p>リスト9-3のコードに<code>File::open</code>が返す値に応じて異なるアクションを取るための処理を追加する必要があります。リスト9-4は、基本的なツールを使用して<code>Result</code>を処理する方法の1つ、第6章で説明した<code>match</code>式を示しています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">リスト 9-4: <code>match</code>式を使用して返却される可能性のあるResultのバリアントを処理する</span></p>
<p><code>Option</code>列挙型のように、<code>Result</code>列挙型とそのバリアントは、初期化処理でインポートされているので、<code>match</code>arm内で<code>Ok</code>と<code>Err</code>バリアントの前に<code>Result::</code>を指定する必要がないことに注目してください。</p>
<p>ここでは、結果が<code>Ok</code>であるとき、内部の<code>file</code>値を<code>Ok</code>バリアントから戻し、そのファイルハンドル値を変数<code>f</code>に代入することをRustに伝えます。<code>match</code>の後で、ファイルハンドルを読み書きのために使うことができます。</p>
<p><code>match</code>のもう一方のarmは<code>File::open</code>から<code>Err</code>値を取得する場合を扱います。この例では、<code>panic!</code>マクロを呼び出すことにしました。現在のディレクトリに<em>hello.txt</em>という名前のファイルがなく、このコードを実行すると、<code>panic!</code>マクロから次の出力が表示されます。</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
</code></pre>
<p>いつものように、この出力は何が間違っているかを正確に教えてくれます。</p>
<a class="header" href="#a色々なエラーにマッチする" id="a色々なエラーにマッチする"><h3>色々なエラーにマッチする</h3></a>
<p>リスト9-4のコードは<code>File::open</code>が失敗した理由にかかわらず<code>panic!</code>になります。ファイルが存在しないために<code>File::open</code>が失敗した場合、ファイルを作成して新しいファイルにハンドルを戻したいと考えています。ファイルを開く権限がないなどの理由で<code>File::open</code>が他の理由で失敗した場合、リスト9-4と同じ方法でコードに<code>panic!</code>を残しておきます。リスト9-5を見てください。これは、<code>match</code>に別のarmを追加します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Tried to create file but there was a problem: {:?}&quot;, e),
            },
            other_error =&gt; panic!(&quot;There was a problem opening the file: {:?}&quot;, other_error),
        },
    };
}
</code></pre>
<p><span class="caption">リスト 9-5: 色々な種類のエラーを異なる方法で扱う</span></p>
<p><code>File::open</code>が<code>Err</code>バリアントの中で返す値の型は<code>io::Error</code>です。これは標準ライブラリによって提供される構造体です。この構造体には<code>io::ErrorKind</code>値を得るために呼び出すことができる<code>kind</code>メソッドがあります。列挙型<code>io::ErrorKind</code>は、標準ライブラリによって提供され、<code>io</code>操作の結果として生じるかもしれないさまざまな種類のエラーを表すバリアントを持っています。使用するバリアントは<code>ErrorKind::NotFound</code>です。これは開こうとしているファイルがまだ存在しないことを示します。そのため、<code>f</code>に<code>match</code>しますが、error.kind()に内部の<code>match</code>もあります。</p>
<p>マッチガードでチェックしたい条件は、<code>error.kind()</code>によって返された値が<code>ErrorKind</code>列挙型の<code>NotFound</code>バリアントかどうかです。そうであれば、<code>File::create</code>でファイルを作成しようとします。しかし、<code>File::create</code>も失敗する可能性があるので、内部の<code>match</code>式も追加する必要があります。ファイルを開くことができない場合は、別のエラーメッセージが表示されます。外側の<code>match</code>の最後のarmは同じままなので、プログラムには欠落しているファイルエラー以外のエラーが発生します。</p>
<p>それはたくさんの<code>match</code>です。<code>match</code>は非常に強力ですが、非常にプリミティブです。第13章では、クロージャについて学びます。<code>Result&lt;T、E&gt;</code>型はクロージャを受け入れる多くのメソッドを持ち、<code>match</code>式として実装されています。より熟練のRust開発者がこれを書くかもしれません。</p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).map_err(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Tried to create file but there was a problem: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<p>第13章を読んだ後、この例に戻って、標準ライブラリのドキュメントで<code>map_err</code>と<code>unwrap_or_else</code>メソッドが何をするのか調べてみましょう。エラーを処理するときに、巨大なネストされた<code>match</code>式をクリーンアップすることができるこれらのメソッドの多くがあります。</p>
<a class="header" href="#aエラー時にパニックするショートカット-unwrapとexpect" id="aエラー時にパニックするショートカット-unwrapとexpect"><h3>エラー時にパニックするショートカット: unwrapとexpect</h3></a>
<p><code>match</code>を使うとうまくいきますが、少し冗長になり、必ずしも意図をうまく伝えるとは限りません。<code>Result&lt;T、E&gt;</code>型は、さまざまなタスクを実行するために多くのヘルパーメソッドが定義されています。<code>unwrap</code>と呼ばれるメソッドの1つは、リスト9-4で書いた<code>match</code>式のように実装されたショートカットメソッドです。<code>Result</code>値が<code>Ok</code>バリアントである場合、<code>unwrap</code>は<code>Ok</code>の値を返します。<code>Result</code>が<code>Err</code>バリアントの場合、<code>unwrap</code>は<code>panic!</code>マクロを呼び出します。実際の<code>unwrap</code>の例を以下に示します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p><em>hello.txt</em>ファイルなしでこのコードを実行すると、<code>unwrap</code>メソッドが行う<code>panic!</code>呼び出しからのエラーメッセージが表示されます。</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p><code>unwrap</code>に似ているもう一つの<code>expect</code>メソッドは、<code>panic!</code>エラーメッセージを選択することもできます。<code>unwrap</code>の代わりに<code>expect</code>を使い、良いエラーメッセージを提供することで意図を伝え、パニックの原因を簡単に追跡することができます。 <code>expect</code>の構文は次のようになります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p><code>unwrap</code>と同じ方法で<code>expect</code>を使うことで、ファイルハンドルを返すか<code>panic!</code>マクロを呼び出します。<code>panic!</code>の呼び出しで<code>expect</code>によって使用されるエラーメッセージは<code>unwrap</code>が使うデフォルトの<code>panic!</code>メッセージではなく<code>expect</code>に渡す引数になります。以下はその様子です。</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<p>このエラーメッセージは、指定したテキスト<code>Failed to open hello.txt</code>で始まるので、このエラーメッセージがどこから来たのかを簡単に見つけることができます。複数の場所で<code>unwrap</code>を使用すると、<code>unwrap</code>が同じメッセージを表示するすべての<code>unwrap</code>を呼び出すため、<code>unwrap</code>がパニックを起こしていることを正確に把握するのに時間がかかることがあります。</p>
<a class="header" href="#aエラーを委譲する" id="aエラーを委譲する"><h3>エラーを委譲する</h3></a>
<p>失敗する可能性のある何かを呼び出す実装をした関数を書く際、関数内でエラーを処理する代わりに、呼び出し元がどうするかを決められるようにエラーを返すことができます。これはエラーの<em>委譲</em>として認知され、呼び出し元に自分のコードの文脈で利用可能なものよりも、エラーの処理法を規定する情報やロジックがより多くある箇所を制御してもらいます。</p>
<p>たとえば、コードリスト9-6は、ファイルからユーザー名を読み取る関数を示しています。ファイルが存在しないか読み取れない場合、この関数は、この関数を呼び出したコードにこれらのエラーを返します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 9-6: <code>match</code>でエラーを呼び出し元のコードに返す関数</span></p>
<p>この関数ははるかに短い方法で記述することができますが、エラー処理を探索するために手動で多くの作業を行うことから始めます。最後に、簡単な方法を示します。最初に関数の戻り値の型を見てみましょう。<code>Result&lt;String, io::Error&gt;</code>です。これは、ジェネリック引数<code>T</code>が具体型<code>String</code>で埋められ、ジェネリック型<code>E</code>が具体的型<code>io::Error</code>の場合に、関数が<code>Result&lt;T, E&gt;</code>型の値を返すことを意味します。この関数が問題なく成功した場合、この関数を呼び出すコードは、<code>String</code>(この関数がファイルから読み取ったユーザー名)を保持する<code>Ok</code>値を受け取ります。この関数が何らかの問題に遭遇した場合、この関数を呼び出すコードは、問題の内容に関する詳細情報を含む <code>io::Error</code>のインスタンスを保持する<code>Err</code>値を受け取ります。関数の戻り値の型に<code>io::Error</code>を選んだのは、この関数本体で呼び出している失敗する可能性のある処理が両方(<code>File::open</code>関数と<code>read_to_string</code>メソッド)とも偶然この型をエラー値として返すからです。</p>
<p>関数の本体は<code>File::open</code>関数を呼び出すことから始まります。リスト9-4の<code>match</code>に似た<code>match</code>で返された<code>Result</code>値を扱い、<code>Err</code>の場合に<code>panic!</code>を呼び出すのではなく、この関数から早くリターンして、この関数のエラー値として<code>File::open</code>からのエラー値を呼び出しコードに返します。<code>File::open</code>が成功すると、ファイルハンドルを変数<code>f</code>に格納して処理を続行します。</p>
<p>次に、変数<code>s</code>に新しい<code>String</code>を作成し、<code>f</code>のファイルハンドルの<code>read_to_string</code>メソッドを呼び出して、ファイルの内容を<code>s</code>に読み込みます。<code>read_to_string</code>メソッドは、<code>File::open</code>が成功したとしても、失敗する可能性があるため、<code>Result</code>を返します。<code>result</code>を処理するために別の<code>match</code>が必要です。もし<code>read_to_string</code>が成功すれば関数は成功し、<code>s</code>の<code>Ok</code>でラップされたファイルからユーザ名を返します。<code>read_to_string</code>が失敗した場合、<code>File::open</code>の戻り値を処理した<code>match</code>にエラー値を返したのと同じ方法でエラー値を返します。しかし、関数の最後の式であるため、<code>return</code>を明示的に言う必要はありません。</p>
<p>このコードを呼び出すコードは、ユーザ名を含む<code>Ok</code>値か、<code>io::Error</code>を含む<code>Err</code>値を得て扱います。呼び出し元のコードがそれらの値をどうするかはわかりません。呼び出しコードが<code>Err</code>値を得たら、 例えば、<code>panic!</code>を呼び出してプログラムをクラッシュさせたり、デフォルトのユーザ名を使ったり、ファイル以外の場所からユーザ名を検索したりできるでしょう。呼び出し元のコードが実際に何をしようとするかについて、十分な情報がないので、成功や失敗情報を全て委譲して適切に扱えるようにするのです。</p>
<p>Rustにおいて、この種のエラー委譲は非常に一般的なので、Rustにはこれをしやすくする<code>?</code>演算子が用意されています。</p>
<a class="header" href="#aエラー委譲のショートカット-演算子" id="aエラー委譲のショートカット-演算子"><h4>エラー委譲のショートカット: ?演算子</h4></a>
<p>リスト9-7は、リスト9-6と同じ機能を持つ<code>read_username_from_file</code>の実装を示していますが、この実装では<code>?</code>演算子を使います。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">リスト 9-7: <code>?</code>を使って呼び出し元のコードにエラーを返す関数</span></p>
<p><code>Result</code>値の後に置かれた<code>?</code>は、リスト9-6の<code>Result</code>値を扱うために定義した<code>match</code>式とほぼ同じように動作します。<code>Result</code>の値が<code>Ok</code>ならば、<code>Ok</code>の値がこの式から返され、プログラムは続行されます。値が<code>Err</code>の場合、<code>return</code>キーワードを使用したかのように関数全体から<code>Err</code>が返され、エラー値は呼び出し元のコードに委譲されます。</p>
<p>リスト9-6の<code>match</code>式と<code>?</code>演算子には違いは、<code>?</code>で取られたエラー値は、あるタイプから別のタイプへのエラーを変換するために使用される標準ライブラリの<code>From</code>特性で定義された<code>from</code>関数を通って行きます。<code>?</code>が<code>from</code>関数を呼び出すと、受け取ったエラーの型は、現在の関数の戻り値の型で定義されているエラーの型に変換されます。これは、関数が多くの異なる理由で失敗する可能性がある場合でも、関数が失敗する可能性のあるすべての方法を表す1つのエラータイプを返す場合に便利です。各エラータイプが<code>from</code>関数を実装して、返されたエラータイプに変換する方法を定義する限り、<code>?</code>は変換を自動的に処理します。</p>
<p>リスト9-7の文脈では、<code>File::open</code>呼び出しの最後の<code>?</code>は、<code>Ok</code>の値を変数<code>f</code>に返します。エラーが発生した場合、<code>?</code>は関数全体からすぐにリターンし、<code>Err</code>値を呼び出しコードに与えます。<code>read_to_string</code>呼び出しの最後の<code>?</code>も同じことが言えます。</p>
<p><code>?</code>演算子は多くの定型文を削除し、この関数の実装を簡単にします。リスト9-8のように、<code>?</code>の直後にメソッド呼び出しを連鎖させることで、このコードをさらに短縮することもできます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">リスト 9-8: <code>?</code>演算子の後のメソッド呼び出しを連結する</span></p>
<p>新しい<code>String</code>の作成を<code>s</code>の中で関数の始めに移しました。その部分は変更されていません。変数<code>f</code>を作成するのではなく、<code>File::open(&quot;hello.txt&quot;)?</code>の結果に<code>read_to_string</code>の呼び出しを直接連結しました。<code>read_to_string</code>呼び出しの最後に<code>?</code>があります。エラーを返すのではなく、<code>File::open</code>と<code>read_to_string</code>の両方が成功したときに<code>s</code>のユーザ名を含む<code>Ok</code>値を返します。この機能はリスト9-6とリスト9-7と同じです。ただ単に異なるバージョンのよりプログラマフレンドリーな書き方なのです。</p>
<p>この関数を書くさまざまな方法について言えば、これをもっと短くする方法があります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::fs;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
#}</code></pre></pre>
<p><span class="caption">リスト 9-9: <code>fs::read_to_string</code>を使う</span></p>
<p>ファイルを文字列に読み込むのはかなり一般的な操作なので、Rustは<code>fs::read_to_string</code>という便利な関数を提供します。これはファイルを開き、新しい<code>String</code>を作成し、ファイルの内容を読み込み、内容を<code>String</code>に入れて返します。もちろん、これはこのエラー処理の全てを見せる機会を与えるものではないので、最初の方法としては難しいものでした。</p>
<a class="header" href="#a演算子はresultを返す関数でしか使用できない" id="a演算子はresultを返す関数でしか使用できない"><h4><code>?</code>演算子は、<code>Result</code>を返す関数でしか使用できない</h4></a>
<p><code>?</code>演算子は、リスト9-6で定義した<code>match</code>式と同じように動作するように定義されているので、<code>Result</code>の戻り値型を持つ関数でのみ使用できます。<code>result</code>の戻り値の型を必要とする<code>match</code>の部分は<code>return Err(e)</code>なので、関数の戻り値の型はこの<code>return</code>と互換性がある<code>Result</code>でなければなりません。</p>
<p><code>main</code>関数で<code>?</code>演算子を使用したらどうなるか見てみましょう。main関数は戻り値が<code>()</code>でした。</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>このコードをコンパイルすると、以下のようなエラーメッセージが得られます。</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>このエラーは、<code>?</code>演算子は<code>Result</code>を返す関数でしか使用が許可されないと指摘しています。<code>Result</code>を返さない関数では、<code>Result</code>を返す別の関数を呼び出した時、<code>?</code>演算子を使用してエラーを呼び出し元に委譲する可能性を生み出す代わりに、<code>match</code>か<code>Result</code>のメソッドのどれかを使う必要があるでしょう。</p>
<p>しかし、 <code>main</code>関数は<code>Result&lt;T,E&gt;</code>を返すことができます。</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())

</code></pre>
<p><code>Box&lt;dyn Error&gt;</code>は&quot;trait object&quot;と呼ばれます。これについては第17章で説明します。今のところ、<code>Box&lt;dyn Error&gt;</code>は&quot;あらゆる種類のエラー&quot;を意味します。</p>
<p>ここまでで<code>panic!</code>呼び出しや<code>Result</code>を返す詳細について議論し終えたので、 どんな場合にどちらを使うのが適切か決める方法についての話に戻りましょう。</p>
<a class="header" href="#panicすべきかするまいか" id="panicすべきかするまいか"><h2><code>panic!</code>すべきかするまいか</h2></a>
<p>では、<code>panic!</code>を呼ぶべきときと<code>Result</code>を返すべきときをどう決めるのでしょうか？コードがパニックすると、回復する方法はありません。復旧の可能性があるかどうかにかかわらず、エラー状況に応じて<code>panic!</code>を呼び出すことができますが、呼び出す側のコードの立場に立ってこの場面は回復不能だという決定を下すことになります。<code>Result</code>値を返すことを選択した場合、決断を下すのではなく、呼び出し側に選択肢を与えます。呼び出しコードは、状況に適した方法で回復しようとするか、この場合の<code>Err</code>値が回復不能であると判断して、<code>panic!</code>を呼び出して回復可能だったエラーを回復不能に変換することもできます。したがって、失敗する可能性のある関数を定義するときは、<code>Result</code>を返すのが良い選択です。</p>
<p><code>Result</code>を返す代わりにパニックするコードを書く方が適切な場合がたまにあります。例やプロトタイプコード、テストでなぜパニックになるのが適切かを調べてみましょう。そして、コンパイラが失敗かどうかを人間のように考えることができない状況について話し合いましょう。この章では、ライブラリコードをパニックするかどうかを決定する方法に関する一般的なガイドラインを示します。</p>
<p>###例、プロトタイプコード、テスト</p>
<p>いくつかの概念を説明するための例を書くときには、堅牢なエラー処理コードを使用することで、この例をあまり明確にすることはできません。例では、<code>unwrap</code>のような、パニックに陥る可能性のあるメソッドへの呼び出しは、アプリケーションにエラーを処理してほしい方法へのプレースホルダーを意味していると理解され、残りのコードが何をしているかによって異なります。</p>
<p>同様に、<code>unwrap</code>と<code>expect</code>メソッドはエラーを処理する方法を決める準備が整う前のプロトタイプ作成時に非常に便利です。プログラムをより堅牢にする準備ができたときに、コードに明瞭なマーカーが残っているからです。</p>
<p>テストでメソッド呼び出しが失敗した場合、たとえそのメソッドがテスト中の機能ではなくても、テスト全体が失敗することが望しいです。<code>panic!</code>はテストが失敗としてマークされる方法であるため、<code>unwrap</code>や<code>expect</code>を呼び出すことはまさに何が起こるべきかです。</p>
<a class="header" href="#aコンパイラよりもプログラマがより情報を持っている場合" id="aコンパイラよりもプログラマがより情報を持っている場合"><h3>コンパイラよりもプログラマがより情報を持っている場合</h3></a>
<p><code>Result</code>が<code>Ok</code>値を持つことを確実にする他のロジックがあるときに<code>unwrap</code>を呼び出すことも適切でしょうが、ロジックはコンパイラが理解できるものではありません。それでも、まだ処理しなければならない<code>Result</code>値を持っています。なぜなら、呼び出している処理が何であれ、自分の特定の場面では論理的に起こり得なくても、一般的にまだ失敗する可能性はあるからです。手動でコードを調査して<code>Err</code>バリアントは存在しないと確認できたら、<code>unwrap</code>を呼び出すことは完全に受容できることです。ここに例があります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
#}</code></pre></pre>
<p>ハードコーディングされた文字列を解析することによって<code>IpAddr</code>インスタンスを作成しています。<code>127.0.0.1</code>は有効なIPアドレスであることがわかります。ここで<code>unwrap</code>を使用することは可能です。しかし、ハードコードされた有効な文字列を持っていても、<code>parse</code>メソッドの戻り値の型は変更されません。<code>Result</code>値が得られ、<code>Err</code>のように<code>Result</code>を処理します。コンパイラはこの文字列が常に有効なIPアドレスであることを知るほどスマートではないからです。IPアドレス文字列がプログラムにハードコードされているのではなく、失敗している可能性がある場合は、より堅牢な方法で<code>Result</code>を処理しなければなりません。</p>
<a class="header" href="#aエラー処理のガイドライン" id="aエラー処理のガイドライン"><h3>エラー処理のガイドライン</h3></a>
<p>コードが悪い状態になる可能性がある場合は、コードパニックを起こすことをお勧めします。この文脈において<em>悪い状態</em>は、無効な値、矛盾する値、欠損値がコードに渡されたり、次のうちの1つ以上が発生した場合など、いくつかの前提条件、保証、契約、または不変条件が破られた状態です。</p>
<ul>
<li>悪い状態がときに起こるとは<em>想定</em>されないとき</li>
<li>この時点以降、この悪い状態にないことを頼りにコードが書かれている場合</li>
<li>使用している型にこの情報をコード化するいい手段がないとき</li>
</ul>
<p>誰かが自分のコードを呼び出して筋の通らない値を渡してきたら、最善の選択肢は<code>panic!</code>し、開発段階で修正できるように自分たちのコードにバグがあることをライブラリ使用者に通知することかもしれません。同様に自分の制御下にない外部コードを呼び出し、修正しようのない無効な状態を返すときに<code>panic!</code>はしばしば適切です。</p>
<p>しかし、失敗が予想されるときは、<code>panic!</code>呼び出しを行うよりも<code>Result</code>を返す方が適切です。例えば、不正なデータが与えられたパーサーやレート制限を超えたことを示すステータスを返すHTTPリクエストが含まれます。このような場合、<code>Result</code>を返すことは、呼び出し元コードがどのように処理するかを決定しなければならない可能性が高いことを示します。</p>
<p>コードが値に対して操作を実行するとき、コードは値が有効であることを確認し、値が有効でない場合はパニックにする必要があります。これは主に安全上の理由によるものです。不正なデータの処理を試みると、コードを脆弱性に晒す可能性があります。これは、境界外のメモリアクセスを試みると、標準ライブラリが <code>panic!</code>を呼び出す主な理由です。現在のデータ構造に属さないメモリにアクセスしようとするのはセキュリティ上の一般的な問題です。関数にはしばしば<em>契約</em>が伴います。入力が特定の要件を満たしている場合にのみその動作が保証されます。契約違反は常に呼び出し側のバグを示し、呼び出しコードで明示的に処理しなければならない種類のエラーではないため、契約違反時にパニックが発生します。実際、コードを呼び出すための合理的な方法はありません。呼び出し元の<em>プログラマ</em>はコードを修正する必要があります。関数の契約、特に違反がパニックの原因となる場合は、関数のAPIドキュメントで説明する必要があります。</p>
<p>しかし、すべての機能で多くのエラーチェックを行うと、冗長で煩わしいことです。幸いなことに、Rustの型システム(コンパイラが行う型チェック)を使用して、多くのチェックを行うことができます。関数に引数として特定の型がある場合は、コンパイラが有効な値を持つことを既に確認していることを確認して、コードのロジックを進めることができます。例えば、<code>Option</code>ではなく型を持っているならば、プログラムは<em>何もない</em>ではなく<em>何かある</em>ことを想定します。そうするとコードは、<code>Some</code>と<code>None</code>バリアントの2つのケースを処理する必要はありません。それは確実に値を持つケースが1つしかありません。関数に何も渡そうとしないコードはコンパイルされないので、実行時にその関数をチェックする必要はありません。もう一つの例は<code>u32</code>のような符号なし整数型を使用して、引数が決して負でないことを保証するものです。</p>
<p>Rustの型システムを使用して有効な値をさらに確実に取得し、検証用のカスタム型を作成する方法を考えてみましょう。第2章の数あてゲームを思い出してください。このコードでは、1から100までの数字を推測するようにユーザーに求めました。その数字の間にユーザーの推測があることを確認してから、推測が肯定的であることを確認しました。この場合、その結果はそれほど悲惨ではありませんでした。「大きすぎ」、「小さすぎ」という結果は正しいでしょう。しかし、ユーザを有効な推測に導き、ユーザが範囲外の数字を推測したり、例えばユーザが文字を代わりに入力したりしたときに別の挙動をするようにしたら、有益な改善になるでしょう。</p>
<p>これを行う一つの方法は、ただの<code>u32</code>の代わりに<code>i32</code>として推測をパースし、負の数になる可能性を許可し、それから数字が範囲に収まっているというチェックを追加することです。</p>
<pre><code class="language-rust ignore">loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // --snip--
}
</code></pre>
<p>この<code>if</code>式は値が範囲外であるかどうかをチェックし、ユーザに問題を告通知し、<code>continue</code>を呼び出してループの次の繰り返しを始め、別の推測を求めます。<code>if</code>式の後、<code>guess</code>は1から100の間にあることを知って、秘密の数の比較を進めることができます。</p>
<p>しかし、これは理想的な解決策ではありません。プログラムが1〜100の値でしか動作しないことが絶対に重要で、この要件を持つ多くの機能を持っていれば、このようなチェックをすべての機能に持たせることは面倒でパフォーマンスにも影響を及ぼす可能性があります。</p>
<p>その代わりに新しい型を作成し、検証をどこにでも繰り返すのではなく型のインスタンスを作成する関数に入れることができます。そうすれば、関数が新しい型をシグニチャに使用し、受け取った値を確実に使用することは安全です。リスト9-10は、<code>new</code>関数が1と100の間の値を受け取った場合にのみ、<code>Guess</code>のインスタンスを生成する<code>Guess</code>型を定義する1つの方法を示しています：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 9-10: 値が1から100の場合のみ処理を継続する<code>Guess</code>型</span></p>
<p>まず、<code>u32</code>型のvalueをフィールドに持つ<code>Guess</code>という名前の構造体を定義しています。ここに数値が保管されます。</p>
<p>次に、<code>Guess</code>に<code>new</code>という名前の関数を実装して、<code>Guess</code>値のインスタンスを生成します。<code>new</code>関数は、<code>i32</code>型の<code>value</code>という1つの引数を持ち、<code>Guess</code>を返すように定義されています。<code>new</code>関数の本体にあるコードは<code>value</code>をテストして1から100の間であることを確認します。<code>value</code>がこのテストに合格しなかった場合、<code>panic!</code>呼び出しを行います。この範囲外の<code>value</code>を持つ<code>Guess</code>を作成すると<code>Guess::new</code>が依存している契約に違反するので、修正する必要があるバグがあるという呼び出しコードを書いています。<code>Guess::new</code>がパニックに陥るかもしれない条件は、公開されているAPIドキュメントで議論されるべきです。第14章で作成したAPIドキュメントに<code>panic!</code>の可能性を示すドキュメントの表記法について説明します。1valueがテスト1に合格した場合、<code>value</code>フィールドが<code>value</code>引数にセットされた新しいGuessを作成して返します。</p>
<p>次に、<code>self</code>を借用し、他の引数を持たず、<code>i32</code>を返す<code>value</code>というメソッドを実装します。この種のメソッドは、<em>ゲッター</em>と呼ばれることもあります。その目的は、フィールドからデータを取得して返すことです。<code>Guess</code>構造体の<code>value</code>フィールドがプライベートであるため、このパブリックメソッドは必要です。<code>value</code>フィールドはプライベートであることが重要です。<code>Guess</code>構造体を使用するコードは<code>value</code>を直接設定することはできません。モジュールの外側のコードは、<code>Guess::new</code>関数を使って <code>Guess</code>が<code>Guess::new</code>関数の条件でチェックされていない<code>value</code>を持つことができないようにします。</p>
<p>引数を一つ持つか、1から100の範囲の数値のみを返す関数はシグニチャで<code>u32</code>ではなく、<code>Guess</code>を取るか返し、本体内で追加の確認を行う必要はなくなります。</p>
<a class="header" href="#aまとめ-8" id="aまとめ-8"><h2>まとめ</h2></a>
<p>Rustのエラー処理機能は、プログラマがより頑健なコードを書く手助けをするように設計されています。<code>panic!</code>マクロは、プログラムが処理できない状態にあり、無効だったり不正な値で処理を継続するのではなく、プロセスに処理を中止するよう指示することを通知します。<code>Result</code>列挙型は、Rustの型システムを使用して、コードが回復可能な方法で処理が失敗するかもしれないことを示唆します。<code>Result</code>を使用して、呼び出し側のコードに成功や失敗する可能性を処理する必要があることも教えます。適切な場面で<code>panic!</code>や<code>Result</code>を使用することで、必然的な問題の眼前でコードの信頼性を上げてくれます。</p>
<p>ここまでで、標準ライブラリが<code>Option</code>や<code>Resul</code>列挙型などでジェネリクスを有効活用するところを目の当たりにしたので、ジェネリクスの動作法と自分のコードでの使用方法について語りましょう。</p>
<a class="header" href="#aジェネリック型トレイトライフタイム" id="aジェネリック型トレイトライフタイム"><h1>ジェネリック型、トレイト、ライフタイム</h1></a>
<p>すべてのプログラミング言語には、概念の重複を効果的に処理するツールがあります。Rustにおいて、そのようなツールの1つが<em>ジェネリックス</em>です。ジェネリックスは、具体的な型やその他のプロパティの抽象的な代役です。コードを書くときは、ジェネリックスの振る舞いや、コードをコンパイルして実行するときに何が起きるのかを知ることなく、ジェネリックスの動作や他のジェネリックとの関係を表現できます。</p>
<p>関数が未知の値を持つ引数を複数の具体的な値で同じコードを実行する方法と同様に、関数は<code>i32</code>や<code>String</code>のような具体的な型の代わりにいくつかの汎用型の引数を取ることができます。実際に第6章で<code>Option&lt;T&gt;</code>、第8章で<code>Vec &lt;T&gt;</code>、<code>HashMap&lt;K, V&gt;</code>、第9章で<code>Result&lt;T, E&gt;</code>を既に使用しました。この章では、ジェネリックスで独自の型、関数、およびメソッドを定義する方法について説明します。</p>
<p>まず、コードの重複を減らす関数を抽出する方法を見ていきます。次に、同じテクニックを使用して、引数の型だけが異なる2つの関数から汎用的な関数を作成します。構造体と列挙型の定義でジェネリック型を使用する方法についても説明します。</p>
<p>次に、<em>トレイト</em>を使用して動作を汎用的な方法で定義する方法を学びます。型をジェネリック型と組み合わせることで、ジェネリック型を特定の振る舞いを持つ型だけに制限することができます。</p>
<p>最後に、<em>ライフタイム</em>について説明します。ライフタイムとは、コンパイラに参照がお互いにどう関係しているかの情報を与える1種のジェネリックスです。ライフタイムでは、多くの状況で値を借用することができ、コンパイラーは参照が有効であることを確認することを可能にします。</p>
<a class="header" href="#a関数を抽出することで重複を取り除く" id="a関数を抽出することで重複を取り除く"><h2>関数を抽出することで重複を取り除く</h2></a>
<p>ジェネリックスの構文に入る前に、まず関数を抽出してジェネリック型を含まない重複を削除する方法を見てみましょう。次に、このテクニックを適用して汎用的な関数を抽出します。関数に重複したコードを抽出するのと同じ方法で、ジェネリックスを使用できる重複したコードを認識し始めます。</p>
<p>リスト10-1に示すように、リスト内で最大の数を見つける短いプログラムを考えてみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
#  assert_eq!(largest, 100);
}
</code></pre></pre>
<p><span class="caption">リスト 10-1: 数字のリストから最大値を求めるコード</span></p>
<p>このコードは整数のリストを変数<code>number_list</code>に格納し、最初の数値を<code>most</code>という名前の変数にリストに格納します。次に、リスト内のすべての数値を繰り返し処理し、現在の数値が<code>largest</code>に格納されている数値よりも大きい場合は、その変数の数値を置き換えます。ただし、現在の数値がこれまでに見た最大数値よりも小さい場合、変数は変更されず、コードはリストの次の数値に移動します。リスト内のすべての数字を考慮した後、<code>largest</code>は最大の数字を保持します。この場合は100です。</p>
<p>2つの異なる数値リストで最大の数値を見つけるには、リスト10-1のコードを複製し、プログラムの2つの異なる場所で同じロジックを使用することができます（リスト10-2を参照）。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">リスト 10-2: 2つの数値のリストから最大値を探すコード</span></p>
<p>このコードは機能しますが、コードを複製するのは面倒でエラーが発生しやすいです。コードを変更したいときは、複数の場所でコードを更新する必要があります。</p>
<p>この重複を排除するために、与えられた整数リストに作用する関数を引数で定義して抽象化を作成することができます。この解決法は、コードをより明確にし、最も大きな数字を抽象的にリストするという概念を表現することができます。</p>
<p>コードリスト10-3では、<code>largest</code>という名前の関数に最大の番号を見つけるコードを抽出しました。リスト10-1のコードとは異なり、このプログラムは特定の1つのリストで最大の番号を見つけることができますが、このプログラムは2つの異なるリストで最大の番号を見つけることができます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 6000);
}
</code></pre></pre>
<p><span class="caption">リスト 10-3: 2つのリストから最大値を探す抽象化されたコード</span></p>
<p><code>largest</code>関数には<code>list</code>という引数があります。この引数は関数に渡すことができる<code>i32</code>値の具体的なスライスを表します。 その結果、関数を呼び出すと、渡された特定の値でコードが実行されます。</p>
<p>まとめると、リスト10-2のコードをリスト10-3に変更するために取った手順は次のとおりです。</p>
<ol>
<li>重複したコードを特定する</li>
<li>関数の本体に重複したコードを抽出し、その関数のシグニチャにそのコードの入力と戻り値を指定します</li>
<li>代わりに関数を呼び出すように、重複したコードの2つのインスタンスを更新します。</li>
</ol>
<p>次に、これらの同じ手順をジェネリックで使用して、コードの重複をさまざまな方法で減らします。関数本体が特定の値の代わりに抽象的な<code>list</code>で動作するのと同じように、ジェネリックスは抽象型でコードを操作できるようにします。</p>
<p>例えば、<code>i32</code>値のスライスの中で最大のものを見つける関数と<code>char</code>値のスライスの中で最大のものを見つけるものの2つの関数があります。その重複をどのように排除しますか？確認してみましょう。</p>
<a class="header" href="#aジェネリックなデータ型" id="aジェネリックなデータ型"><h2>ジェネリックなデータ型</h2></a>
<p>関数シグニチャや構造体などの項目の定義を作成するためにジェネリックスを使用できます。これらの定義は、さまざまな具体的なデータ型で使用できます。まず、ジェネリックスを使って関数、構造体、列挙型、およびメソッドを定義する方法を見ていきましょう。次に、ジェネリックスがコードのパフォーマンスにどのように影響するかについて説明します。</p>
<a class="header" href="#a関数定義において" id="a関数定義において"><h3>関数定義において</h3></a>
<p>ジェネリックスを使用する関数を定義するとき、ジェネリックスを関数のシグニチャに置きます。ここでは、通常、引数と戻り値のデータ型を指定します。これにより、コードの柔軟性が高まり、コードの重複を防ぎながら、関数の呼び出し側に多くの機能が提供されます。</p>
<p><code>largest</code>関数を続けます。リスト10-4はどちらもスライスから最大値を探す2つの関数を示しています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
#    assert_eq!(result, 'y');
}
</code></pre></pre>
<p><span class="caption">リスト 10-4: 名前とシグニチャの型のみが異なる2つの関数</span></p>
<p><code>largest_i32</code>関数は、リスト10-3で抽出したもので、スライス内で最大の<code>i32</code>を見つけます。<code>largest_char</code>関数はスライス内で最大の<code>char</code>を見つけます。関数本体には同じコードがありますので、単一の関数にジェネリック型引数を導入して重複を排除しましょう。</p>
<p>定義する新しい関数の型を引数化するには、関数への値引数の場合と同様に、型引数の名前を付ける必要があります。任意の識別子を型引数名として使用できますが、<code>T</code>を使用します。&quot;慣習的にRustの引数名は短く(しばしば単なる文字)であり、Rustのタイプ命名規則はキャメルケースだからです。<code>T</code>は&quot;type&quot;の略で、ほとんどのRustプログラマのデフォルトの選択です。</p>
<p>関数の本体で引数を使用するときは、コンパイラがその名前の意味を知るように、シグニチャに引数名を宣言する必要があります。同様に、関数シグニチャに型引数名を使用する場合は、型引数名を宣言してから使用する必要があります。ジェネリックな<code>largest</code>関数を定義するには、型名宣言を山カッコ(<code>&lt;&gt;</code>)で囲み、関数名と引数リストの間に配置してください。</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>この定義を次のように読むことができます。<code>largest</code>関数は、なんらかの型<code>T</code>に関してジェネリックです。この関数は<code>list</code>という名前の1つの引数を持ちます。これは<code>T</code>型の値のスライスです。<code>largest</code>関数は、同じ型の<code>T</code>の値を返します。</p>
<p>リスト10-5は、そのシグニチャにジェネリックなデータ型を使用して、<code>largest</code>関数定義を組み合わせたものを示しています。リストには、関数を<code>i32</code>値のスライスまたは<code>char</code>値のいずれかで呼び出す方法も示されています。このコードはまだコンパイルされませんが、この章の後半で修正します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">リスト 10-5: ジェネリックな型引数を使用するものの、まだコンパイルできないlargest関数の定義</span></p>
<p>このコードをコンパイルすると、このエラーが発生します。</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>注釈には<code>std::cmp::PartialOrd</code>があります。これは<em>トレイト</em>です。トレイトについては次のセクションで説明します。今のところ、このエラーは<code>T</code>が可能なすべての可能な型に対して<code>largest</code>の本体が機能しないことを述べています。本体の<code>T</code>型の値を比較したいので、値を並べ替えることのできる型しか使用できません。比較を可能にするために、標準ライブラリには型に対して実装できる<code>std::cmp::PartialOrd</code>特性があります（この特性の詳細については付録Cを参照してください）。&quot;Tトレイト境界&quot;セクションでジェネリック型が特定の特性を持つように指定する方法を学びますが、まずジェネリック型引数を使用する他の方法を調べてみましょう。</p>
<a class="header" href="#a構造体定義において" id="a構造体定義において"><h3>構造体定義において</h3></a>
<p><code>&lt;&gt;</code>構文を使用して、1つ以上のフィールドでジェネリック型引数を使用するように構造体を定義することもできます。コードリスト10-6は、任意の型の<code>x</code>と<code>y</code>座標値を保持する<code>Point&lt;T&gt;</code>構造体を定義する方法を示しています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-6: 型<code>T</code>の<code>x</code>と<code>y</code>値を保持する<code>Point&lt;T&gt;</code>構造体</span></p>
<p>構造体定義でジェネリックを使用する構文は、関数定義で使用される構文に似ています。まず、構造体の名前の直後に山形括弧で囲まれた型引数の名前を宣言します。次に、具体的なデータ型を指定する場合は、構造体定義のジェネリック型を使用できます。</p>
<p><code>Point &lt;T&gt;</code>を定義するためにジェネリック型を1つしか使用していないので、<code>Point&lt;T&gt;</code>構造体はある種の<code>T</code>型よりも一般的で、<code>x</code>と<code>y</code>はどちらの型でも同じ型です。リスト10-7のように、異なる型の値を持つ<code>Point&lt;T&gt;</code>のインスタンスを作成すると、コードはコンパイルされません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listing 10-7: <code>x</code>と<code>y</code>のフィールドは、両方とも同じジェネリックデータ型<code>T</code>を持つので、同じ型でなければならない</span></p>
<p>この例では、整数値5を<code>x</code>に代入すると、ジェネリック型<code>T</code>が<code>Point &lt;T&gt;</code>のこのインスタンスの整数になることをコンパイラに知らせます。次に<code>x</code>と同じ型を持つように定義した<code>y</code>に4.0を指定すると、次のような型不一致エラーが発生します。</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
floating-point variable
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<p><code>x</code>と<code>y</code>が両方ともジェネリックであるが、異なるタイプを持つことができる<code>Point</code>構造体を定義するために、複数のジェネリック型引数を使うことができます。例えば、リスト10-8では<code>T</code>型と<code>U</code>型に対して<code>Point</code>の定義を変更することができます。<code>x</code>型は<code>T</code>型で<code>y</code>型は<code>U</code>型です。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-8: <code>Point&lt;T, U&gt;</code>は、<code>x</code>と<code>y</code>は異なる型の値になり得る</span></p>
<p><code>Point</code>のすべてのインスタンスが許可されました。定義には、必要な数のジェネリック型引数ーを使用できますが、いくつかを使用すると、コードを読みづらくなります。多くのジェネリック型が必要な場合は、コードがより小さな部分に再構成する必要があることのサインかもしれません。</p>
<a class="header" href="#enum定義において" id="enum定義において"><h3>enum定義において</h3></a>
<p>構造体で行ったように、さまざまな種類の汎用データ型を保持する列挙型を定義できます。 第6章で使用した、標準ライブラリが提供する <code>Option &lt;T&gt;</code> enumをもう一度見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>この定義は道理が通っているはずです。<code>Option&lt;T&gt;</code>は<code>T</code>型のジェネリックな列挙型で、<code>T</code>型の1つの値を保持する<code>Some</code>と値を何も保持しない<code>None</code>の2つのバリアントを持ちます。<code>Option&lt;T&gt;</code>列挙型を使うことで、オプショナルな値を持つという抽象的な概念を表現することができます。<code>Option&lt;T&gt;</code>はジェネリックスなので、オプショナルな値の型が何であってもこの抽象化を使用できます。</p>
<p>Enumは複数のジェネリック型も使用できます。第9章で使用した<code>Result</code>列挙体の定義は一例です。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p><code>Result</code>列挙型は<code>T</code>と<code>E</code>の2つの型に関してジェネリックスであり、<code>T</code>型の値を保持する<code>Ok</code>と<code>T</code>型の値を保持する<code>Err</code>の2種類のバリアントがあります。この定義は、成功する可能性のある操作（何らかの型の<code>T</code>型の値を返す）または失敗する型式（<code>E</code>型のエラーを返す）がある箇所で、<code>Result</code>列挙型を使うのが便利です。実際には、これはリスト9-3のファイルを開くために使用したものです。ファイルを開くのに成功した時に<code>T</code>に型<code>std::fs::File</code>が入り、ファイルを開く際に問題があった時に<code>E</code>に型<code>std::io::Error</code>が入ります。</p>
<p>自分のコード内で保持している値の型のみが異なる構造体やenum定義の場面を認識したら、代わりにジェネリックな型を使用することで重複を避けることができます。</p>
<a class="header" href="#aメソッド定義において" id="aメソッド定義において"><h3>メソッド定義において</h3></a>
<p>第5章で行ったように構造体と列挙型のメソッドを実装することができます。リスト10-9は、リスト10-6で定義した<code>Point&lt;T&gt;</code>構造体に<code>x</code>というメソッドを実装したものです。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">リスト 10-9: 型<code>T</code>の<code>x</code>フィールドへの参照を返す<code>x</code>というメソッドを<code>Point&lt;T&gt;</code>構造体に実装する</span></p>
<p>ここでは、フィールド<code>x</code>のデータへの参照を返す<code>Point&lt;T&gt;</code>に<code>x</code>という名前のメソッドを定義しました。</p>
<p><code>impl</code>の直後に<code>T</code>を宣言しなければならないので、<code>Point&lt;T&gt;</code>型のメソッドを実装するよう指定する必要があります。<code>impl</code>の後に<code>T</code>をジェネリック型として宣言することにより、Rustは<code>Point</code>の山括弧の型が具体的な型ではなくジェネリック型であることを識別できます。</p>
<p>たとえば、ジェネリック型の<code>Point&lt;T&gt;</code>インスタンスではなく、<code>Point&lt;f32&gt;</code>インスタンスでのみメソッドを実装することができます。リスト10-10では、具体的な型<code>f32</code>を使用します。つまり、<code>impl</code>の後に型を宣言しません。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 10-10: ジェネリックな型引数<code>T</code>に対して特定の具体的な型がある構造体にのみ適用される<code>impl</code>ブロック</span></p>
<p>このコードは、Point<f32>にはdistance_from_originというメソッドが存在するが、 Tがf32ではないPoint<T>の他のインスタンスにはこのメソッドが定義されないことを意味します。このメソッドは、ポイントが座標(0.0、0.0)のポイントからどれだけ離れているかを測定し、浮動小数点型に対してのみ使用可能な数学演算を使用します。</p>
<p>構造体定義のジェネリックな型引数は、必ずしもその構造体のメソッドシグニチャで使用するものと同じにはなりません。例えば、リスト10-11は、リスト10-8の<code>Point&lt;T, U&gt;</code>にメソッドmixupを定義しています。このメソッドは、他の<code>Point</code>を引数として取り、この引数は<code>mixup</code>を呼び出している<code>self</code>の<code>Point</code>とは異なる型の可能性があります。このメソッドは、型<code>T</code>の<code>self</code>の<code>Point</code>の<code>x</code>値と渡した型<code>W</code>の<code>Point</code>の<code>y</code>値から新しい<code>Point</code>インスタンスを生成します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">リスト 10-11: 構造体定義とは異なるジェネリックな型を使用するメソッド</span></p>
<p><code>main</code>では<code>x</code>（値が5）の<code>i32</code>と<code>y</code>の<code>f64</code>（値は<code>10.4</code>）を持つ<code>Point</code>を定義しました。<code>p2</code>変数は、<code>x</code>（値 &quot;Hello&quot;）を持つ文字列スライスと<code>y</code>（<code>c</code>を持つ）の<code>char</code>を持つ<code>Point</code>構造体です。引数<code>p2</code>で<code>p1</code>に<code>mixup</code>を呼び出すと、<code>p3</code>が得られ、<code>x</code>は<code>i32</code>になります。<code>x</code>は<code>p1</code>からきたからです。<code>p3</code>変数は、<code>y</code>に<code>char</code>になります。<code>y</code>は<code>p2</code>由来だからです。<code>println!</code>マクロの呼び出しは、 <code>p3.x = 5, p3.y = c</code>と出力するでしょう。</p>
<p>この例の目的は、いくつかの一般的な引数が<code>impl</code>で宣言され、いくつかがメソッド定義で宣言される状況を示すことです。 ここで、ジェネリック引数<code>T</code>と<code>U</code>は、<code>impl</code>の後に宣言されています。ジェネリック引数<code>V</code>と<code>W</code>は<code>fn mixup</code>の後で宣言されています。なぜならそれらはメソッドにしか関係ないからです。</p>
<a class="header" href="#aジェネリクスを使用したコードのパフォーマンス" id="aジェネリクスを使用したコードのパフォーマンス"><h3>ジェネリクスを使用したコードのパフォーマンス</h3></a>
<p>ジェネリック型引数を使用しているときにランタイムコストがあるかどうか疑問に思うかもしれません。良いニュースとして、コンパイラがジェネリクスを具体的な型がある時よりもジェネリックな型を使用したコードを実行するのが遅くならないように実装しています。</p>
<p>Rustは、コンパイル時にジェネリックを使用しているコードの単相化を実行することでこれを実現します。*単相化(monomorphization)*は、コンパイル時に使用される具体的な型を埋め込むことによって、ジェネリックなコードを特定のコードに変換するプロセスです。</p>
<p>このプロセスでは、コンパイラはコードリスト10-5のジェネリック関数を作成するために使用した手順の逆を行います。コンパイラはジェネリックコードが呼び出されるすべての場所を調べ、ジェネリックコードが呼び出される具体的な型のコードを生成します。</p>
<p>標準ライブラリの<code>Option&lt;T&gt;</code>列挙型を使った例を見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let integer = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>Rustがこのコードをコンパイルすると、単相化が実行されます。その過程で、コンパイラは<code>Option&lt;T&gt;</code>インスタンスで使用された値を読み込み、2種類の<code>Option&lt;T&gt;</code>を識別します。一つは<code>i32</code>で、もう一つは<code>f64</code>です。このように、<code>Option&lt;T&gt;</code>の一般的な定義を<code>Option_i32</code>と<code>Option_f64</code>に展開することで、一般的な定義を特定のものに置き換えます。</p>
<p>コードの単形化バージョンは以下のようになります。一般的な<code>Option&lt;T&gt;</code>は、コンパイラによって作成された特定の定義に置き換えられます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Rustはジェネリックコードを各インスタンスの型を指定するコードにコンパイルするので、ジェネリックの使用にはランタイムコストはかかりません。コードが実行されると、各定義を手作業で複製した場合と同じように機能します。単相化のプロセスにより、 Rustのジェネリクスは実行時に非常に効率的になるのです。</p>
<a class="header" href="#aトレイト-共通の振る舞いを定義する" id="aトレイト-共通の振る舞いを定義する"><h2>トレイト: 共通の振る舞いを定義する</h2></a>
<p><em>トレイト</em>は特定の型が持つ機能についてRustコンパイラに指示し、他の型と共有することができます。トレイトを使用して抽象的な方法で共有動作を定義することができます。トレイト境界を使用して、ジェネリックスが特定の動作を持つ任意のタイプであることを指定できます。</p>
<blockquote>
<p>注：トレイトは、いくつかの違いがありますが他の言語では<em>interfaces</em>と呼ばれる機能に似ています。</p>
</blockquote>
<a class="header" href="#aトレイを定義する" id="aトレイを定義する"><h3>トレイを定義する</h3></a>
<p>型の振る舞いは、その型に対して呼び出すことができるメソッドから構成されます。異なる型は、それらの型すべてに対して同じメソッドを呼び出せる場合、同じ動作を共有します。トレイトの定義は、メソッドシグニチャをグループ化して、目的を達成するために必要な一連の動作を定義する方法です。</p>
<p>たとえば、さまざまな種類と量のテキストを保持する複数の構造体があるとしましょう。特定の場所に保管されているニュース記事を保持する<code>NewsArticle</code>構造体と、新規ツイートか、リツイートか、はたまた他のツイートへのリプライなのかを示すメタデータを伴う最大で280文字までの<code>Tweet</code>構造体です。</p>
<p><code>NewsArticle</code>や<code>Tweet</code>インスタンスに保存される可能性のあるデータの要約を表示できるメディア要約ライブラリを作成したいと考えています。これを行うには、それぞれの型から要約が必要です。インスタンスに対して<code>summarize</code>メソッドを呼び出すことによって要約を要求する必要があります。リスト10-12は、この振る舞いを表現する<code>Summary</code>トレイトの定義を示しています。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-12: <code>summarize</code>メソッドで提供される振る舞いからなる<code>Summary</code>トレイト</span></p>
<p>ここでは、<code>trait</code>キーワードを使用してトレイトを宣言し、次にこのトレイト名<code>Summary</code>を指定しています。中括弧の中で、このトレイトを実装する型の振る舞いを記述するメソッドシグニチャを宣言します。今回の場合は<code>fn summarize(&amp;self) -&gt; String</code>です。</p>
<p>メソッドシグニチャの後に、中括弧で実装する代わりに、セミコロンを使用します。このトレイトを実装する各タイプは、メソッドの本体に対して独自のカスタム動作を提供する必要があります。コンパイラは<code>Summary</code>トレイトを持つ型は、このシグニチャで定義された<code>summarize</code>メソッドを正確に定義するように強制します。</p>
<p>トレイトは、その本体に複数のメソッドを持つことができます。メソッドのシグニチャは1行に1つずつリストされ、各行はセミコロンで終わります。</p>
<a class="header" href="#aトレイトを型に実装する" id="aトレイトを型に実装する"><h3>トレイトを型に実装する</h3></a>
<p><code>Summary</code>トレイトを使って望ましい振る舞いを定義しましたので、メディア要約の型に実装することができます。リスト10-13は見出し、著者、場所を使用して<code>summarize</code>の戻り値を生成する<code>NewsArticle</code>構造体の<code>Summary</code>トレイト実装を示しています。<code>Tweet</code>構造体の場合、ツイートの内容が既に280文字に制限されていると想定して、<code>summarize</code>をユーザ名にツイート全体のテキストが続く形で定義します。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Summary {
#     fn summarize(&amp;self) -&gt; String;
# }
#
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 10-13: <code>Summary</code>トレイトをN<code>ewsArticle</code>と<code>Tweet</code>型に実装する</span></p>
<p>ある型の特性を実装することは、通常のメソッドを実装することと似ています。違いは、<code>impl</code>の後に実装したいトレイト名を入れてから、<code>for</code>キーワードを使い、そのトレイトを実装する型の名前を指定することです。<code>impl</code>ブロック内で、トレイト定義が定義したメソッドのシグニチャを記述します。各シグニチャの後にセミコロンを追加する代わりに、中括弧を使用して、メソッド本体に特定の型のトレイトのメソッドに欲しい特定の振る舞いを記述します。</p>
<p>このトレイトを実装した後、次のような通常のメソッドと同じ方法で、<code>NewsArticle</code>と<code>Tweet</code>のインスタンスのメソッドを呼び出すことができます。</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>このコードは<code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>と出力します。</p>
<p>リスト10-13の同じ<em>lib.rs</em>に<code>Summary</code>特性と<code>NewsArticle</code>と<code>Tweet</code>型を定義したので、それらはすべて同じスコープに入っています。この<em>lib.rs</em>を<code>aggregator</code>と呼ばれるクレート専用にして、誰か他の人がこのクレートの機能を活用して自分のライブラリのスコープに定義された構造体に<code>Summary</code>トレイトを実装したいとしましょう。まず、トレイトをスコープにインポートする必要があります。<code>use aggregator::Summary;</code>と指定してそれを行い、これにより自分の型に<code>Summary</code>を実装することが可能になります。<code>Summary</code>トレイトは、 他のクレートが実装するためには、公開トレイトである必要があり、ここではリスト10-12の<code>trait</code>の前に、<code>pub</code>キーワードを置いたのでそうなっています。</p>
<p>トレイトの実装で注意すべき制限の1つは、トレイトか対象の型が自分のクレートにローカルである時のみ、型に対してトレイトを実装できるということです。たとえば、<code>Tweet</code>は<code>aggregator</code>クレートのローカルなので、<code>Display</code>のような標準ライブラリのトレイトを<code>Tweet</code>のようなカスタムタイプに実装することができます。<code>Summary</code>は<code>aggregator</code>クレートのローカルなので、<code>aggregator</code>クレートに<code>Vec&lt;T&gt;</code>に<code>Summary</code>を実装することもできます。</p>
<p>しかし、外部の型に外部のトレイトを実装することはできません。例えば、<code>aggregator</code>クレート内で<code>Vec&lt;T&gt;</code>に対して<code>Display</code>トレイトを実装することはできません。<code>Display</code>と<code>Vec&lt;T&gt;</code>は標準ライブラリで定義され、<code>aggregator</code>クレートにローカルではないからです。この制限は、*コヒーレンス(coherence)*と呼ばれるプログラムのプロパティの一部であり、より具体的には、*オーファンルール(orphan rule)*であり、親の型が存在しないためそのように名前が付けられています。このルールは、他の人のコードが自分のコードを壊すことができないようにします。このルールがなければ、2つのクレートが同じ型の同じトレイトを実装でき、Rustはどちらの実装を使用すべきかがわからなくなります。</p>
<a class="header" href="#aデフォルト実装" id="aデフォルト実装"><h3>デフォルト実装</h3></a>
<p>場合によっては、全ての型の全メソッドに対して実装を必要とするのではなく、トレイトの全てあるいは一部のメソッドに対してデフォルトの振る舞いがあると便利です。そうすれば、特定の型のトレイトを実装する際に、各メソッドのデフォルト動作を保持またはオーバーライドできます。</p>
<p>リスト10-14は、リスト10-12のように、メソッドのシグニチャのみを定義するのではなく、<code>Summary</code>トレイトの<code>summarize</code>メソッドにデフォルトの文字列を指定する方法を示しています。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 10-14: <code>summarize</code>メソッドのデフォルト実装がある<code>Summary</code>トレイトの定義</span></p>
<p>デフォルト実装を使用して独自の実装を定義するのではなく、<code>NewsArticle</code>のインスタンスをまとめるには、<code>impl Summary for NewsArticle {}</code>と空の<code>impl</code>ブロックを指定します。</p>
<p><code>NewsArticle</code>に<code>summarize</code>メソッドを直接定義しなくても、デフォルトの実装を提供し、<code>NewsArticle</code>が<code>Summary</code>トレイトを実装するように指定しました。その結果、<code>NewsArticle</code>のインスタンスに対して<code>summarize</code>メソッドを呼び出すことができます。</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summarize());
</code></pre>
<p>このコードは<code>New article available! (Read more...)</code>と出力します。</p>
<p><code>summarize</code>のデフォルト実装を作成しても、リスト10-13の<code>Tweet</code>の<code>Summary</code>の実装について何も変更する必要はありません。その理由は、既定の実装をオーバーライドする構文は、既定の実装を持たないトレイトのメソッドを実装するための構文と同じだからです。</p>
<p>デフォルト実装は、他のデフォルト実装がないメソッドでも呼び出すことができます。このように、トレイトは多くの有用な機能を提供することができ、実装者が一部しか指定しなくてよくなります。例えば、<code>summary</code>トレイトを実装する必要がある<code>summarize_author</code>メソッドを定義し、<code>summarize_author</code>メソッドを呼び出すデフォルト実装を持つ<code>summarize</code>メソッドを定義することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
#}</code></pre></pre>
<p>このバージョンの<code>Summary</code>を使うためには、型にトレイトを実装するとき<code>summarize_author</code>のみを定義する必要があります。</p>
<pre><code class="language-rust ignore">impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p><code>summarize_author</code>を定義した後、<code>Tweet</code>構造体のインスタンスに対して<code>summarize</code>を呼び出すことができます。<code>summarize</code>のデフォルト実装は<code>summarize_author</code>の定義を呼び出します。<code>summarize_author</code>を実装しているので、<code>Summary</code>トレイとは、コードを書く必要なしに<code>summarize</code>メソッドの動作を与えました。</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>このコードは<code>1 new tweet: (Read more from @horse_ebooks...)</code>と出力します。</p>
<p>同じメソッドのオーバーライド実装からデフォルト実装を呼び出すことはできません。</p>
<a class="header" href="#a引数としてのトレイト" id="a引数としてのトレイト"><h3>引数としてのトレイト</h3></a>
<p>トレイトを定義し、それらを型に実装する方法を知っているので、さまざまな型の引数を受け入れるためにトレイトを使用する方法を探ることができます。</p>
<p>たとえば、リスト10-13では<code>NewsArticle</code>と<code>Tweet</code>型の<code>Summary</code>トレイトを実装しました。引数に<code>summary</code>トレイトを実装した型の<code>item</code>を受け取り、<code>item</code>の<code>summarize</code>メソッドを呼び出す<code>notify</code>関数を定義することができます。これを行うには、次のように <code>impl Trait</code>構文を使用できます。</p>
<pre><code class="language-rust ignore">pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p><code>notify</code>の本体では<code>summar</code>のような<code>summary</code>トレイトから来た<code>item</code>のメソッドを呼び出すことができます。</p>
<a class="header" href="#aトレイト境界" id="aトレイト境界"><h4>トレイト境界</h4></a>
<p><code>impl Trait</code>構文は短い例では便利ですが、長い形式ではシンタックスシュガーです。これは<em>トレイト境界</em>と呼ばれ、以下のようになります。</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>これは上記の例と同じですが、少し冗長です。コロンと内側の山括弧の後に、ジェネリック型引数の宣言でトレイト境界を配置します。<code>T</code>に束縛されたトレイトのため、<code>NewsArticle</code>や<code>Tweet</code>のインスタンスを引数に渡して<code>notify</code>を呼ぶことができます。<code>String</code>や<code>i32</code>のような他の型の関数を呼び出すコードは、<code>Summary</code>を実装していないのでコンパイルされません。</p>
<p><code>Imp Trait</code>ではなく、いつこの構文を使うべきでしょうか？<code>impl Trait</code>は短い例題にはうってつけですが、trait境界はもっと複雑なものに便利です。たとえば、<code>Summary</code>を実装する2つの引数を受け取りたいとします。</p>
<pre><code class="language-rust ignore">pub fn notify(item1: impl Summary, item2: impl Summary) {
</code></pre>
<p>これは<code>item1</code>と<code>item2</code>が異なる型を持つことが許されていれば（両方とも<code>Summary</code>を実装している限り）うまくいくでしょう。しかし、両方を同じタイプにすることを強制したいのであればどうしますか？それは、トレイト境界を使用する場合にのみ可能です。</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) {
</code></pre>
<a class="header" href="#aで複数のトレイトを指定する" id="aで複数のトレイトを指定する"><h4><code>+</code>で複数のトレイトを指定する</h4></a>
<p><code>item</code>に書式を表示するために<code>notify</code>メソッドが必要で、その中で<code>summarize</code>メソッドを使うのであれば、<code>item</code>は<code>Display</code>と<code>Summary</code>の二つの異なるトレイトを同時に実装する必要があります。これは<code>+</code>構文を使って行うことができます。</p>
<pre><code class="language-rust ignore">pub fn notify(item: impl Summary + Display) {
</code></pre>
<p>この構文は、ジェネリック型のトレイト境界でも有効です。</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: T) {
</code></pre>
<a class="header" href="#aより明確なコードのための-where句" id="aより明確なコードのための-where句"><h4>より明確なコードのための <code>where</code>句</h4></a>
<p>しかし、あまりにも多くのトレイト境界を使用することには欠点があります。各ジェネリックスには独自のトレイト境界があるため、複数のジェネリック型引数を持つ関数は、関数名とその引数リストの間に多くのトレイト境界情報を持ち、関数シグニチャを読みにくくします。この理由から、Rustは関数シグニチャの後に<code>where</code>節の中でトレイト境界を指定するための代替構文を持っています。次のように書くのではなく、</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>次のように<code>where</code>節を使うことができます。</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>関数名、引数リスト、および戻り値の型が密接して定義されているので、この関数のシグニチャはすっきりします。</p>
<a class="header" href="#aトレイトを返す" id="aトレイトを返す"><h3>トレイトを返す</h3></a>
<p>戻り値の位置で<code>impl Trait</code>構文を使用して、トレイトを実装したものを返すこともできます。</p>
<pre><code class="language-rust ignore">fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p>このシグニチャは、「私は<code>Summary</code>トレイトを実装するものを返すつもりですが、正確な型を伝えるつもりはありません」と述べています。この場合、<code>Tweet</code>を返していますが、呼び出した人はそれを知りません。</p>
<p>これはどのように役に立つのでしょうか？13章では、トレイトに大きく依存する2つの機能、クロージャー、イテレーターについて学びます。これらの機能は、コンパイラだけが知っている型、または非常に長い型を作成します。<code>impl Trait</code>は長い型を書く必要なく、「これは<code>Iterator</code>を返します」と簡単に宣言することができます。</p>
<p>しかし、これは戻ってくる単一の型を持っている場合にのみ機能します。たとえば、これはうまく<em>いかない</em>でしょう。</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(&quot;The Pittsburgh Penguins once again are the best
            hockey team in the NHL.&quot;),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(&quot;of course, as you probably already know, people&quot;),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<p>ここでは、<code>NewsArticle</code>または<code>Tweet</code>のいずれかを返します。これは、<code>impl Trait</code>がどのように機能するかという制限があるため、うまくいきません。このコードを書くには、第17章の「さまざまな型の値を許容する特性オブジェクトの使用」の項まで待つ必要があります。</p>
<a class="header" href="#aトレイト境界でlargest関数を修正する" id="aトレイト境界でlargest関数を修正する"><h3>トレイト境界でlargest関数を修正する</h3></a>
<p>ジェネリック型引数の境界を使用して振る舞いを指定する方法を知ったので、リスト10-5に戻ってジェネリック型引数を使用する<code>largest</code>関数の定義を修正しましょう。前回このコードを実行しようとすると、以下のようなエラーが発生しました。</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p><code>largest</code>の本体では、大なり(<code>&gt;</code>)演算子を使って<code>T</code>型の2つの値を比較したいと考えました。この演算子は標準ライブラリトレイト<code>std:: cmp::PartialOrd</code>のデフォルトメソッドとして定義されているため、比較できるあらゆる型のスライスに対して動くようにTのトレイト境界に<code>PartialOrd</code>を指定する必要があります。<code>PartialOrd</code>は、初期化処理に入っているので、スコープに入れる必要はありません。<code>largest</code>のシグニチャを次のように変更します。</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>コードをコンパイルすると、異なる一連のエラーが発生します。</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&amp;list[0]`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:4:9
  |
4 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>このエラーのキーとなる行は<code>cannot move out of type [T], a non-copy slice</code>です。ジェネリックでないバージョンのlargest関数では、最大のi32かcharを探そうとするだけでした。第4章の「スタックオンリーデータ：コピー」で説明したように、既知のサイズを持つ<code>i32</code>や<code>char</code>のような型はスタックに格納できるので、<code>Copy</code>トレイトを実装します。しかし、<code>largest</code>関数をジェネリックスにすることで、<code>list</code>引数は<code>Copy</code>トレイトを実装しない型を持つことが可能になりました。その結果、<code>list[0]</code>から<code>maximum</code>変数に値を移動することができなくなり、このエラーが発生します。</p>
<p><code>Copy</code>トレイトを実装する型だけでこのコードを呼び出すには、<code>T</code>のトレイト境界に<code>Copy</code>を追加することで実現します。リスト10-15は、関数に渡したスライスの値の型が<code>i32</code>や<code>char</code>などのように、<code>PartialOrd</code>と<code>Copy</code>を実装する限り、コンパイルできるジェネリックな<code>largest</code>関数の完全なコードを示しています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">リスト 10-15: <code>PartialOrd</code>と<code>Copy</code>トレイトを実装するあらゆるジェネリックな型に対して動く、<code>largest</code>関数の定義</span></p>
<p>もしlargest関数をCopyを実装する型だけに制限したくなかったら、Copyではなく、 TがCloneというトレイト境界を含むと指定することもできます。そうすると、<code>largest</code>関数に所有権を持たせたいときに、スライス内の各値を複製することができます。<code>clone</code>関数を使うことは、<code>String</code>のようなヒープデータを所有する型の場合にヒープ割り当てを増やすことを意味し、大量のデータを扱う場合はヒープ割り当てが遅くなる可能性があります。</p>
<p><code>largest</code>を実装する別の方法は、スライス内の<code>T</code>値への参照を返す関数です。戻り値の型を<code>T</code>ではなく<code>&amp;T</code>に変更して、関数の本体を変更して参照を返すと、<code>Clone</code>や<code>Copy</code>トレイト境界は必要なくなり、ヒープ割り当てを避けることができます。これらの他の解決策を自分で実装してみてください！</p>
<a class="header" href="#aトレイト境界を使用してメソッド実装を条件分けする" id="aトレイト境界を使用してメソッド実装を条件分けする"><h3>トレイト境界を使用して、メソッド実装を条件分けする</h3></a>
<p><code>impl</code>ブロックでジェネリックな型引数を使用するトレイト境界を活用することで、特定のトレイトを実装する型に対するメソッド実装を
条件分岐できます。たとえば、リスト10-16の<code>Pair&lt;T&gt;</code>型は常に<code>new</code>関数を実装しています。しかし、<code>Pair&lt;T&gt;</code>は、内部の型<code>T</code>が比較を可能にする<code>PartialOrd</code>トレイトと出力を可能にする<code>Display</code>トレイトを実装している時のみ、<code>cmp_display</code>メソッドを実装します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 10-16: トレイト境界によってジェネリックな型に対するメソッド実装を条件分けする</span></p>
<p>また、別のトレイトを実装する任意の型のための条件を条件付きで実装することもできます。トレイト境界を満たす任意のタイプの特性の実装は、*ブランケット実装(blanket implementation)*と呼ばれ、Rust標準ライブラリで広く使用されています。例えば、標準ライブラリは、<code>Display</code>トレイトを実装する任意の型の<code>ToString</code>トレイトを実装します。標準ライブラリの<code>impl</code>ブロックはこのコードに似ています。</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>標準ライブラリはこのブランケットの実装を持っているので、<code>Display</code>特性を実装するすべての型の<code>ToString</code>トレイトによって定義された<code>to_string</code>メソッドを呼び出すことができます。例えば、整数は<code>Display</code>を実装しているので、整数を対応する<code>String</code>値に変換することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<p>ブランケット実装は、「実装したもの」セクションのトレイトに関するドキュメントに記載されています。</p>
<p>トレイトとトレイト境界は、複製を減らすためにジェネリック型引数を使用するコードを書くだけでなく、ジェネリック型に特定の動作を持たせたいというコンパイラを指定します。コンパイラは、トレイト境界の情報を使用して、コードで使用されているすべての具体的な型が正しい動作を提供しているかどうかをチェックできます。動的に型付けされた言語では、型が実装しなかった型に対してメソッドを呼び出すと、実行時にエラーが発生します。しかし、Rustはこれらのエラーをコンパイルするためにコンパイルするので、コードを実行する前に問題を修正する必要があります。さらに、コンパイル時にすでにチェックしているため、実行時に動作をチェックするコードを記述する必要はありません。そうすることで、ジェネリックの柔軟性を失うことなく、パフォーマンスが向上します。</p>
<p>もう使用したことのある別の種類のジェネリクスは、<em>ライフタイム</em>と呼ばれます。型が欲しい振る舞いを保持していることを保証するのではなく、必要な間だけ参照が有効であることをライフタイムは保証します。ライフタイムがどうやってそれを行うかを見ましょう。</p>
<a class="header" href="#aライフタイムで参照を有効化する" id="aライフタイムで参照を有効化する"><h2>ライフタイムで参照を有効化する</h2></a>
<p>第4章の「参照と借用」のセクションでは説明しなかった1つの詳細は、Rustのすべての参照にはその参照が有効なスコープである<em>ライフタイム</em>があることです。型が推論されるように、ライフタイムも暗黙的に推論されます。複数の型の可能性がある場合、型に注釈を付ける必要があります。同様の方法で、参照の存続期間がいくつか異なる方法で関係する可能性がある場合、ライフタイムに注釈を付ける必要があります。Rustでは、実行時に使用される実際の参照が確実に有効であることを保証するために、ジェネリックなライフタイム引数を使用して関係に注釈を付ける必要があります。</p>
<p>ライフタイムのコンセプトは、他のプログラミング言語のツールとは多少異なります。間違いなく、Rustの最も特徴的な機能です。この章では、ライフタイム全体については触れませんが、ライフタイムの構文に遭遇する可能性のある一般的な方法について説明し、概念に慣れることができます。詳細については、第19章の「高度なライフタイム」の項を参照してください。</p>
<a class="header" href="#aライフタイムを参照するダングリングの防止" id="aライフタイムを参照するダングリングの防止"><h3>ライフタイムを参照するダングリングの防止</h3></a>
<p>ライフタイムの主な目的は、参照することを意図したデータ以外のデータをプログラムが参照させるダングリング参照を防止することです。外側スコープと内側スコープを持つリスト10-17のプログラムを考えてみましょう。</p>
<pre><code class="language-rust ignore does_not_compile">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">リスト 10-17: 値がスコープを抜けてしまった参照を使用しようとする</span></p>
<blockquote>
<p>注：リスト10-17、10-18、および10-24の例では、変数に初期値を指定せずに変数を宣言しているため、変数名は外部スコープに存在します。一見すると、これはnull値を持たないRustと衝突しているように見えるかもしれません。しかし、変数に値を渡す前に変数を使用しようとすると、コンパイル時エラーが発生します。これは、Rustが実際にnull値を許可しないことを示しています。</p>
</blockquote>
<p>外側スコープは<code>r</code>という名前の変数を初期値なしで宣言し、内側スコープは<code>x</code>という名前の変数を初期値5で宣言します。内側のスコープ内で、<code>r</code>の値を<code>x</code>への参照にセットしようとしています。それから内側のスコープが終わり、<code>r</code>の値を出力しようとしています。<code>r</code>が参照している値が使おうとする前にスコープを抜けるので、このコードはコンパイルできません。以下がエラーメッセージです。</p>
<pre><code class="language-text">error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:5
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>変数<code>x</code>は「生存期間が短すぎます」。なぜなら、内部スコープが7行目で終了すると<code>x</code>がスコープから外れるからです。しかし <code>r</code>は外側スコープに対しても有効です。Rustでこのコードが動くことを許可していたら、<code>r</code>は<code>x</code>がスコープを抜けた時に解放されるメモリを参照していることになり、<code>r</code>で行おうとするいかなることも動かないでしょう。では、どうやってコンパイラはこのコードが無効であると決定しているのでしょうか？*借用精査機(borrow checker)*を使用しています。</p>
<a class="header" href="#a借用精査機" id="a借用精査機"><h3>借用精査機</h3></a>
<p>Rustコンパイラにはスコープを比較してすべての借用が有効かどうかを判断する<em>借用精査機</em>があります。リスト10-18は、リスト10-17と同じコードを示していますが、コメントには変数のライフタイムが示されています。</p>
<pre><code class="language-rust ignore does_not_compile">{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre>
<p><span class="caption">リスト10-18: それぞれ<code>'a</code>と<code>'b</code>と名付けられた<code>r</code>と<code>x</code>のライフタイムのコメント</span></p>
<p>ここでは、<code>r</code>の存続期間を<code>'a</code>、<code>x</code>の存続期間を<code>'b</code>と注釈を付けました。見てわかるように、内側の<code>'b</code>ブロックは、外側の<code>'a</code>ライフタイムブロックよりもはるかに小さくなっています。コンパイル時に、Rustは2つのライフタイムのサイズを比較して、 <code>r</code>は<code>'a</code>のライフタイムだけれども、<code>'b</code>のライフタイムのメモリを参照していると確認します。<code>'b</code>は<code>'a</code>よりも短いので、プログラムは拒否されます。参照の被写体が参照ほど長生きしないのです。</p>
<p>リスト10-19はコードを修正して、ダグルな参照がなく、エラーなくコンパイルします。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
#}</code></pre></pre>
<p><span class="caption">リスト 10-19: データのライフタイムが参照より長いので、有効な参照</span></p>
<p>ここで、<code>x</code>はライフタイム<code>'b</code>になり、この場合<code>'a</code>よりも大きいです。これはコンパイラは<code>x</code>が有効な間、<code>r</code>の参照も常に有効になることを把握しているので、<code>r</code>は<code>x</code>を参照できることを意味します。</p>
<p>参照のライフタイムと、Rustがライフタイムをどのように分析して参照が常に有効になるかを知ったので、関数の文脈で引数と戻り値の一般的なライフタイムを調べてみましょう。</p>
<a class="header" href="#a関数のジェネリックなライフタイム" id="a関数のジェネリックなライフタイム"><h3>関数のジェネリックなライフタイム</h3></a>
<p>2つの文字列スライスのうち長い方を返す関数を記述しましょう。この関数は2つの文字列スライスを取り、文字列スライスを返します。<code>longest</code>関数を実装完了後、リスト10-20のコードは<code>The longest string is abcd</code>を出力します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">リスト 10-20: <code>longest</code>関数を呼び出して2つの文字列スライスのうち長い方を探す<code>main</code>関数</span></p>
<p><code>longest</code>関数に引数の所有権を奪ってほしくないため、関数が受け取って欲しい引数が文字列スライス、つまり参照であることに注意してください。関数が<code>String</code>（変数<code>string1</code>に格納されている型）のスライスと、文字列リテラル（変数<code>string2</code>に含まれているもの）を受け入れるようにしたいとします。</p>
<p>リスト10-20で使用する引数がなぜ必要なのかについては、第4章の「引数としての文字列スライス」を参照してください。</p>
<p>リスト10-21に示すような <code>longest</code>関数を実装しようとすると、コンパイルされません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">リスト 10-21:  2つの文字列スライスのうち長い方を返すけれども、コンパイルできないlongest関数の実装</span></p>
<p>代わりにライフタイムについて説明する、以下のエラーを受け取ります。</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:33
  |
1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>ヘルプテキストは、返されるリファレンスが<code>x</code>または<code>y</code>を参照するかどうかをRustが知ることができないため、戻り値の型がそれにジェネリックなライフタイム引数を必要とすることを示しています。実際には、この関数の本体の<code>if</code>ブロックは<code>x</code>への参照を返し、<code>else</code>ブロックは<code>y</code>への参照を返すので、どちらかわかりません。</p>
<p>この関数を定義するとき、この関数に渡される具体的な値はわからないので、<code>if</code>か<code>else</code>のどちらが実行されるかはわかりません。また、渡される参照の具体的なライフタイムもわからないため、リスト10-18および10-19で行ったようにスコープを見ることができず、返す参照が常に有効かどうかが判断されます。<code>x</code>と<code>y</code>のライフタイムが返り値の存続期間にどのように関係しているのか分からないので、借用精査機はこれを判断することができません。このエラーを修正するために、借用精査機が解析を実行できるよう、参照間の関係を定義するジェネリックなライフタイム引数を追加します。</p>
<a class="header" href="#aライフタイム注釈記法" id="aライフタイム注釈記法"><h3>ライフタイム注釈記法</h3></a>
<p>ライフタイム注釈はいかなる参照のライフタイムを変更しません。シグニチャがジェネリック型引数を指定するときに関数が任意の型を受け入れるのと同じように、関数はジェネリックなライフタイム引数を指定することで、任意のライフタイムの参照を受け入れることができます。ライフタイム注釈は、ライフタイムに影響を与えることなく、複数のリファレンスのライフタイムの相互関係を記述します。</p>
<p>生涯の注釈には少し珍しい構文があります。生涯引数の名前はアポストロフィ(<code>'</code>)で始まらなければならず、通常はジェネリック型のようにすべて小文字で非常に短いです。ほとんどの人は<code>'a</code>という名前を使用します。ライフタイム引数注釈は、参照の<code>&amp;</code>の後に配置し、注釈と参照の型を区別するために空白を1つ使用します。</p>
<p>ここにいくつかの例があります。ライフタイム引数なしの<code>i32</code>への参照、<code>'a</code>というライフタイム引数付きの<code>i32</code>への参照、 同じくライフタイム<code>'a</code>付き<code>i32</code>への可変参照です。</p>
<pre><code class="language-rust ignore">&amp;i32        // ただの参照
&amp;'a i32     // 明示的なライフタイム付きの参照
&amp;'a mut i32 // 明示的なライフタイム付きの可変参照
</code></pre>
<p>1つのライフタイム注釈それだけでは、大して意味はありません。ライフタイム注釈は、複数の参照のジェネリックなライフタイム引数が、 お互いにどう関係するかをコンパイラに指示することを意図しているからです。たとえば、ライフタイム<code>'a</code>付きの<code>i32</code>への参照となる引数<code>first</code>のある関数があるとしましょう。この関数にはさらに、<code>'a</code>のライフタイム付きの<code>i32</code>への別の参照となる<code>second</code>という別の引数もあります。ライフタイム注釈は、<code>first</code>と<code>second</code>の参照がどちらもジェネリックなライフタイムと同じだけ生きることを示唆します。</p>
<a class="header" href="#a関数シグニチャにおけるライフタイム注釈" id="a関数シグニチャにおけるライフタイム注釈"><h3>関数シグニチャにおけるライフタイム注釈</h3></a>
<p>次に、<code>longest</code>関数の文脈でライフタイム注釈を調べてみましょう。ジェネリック型引数の場合と同様に、関数名と引数リストの間に山括弧で囲んだジェネリックなライフタイム引数を宣言する必要があります。このシグニチャで表現したい制約は、引数内のすべての参照と戻り値のライフタイムが同じでなければならないということです。リスト10-22に示すように、ライフタイムを <code>'a</code>という名前にして、それを各参照に追加します。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト10-22: シグニチャの全参照が同じライフタイム<code>'a</code>になると指定した<code>longest</code>関数の定義</p>
<p></span></p>
<p>このコードはコンパイルでき、リスト10-20の<code>main</code>関数とともに使用したら、欲しい結果になるはずです。</p>
<p>関数シグニチャは、なんらかのライフタイム<code>'a</code>に対して、関数は2つの引数を取り、どちらも少なくともライフタイム<code>'a</code>と同じだけ生きる文字列スライスであるとコンパイラに教えています。また、この関数シグニチャは、関数から返る文字列スライスも少なくともライフタイム<code>'a</code>と同じだけ生きると、コンパイラに教えています。これらの制約は、コンパイラに強制してほしいものです。この関数シグニチャでライフタイム引数を指定する時、渡されたり、返したりしたいかなる値のライフタイムも変更していないことを思い出してください。むしろ、借用精査機は、これらの制約を支持しない値全てを拒否するべきと指定しています。 <code>longest</code>関数は、正確に<code>x</code>と<code>y</code>の生存期間を知る必要はなく、何かのスコープが<code>'a</code>に代替され、 このシグニチャを満足することだけ知っている必要があることに注意してください。</p>
<p>関数のライフタイム注釈を付けるとき、注釈は関数の本体ではなく関数のシグニチャに入ります。Rustは、何の助けもなしに関数内のコードを分析することができます。しかし、ある関数がその関数の外にあるコードを参照したり、その関数の外にあるコードから参照を受け取ったりすると、Rustは引数のライフタイムや独自の戻り値を把握することがほとんど不可能になります。機能が呼び出されるたびにライフタイムが異なる場合があります。このため、ライフタイムに手動で注釈を付ける必要があります。</p>
<p>具体的な参照を<code>longest</code>に渡すと、<code>'a</code>に置き換えられる具体的なライフタイムは、<code>y</code>のスコープと被さる<code>x</code>のスコープの一部になります。言い換えると、ジェネリックなライフタイム<code>'a</code>は、<code>x</code>と<code>y</code>のライフタイムのうち、小さい方に等しい具体的なライフタイムになるのです。返却される参照を同じライフタイム引数<code>'a</code>で注釈したので、返却される参照も<code>x</code>か<code>y</code>のライフタイムの小さい方と同じだけ有効になるでしょう。</p>
<p>ライフタイム注釈がどのようにして具体的なライフタイムになる参照を渡すことで<code>longest</code>関数を制限する方法を見ましょう。リスト10-23は簡単な例です。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p><span class="caption">リスト 10-23: 異なる具体的なライフタイムの<code>String</code>値への参照で<code>longest</code>関数を使用する</span></p>
<p>この例では <code>string1</code>は外側スコープの終わりまで有効です。<code>string2</code>は内側スコープの終わりまで有効で、<code>result</code>は内側スコープの終わりまで有効なものを参照します。このコードを実行すると、借用精査機がこのコードを承認していることがわかります。コンパイルして実行すると<code>The longest string is long string is long</code>を出力します。</p>
<p>次に、<code>result</code>の参照のライフタイムが2つの引数のうちのより短いライフタイムでなければならないことを示す例を試してみましょう。<code>result</code>変数の宣言を内部スコープの外側に移動しますが、<code>string2</code>スコープ内の<code>result</code>変数にその値を代入します。 次に、内部スコープが終了した後、<code>scope</code>の外側に<code>result</code>を使用する<code>println!</code>を移動します。リスト10-24のコードはコンパイルされません。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">リスト 10-24: <code>string2</code>がスコープを抜けてから<code>result</code>を使用しようとする</span></p>
<p>このコードをコンパイルしようとすると、次のエラーが表示されます。</p>
<pre><code class="language-text">error[E0597]: `string2` does not live long enough
  --&gt; src/main.rs:15:5
   |
14 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
15 |     }
   |     ^ `string2` dropped here while still borrowed
16 |     println!(&quot;The longest string is {}&quot;, result);
17 | }
   | - borrowed value needs to live until here
</code></pre>
<p>このエラーは、<code>result</code>が<code>println!</code>文に対して有効になるために、<code>string2</code>が外側のスコープの終わりまで有効である必要があることを示しています。関数引数と戻り値のライフタイムを同じライフタイム引数<code>'a</code>で注釈したので、コンパイラはこのことを知っています。</p>
<p>人間からしたら、このコードを見て<code>string1</code>は<code>string</code>2よりも長いことが確認でき、そのため<code>result</code>は<code>string1</code>への参照を含んでいます。<code>string1</code>はまだスコープから外れていないので、<code>string1</code>への参照は<code>println!</code>ステートメントでも有効です。
しかし、コンパイラはこの場合参照が有効であることを認識できません。<code>longest</code>関数が返す参照の有効期間は、渡された参照の有効期間のうちの小さいものと同じであることをRustに告げました。したがって、借用精査機はリスト10-24のコードを無効な参照がある可能性があるとして許可しないのです。</p>
<p>試しに値や<code>longest</code>関数に渡される参照のライフタイムや返される参照の使用法が異なる実験をもっと企ててみてください。自分の実験がコンパイル前に借用精査機を通るかどうか仮説を立てて、それが正しいか確認してみてください。</p>
<a class="header" href="#aライフタイムの観点で思考する" id="aライフタイムの観点で思考する"><h3>ライフタイムの観点で思考する</h3></a>
<p>ライフタイム引数を指定する必要がある方法は、関数が何をしているかによって異なります。たとえば、最長の文字列スライスではなく最初の引数を常に返すように<code>longest</code>関数の実装を変更した場合、<code>y</code>引数で有効期間を指定する必要はないため、以下のコードがコンパイルされます。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>この例では、引数<code>x</code>と戻り値の型に対して<code>'a</code>というライフタイム引数を指定しましたが、引数<code>y</code>には指定していません。<code>y</code>のライフタイムは<code>x</code>や戻り値のライフタイムとは何の関係もないからです。</p>
<p>関数から参照を返す際、戻り値型のライフタイム引数は、引数のうちどれかのライフタイム引数と一致する必要があります。返される参照が引数のどれかを参照してい<em>なければ</em>、この関数内で生成された値を参照しているに違いなく、その値が関数の末端でスコープを抜けるので、ダングリング参照になるでしょう。コンパイルできないこの<code>longest</code>関数の試行された実装を考えてみましょう。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>ここでは、戻り値の型としてライフタイム引数<code>'a</code>を指定していますが、戻り値の有効期間が引数のライフタイムにまったく関係しないため、この実装はコンパイルに失敗します。以下のようなエラーメッセージを受け取ります。</p>
<pre><code class="language-text">error[E0597]: `result` does not live long enough
 --&gt; src/main.rs:3:5
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the
function body at 1:1...
 --&gt; src/main.rs:1:1
  |
1 | / fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
2 | |     let result = String::from(&quot;really long string&quot;);
3 | |     result.as_str()
4 | | }
  | |_^
</code></pre>
<p>問題は<code>result</code>が範囲外になり、<code>longest</code>関数の最後でクリーンアップされるということです。また、関数から<code>result</code>を返そうともしています。ダングリング参照を変えるであろうライフタイム引数を指定する手段はなく、コンパイラは、ダングリング参照を生成させてくれません。今回の場合、最善の修正案は、呼び出し元の関数が値のクリーンアップに責任を持てるよう、参照ではなく所有されたデータ型を返すことでしょう。</p>
<p>最終的に、ライフタイム構文は、さまざまな引数のライフタイムと関数の戻り値を結びつけることです。それらが接続されると、Rustはメモリセーフな操作を許可し、ダングリングポインタを作成したり、メモリの安全性に違反する操作を禁止するのに十分な情報を持っています。</p>
<a class="header" href="#a構造体定義のライフタイム注釈" id="a構造体定義のライフタイム注釈"><h3>構造体定義のライフタイム注釈</h3></a>
<p>これまでは、所有している型を保持する構造体しか定義していませんでした。構造体が参照を保持することは可能ですが、その場合は構造体の定義内のすべての参照に生涯の注釈を追加する必要があります。リスト10-25には、文字列スライスを保持する <code>ImportantExcerpt</code>という名前の構造体があります。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };
}
</code></pre></pre>
<p><span class="caption">リスト 10-25: 参照を含む構造体なので、定義にライフタイム注釈が必要</span></p>
<p>この構造体には参照用の文字列スライスを保持する1つのフィールド<code>part</code>があります。一般的なデータ型と同様に、構造体の名前の後ろに山形括弧の中にある一般的なライフタイム引数の名前を宣言して、構造体定義の本体でライフタイム引数を使用することができます。この注釈は、<code>ImportantExcerpt</code>のインスタンスが<code>part</code>フィールドに保持している参照を残存させることができないことを意味します。</p>
<p><code>main</code>関数は変数<code>novel</code>が所有する<code>String</code>の最初の文に対する参照を保持する<code>ImportantExcerpt</code>構造体のインスタンスを生成します。<code>novel</code>のデータは<code>ImportantExcerpt</code>インスタンスが作成される前に存在します。さらに、<code>novel</code>は<code>ImportantExcerpt</code>が範囲外になるまで範囲外に出ないので、<code>ImportantExcerpt</code>インスタンスの参照は有効です。</p>
<a class="header" href="#aライフタイム省略" id="aライフタイム省略"><h3>ライフタイム省略</h3></a>
<p>すべてのリファレンスにはライフタイムがあり、参照を使用する関数や構造体にはライフタイム引数を指定する必要があることがわかりました。しかし、第4章ではリスト4-9の関数がありました。これはリスト10-26にもあり、ライフタイム注釈なしでコンパイルされています。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p><span class="caption">リスト 10-26: 引数と戻り値型が参照であるにも関わらず、ライフタイム注釈なしでコンパイルできた リスト4-9で定義した関数</span></p>
<p>この関数がライフタイム注釈なしでコンパイルできた理由は、歴史的なものです。昔のバージョンのRust(1.0以前)では、全参照に明示的なライフタイムが必要だったので、このコードはコンパイルできませんでした。その頃、関数シグニチャはこのように記述されていたのです。</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>多くのRustコードを書いた後、Rustチームは、Rustプログラマが特定の場面では、何度も何度も同じライフタイム注釈に入ることを発見しました。これらの場面は予測可能で、いくつかの決定的なパターンに従っていました。開発者はこのパターンをコンパイラのコードに落とし込んだので、このような場面には借用精査機がライフタイムを推論できるようになり、明示的な注釈を必要としなくなったのです。</p>
<p>他の決定的なパターンが出現し、コンパイラに追加されることもあり得るので、このRustの歴史は関係があります。将来的に、さらに少数のライフタイム注釈しか必要にならない可能性もあります。</p>
<p>コンパイラの参照解析に落とし込まれたパターンは、<em>ライフタイム省略規則</em>と呼ばれます。これらはプログラマが従う規則ではありません。コンパイラが考慮する一連の特定のケースであり、 自分のコードがこのケースに当てはまれば、ライフタイムを明示的に書く必要はなくなります。</p>
<p><em>省略規則</em>は、完全な推論を提供しません。コンパイラが決定的に規則を適用できるけれども、参照がなるライフタイムに関してそれでも曖昧性があるなら、コンパイラは、残りの参照がなるべきライフタイムを推論しません。この場合、推論ではなく、コンパイラは、参照がお互いにどう関係するかを指定するライフタイム注釈を追記することで、解決できるエラーを与えます。</p>
<p>関数またはメソッドの引数の寿命は<em>入力ライフタイム</em>と呼ばれ、戻り値の寿命は<em>出力ライフタイム</em>と呼ばれます。</p>
<p>コンパイラは、3つのルールを使用して、明示的な注釈がない場合に参照されるライフタイムを把握します。第1のルールは入力ライフタイムに適用され、第2および第3のルールは出力ライフタイムに適用されます。コンパイラが3つのルールの終わりに達し、まだライフタイムがわからない参照がある場合、コンパイラはエラーで停止します。</p>
<p>これらの規則は、<code>fn</code>定義と<code>impl</code>ブロックに適用されます。</p>
<p>最初の規則は、参照である各引数は、独自のライフタイム引数を得るというものです。換言すれば、1引数の関数は、1つのライフタイム引数を得るということです（<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>）。また、2つ引数のある関数は、2つの個別のライフタイム引数を得ます（<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>）。以下も同様です。</p>
<p>2番目の規則は、1つだけ入力ライフタイム引数があるなら、そのライフタイムが全ての出力ライフタイム引数に代入されるというものです（<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>）。</p>
<p>3番目の規則は、複数の入力ライフタイム引数があるけれども、メソッドなのでそのうちの一つが<code>&amp;self</code>や<code>&amp;mut self</code>だった場合、<code>self</code>のライフタイムが全出力ライフタイム引数に代入されるというものです。この3番目の規則により、必要なシンボルの数が減るので、メソッドが遥かに読み書きしやすくなります。</p>
<p>コンパイラになってみましょう。これらの規則を適用して、リスト10-26の<code>first_word</code>関数のシグニチャの参照のライフタイムが何か計算します。シグニチャは、参照に紐付けられるライフタイムがない状態から始まります。</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>コンパイラは最初のルールを適用します。このルールは、各引数が独自のライフタイムを取得するように指定します。それを通常通り<code>'a</code>と呼ぶので、シグニチャはこれです。</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>1つだけ入力ライフタイムがあるので、2番目の規則を適用します。2番目の規則は、1つの入力引数のライフタイムが、出力引数に代入されると指定するので、シグニチャはこうなります。</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>もうこの関数シグニチャの全ての参照にライフタイムが付いたので、コンパイラは、プログラマにこの関数シグニチャのライフタムを注釈してもらう必要なく、解析を続行できます。</p>
<p>別の例を見てみましょう。リスト10-21で作業を開始したときにライフタイム引数を持たない<code>longest</code>関数を使用します。</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>最初のルールを適用してみましょう。各引数は独自のライフタイムを取得します。今回は、1つではなく2つの引数があるため、2つのライフタイムがあります。</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>2つ以上入力ライフタイムがあるので、2番目の規則は適用されないとわかります。また3番目の規則も適用されません。<code>longest</code>はメソッドではなく関数なので、どの引数も<code>self</code>ではないからです。3つのルールをすべて実行した後も、戻り値の型のライフタイムはまだわかりません。このため、リスト10-21のコードをコンパイルしようとしたときにエラーが発生しました。コンパイラはライフタイムの省略規則を処理しましたが、シグニチャ内の参照のライフタイムをすべて把握できませんでした。</p>
<p>3番目の規則は実際メソッドシグニチャでしか適用されないので、次にその文脈でライフタイムを観察し、3番目の規則が、メソッドシグニチャであまり頻繁にライフタイムを注釈しなくても済むことを意味する理由を確認します。</p>
<a class="header" href="#aメソッド定義におけるライフタイム注釈" id="aメソッド定義におけるライフタイム注釈"><h3>メソッド定義におけるライフタイム注釈</h3></a>
<p>構造体にライフタイムのあるメソッドを実装する際、リスト10-11に示すジェネリック型の引数と同じ構文を使用します。 ライフタイム引数を宣言して使用する場所は、構造体フィールド、メソッドの引数、および戻り値に関連しているかどうかによって異なります。</p>
<p>構造体フィールドのライフタイム名前は、<code>impl</code>キーワードの後に宣言し、構造体の型の一部であるため、構造体の名前の後に使用する必要があります。</p>
<p><code>impl</code>ブロック内のメソッドシグニチャでは、参照は構造体のフィールド内の参照のライフタイムに縛られるか、独立している可能性があります。さらに、ライフタイム省略規則では、ライフタイム注釈がメソッドシグニチャに必要ないようにすることがよくあります。リスト10-25で定義した<code>ImportantExcerpt</code>という名前の構造体を使ったいくつかの例を見てみましょう。</p>
<p>まず、<code>level</code>という名前のメソッドを使います。このメソッドは<code>self</code>への参照であり、戻り値は<code>i32</code>です。これは何も参照していません。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<p><code>impl</code>の後のライフタイム引数宣言と型名の後に使用する必要がありますが、最初の省略規則のために<code>self</code>への参照のライフタイムに注釈を付ける必要はありません。</p>
<p>3番目のライフタイム省略規則が適用される例を次に示します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
#}</code></pre></pre>
<p>2つ入力ライフタイムがあるので、コンパイラは最初のライフタイム省略規則を適用し、<code>&amp;self</code>と<code>announcement</code>に独自のライフタイムを与えます。それから、引数の1つが<code>&amp;self</code>なので、戻り値型は<code>&amp;self</code>のライフタイムを得て、全てのライフタイムが説明されました。</p>
<a class="header" href="#a静的ライフタイム" id="a静的ライフタイム"><h3>静的ライフタイム</h3></a>
<p>議論する必要のある1種の特殊なライフタイムが、<code>'static</code>であり、これはプログラム全体の期間を示します。文字列リテラルは全て<code>'static</code>ライフタイムになり、次のように注釈できます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
#}</code></pre></pre>
<p>この文字列のテキストは、プログラムのバイナリに直接格納され、常に利用可能です。そのため、全文字列リテラルのライフタイムは、<code>'static</code>なのです。</p>
<p>エラーメッセージで<code>'static</code>ライフタイムを使用することを勧められることがある可能性があります。ですが、参照に対してライフタイムとして<code>'static</code>を指定する前に、今ある参照が本当にプログラムの全期間生きるかどうか考えてください。可能であっても、参照がそれだけの期間生きるかどうか考慮する可能性があります。ほとんどの場合、問題は、ダングリング参照を生成しようとしているか、利用可能なライフタイムの不一致が原因です。そのような場合、解決策はその問題を修正することであり、<code>'static</code>ライフタイムを指定することではありません。</p>
<a class="header" href="#aジェネリックな型引数トレイト境界ライフタイムを一度に" id="aジェネリックな型引数トレイト境界ライフタイムを一度に"><h2>ジェネリックな型引数、トレイト境界、ライフタイムを一度に</h2></a>
<p>ジェネリック型引数、トレイト境界、およびすべての関数を1つの関数で指定する構文を簡単に見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>リスト10-22からの2つの文字列のうち長い方を返す<code>longest</code>関数ですが、ジェネリック型<code>T</code>の<code>ann</code>という追加の引数があり、これは<code>where</code>句で指定されているように、<code>Display</code>トレイトを実装するあらゆる型で埋めることができます。この追加の引数は、関数が文字列スライスの長さを比較する前に出力されるので、<code>Display</code>トレイト境界が必要なのです。ライフタイムは1種のジェネリックなので、ライフタイム引数<code>'a</code>とジェネリックな型引数<code>T</code>が関数名の後、山カッコ内の同じリストに収まっています。</p>
<a class="header" href="#aまとめ-9" id="aまとめ-9"><h2>まとめ</h2></a>
<p>この章で多くをカバーしました。ジェネリック型引数、トレイトとトレイト境界、およびジェネリックなライフタイム引数について知ったので、多くの異なる状況で動作する繰り返しなしでコードを書く準備が整いました。ジェネリック型の引数を使用すると、さまざまな型にコードを適用できます。トレイトとトレイト境界は、ジェネリックな型であっても、コードが必要とする動作を保証します。ライフタイム注釈を使用する方法を学び、この柔軟なコードにダングリング参照がないようにしました。この分析はすべてコンパイル時に実行されますが、実行時のパフォーマンスには影響しません。</p>
<p>信じるかどうかは自由ですが、この章で議論した話題にはもっともっと学ぶべきことがあります。第17章ではトレイトオブジェクトを議論し、これはトレイトを使用する別の手段です。第19章では、ライフタイム注釈が関わるもっと複雑な筋書きと何か高度な型システムの機能を講義します。次は、Rustでテストを書く方法を学ぶので、コードがあるべき通りに動いていることを確かめられます。</p>
<a class="header" href="#a自動テストを書く" id="a自動テストを書く"><h1>自動テストを書く</h1></a>
<p>1972年のエッセイ「謙虚なプログラマ」でエドガー・W・ダイクストラは以下のように述べています。「プログラムのテストは、バグの存在を示すには非常に効率的な手法であるが、バグの不在を示すには望み薄く不適切である」と。これは、できるだけテストを試みるべきではないということではありません。</p>
<p>プログラムの正しさは、コードが意図していることをどの程度行っているかです。Rustはプログラムの正当性に重きを置いて設計されていますが、正当性は複雑で、単純に証明することはありません。Rustの型システムはこの負担の大きな部分を負っていますが、型システムはあらゆる種類の誤りをキャッチできません。そのため、Rustには言語内での自動ソフトウェアテストの作成がサポートされています。</p>
<p>例として、<code>add_two</code>という関数を書いて、渡される数値に2を加えたとします。この関数のシグニチャは、パラメータとして整数を受け取り、結果として整数を返します。この関数を実装してコンパイルするとき、Rustはこれまでに学んだすべての型チェックと借用チェックを行い、たとえば、<code>String</code>の値や無効な参照をこの関数に渡していないかなどを確かめます。ところが、コンパイラはプログラマがまさしく意図したことを関数が実行しているかどうかは確かめられません。つまり、引数に10を足したり、50を引いたりするのではなく、引数に2を足していることです。このような時にテストは必要になります。</p>
<p>たとえば、<code>add_two</code>関数に<code>3</code>を渡すと返される値は<code>5</code>であるというテストを書くことができます。ードを変更するたびにこれらのテストを実行することで、既存の正しい動作が変更されていないことを確認できます。</p>
<p>テストは複雑なスキルです。よいテストの書き方をあらゆる方面から解説することは1章だけではできませんが、Rustのテスト機能のメカニズムについて議論します。テストの作成時に使用できるアノテーションやマクロ、テストの実行に必要なデフォルトの動作とオプション、単体テストと統合テストへのテストの構成方法について説明します。</p>
<a class="header" href="#aテストの記述法" id="aテストの記述法"><h2>テストの記述法</h2></a>
<p>テストは、非テストコードが期待どおりに機能していることを検証するRust関数です。テスト関数の本体は、通常次の3つのアクションを実行します。</p>
<ol>
<li>必要なデータや状態をセットアップする</li>
<li>テスト対象のコードを実行する</li>
<li>結果が想定通りかアサーションする</li>
</ol>
<p>Rustが特にこれらの動作を行うテストを書くために用意している機能を見ていきましょう。これには、<code>test</code>属性、いくつかのマクロ、<code>should_panic</code>属性が含まれます。</p>
<a class="header" href="#aテスト関数の解剖" id="aテスト関数の解剖"><h3>テスト関数の解剖</h3></a>
<p>最も簡単な方法では、Rustでのテストは<code>test</code>属性で注釈された関数です。属性はRustコードに関するメタデータです。1つの例は、第5章で構造体で使用した<code>derive</code>属性です。関数をテスト関数に変更するには、<code>fn</code>の前の行に<code>＃[test]</code>を追加します。<code>cargo test</code>コマンドでテストを実行すると、Rustは<code>test</code>属性でアノテーションされた関数を実行し、各テスト関数が成功するか失敗するかを報告するテスト用バイナリを作成します。</p>
<p>Cargoで新しいライブラリプロジェクトを作成すると、テスト機能付きのテストモジュールが自動的に生成されます。このモジュールはテストの作成を開始するのに役立ちますので、新しいプロジェクトを開始するたびにテスト関数の構造と構文を正確に調べる必要はありません。必要なだけ多くのテスト機能とテストモジュールを追加することができます。</p>
<p>実際にコードをテストすることなく、私たちのために生成されたテンプレートテストを試すことで、テストの仕組みのいくつかの側面を探求します。次に、私たちが書いたコードを呼び出し、その動作が正しいことを主張する実際のテストを書きます。</p>
<p><code>adder</code>という新しいライブラリプロジェクトを作成しましょう。</p>
<pre><code class="language-text">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p><code>adder</code>ライブラリの<em>src/lib.rs</em>ファイルの内容はリスト11-1のようになります。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre></pre>
<p><span class="caption">リスト 11-1: <code>cargo new</code>で自動生成されたテストモジュールと関数</span></p>
<p>今のところ、上の2行を無視して、関数にどのように作用するかを見てみましょう。<code>fn</code>行の前の<code>#[test]</code>注釈に注意してください。この属性はこれがテスト関数であることを示しているので、テストランナーはこの関数をテストとして扱うことを知っています。また、<code>tests</code>モジュールに非テスト関数を組み込んで、共通のシナリオを設定したり、一般的な操作を行うこともできます。したがって、<code>#[test]</code>属性を使ってどの関数がテストであるかを示す必要があります。</p>
<p>関数本体は <code>assert_eq!</code>マクロを使用して、2 + 2が4に等しいことを宣言します。このアサーションは、典型的なテストの形式の例として役立ちます。このテストが合格することを確認するために実行してみましょう。</p>
<p><code>cargo test</code>コマンドは、リスト11-2に示すように、プロジェクト内のすべてのテストを実行します。</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><span class="caption">リスト 11-2: 自動生成されたテストを走らせた出力</span></p>
<p>Cargoはコンパイルされ、テストが実行されました。<code>Compiling</code>、<code>Finished</code>、<code>Running</code>行の後に<code>running 1 test</code>という行があります。次の行には、生成されたテスト関数の名前、<code>it_works</code>とそのテストを実行した結果<code>ok</code>が表示されます。次に、テストの実行の概要が表示されます。<code>test result：ok.</code>というテキストは、すべてのテストが成功したことを意味します。 <code>0 failed</code>は合格または不合格のテストの数を合計します。</p>
<p>無視されたテストはありませんので、サマリーには<code>0 ignored</code>と表示されます。また、実行されているテストをフィルタリングしていないため、サマリーの最後に<code>0 filtered out</code>と表示されます。テストの無視と除外については、次のセクション「テストの実行され方を制御する」で説明します。</p>
<p><code>0 measured</code>という統計は、性能を測定するベンチマーク試験のためのものである。ベンチマークテストは、この記事の執筆時点でNightlyのRustだけで利用可能です。詳細は<a href="../unstable-book/library-features/test.html">ベンチマークテストのドキュメンテーション</a>を参照してください。</p>
<p><code>Doc-tests adder</code>で始まるテスト出力の次の部分は、ドキュメンテーションテストの結果です。まだドキュメントテストはありませんが、RustはAPIドキュメントに記載されているコード例をコンパイルできます。この機能は、ドキュメントとコードを同期させるのに役立ちます。第14章の「テストとしてのドキュメンテーションコメント」セクションでドキュメンテーション・テストを書く方法について説明します。今は<code>Doc-tests</code>の出力を無視します。</p>
<p>テストの名前を変更してテスト出力をどのように変更するかを見てみましょう。<code>it_works</code>関数を<code>exploration</code>のような別の名前に変更してください。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre></pre>
<p>その後、再度<code>cargo test</code>を実行します。出力に<code>it_works</code>の代わりに<code>exploration</code>が表示されます。</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>別のテストを追加しましょう。今回は失敗したテストを行います。テスト機能で何かがパニックすると、テストは失敗します。各テストは新しいスレッドで実行され、メインスレッドがテストスレッドが終了したことがわかると、テストは失敗とマークされます。第9章でパニックを引き起こす最も簡単な方法について話しました。これは<code>panic!</code>マクロを呼び出すことです。<em>src/lib.rs</em>ファイルがリスト11-3のようになるよう、新しいテストanotherを入力してください。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust panics"># fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">リスト 11-3: <code>panic!</code>マクロを呼び出したために失敗する2番目のテストを追加する</span></p>
<p><code>cargo test</code>を使ってテストを再実行してください。出力はリスト11-4のようになります。これは、<code>exploration</code>テストが成功し、<code>another</code>が失敗したことを示しています。</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed
</code></pre>
<p><span class="caption">リスト 11-4: 1つのテストが通り、失敗するときのテスト結果</span></p>
<p><code>ok</code>の代わりに、<code>test tests::another</code>行は<code>FAILED</code>を表示します。2つの新しいセクションが個々の結果とサマリーの間に表示されます。最初のセクションには、それぞれのテストの失敗の詳細な理由が表示されます。この場合、<code>another</code>は<em>src/lib.rs</em>ファイルの10行目で<code>Make this test fail</code>というパニックになりました。次のセクションでは、失敗したすべてのテストの名前だけを示します。これは、たくさんのテストがあり、多くの詳細な失敗したテスト出力がある場合に便利です。失敗したテストの名前を使用して、そのテストだけを実行してより簡単にデバッグすることができます。テストを実行する方法の詳細については、「テストの実行され方を制御する」のセクションで説明します。</p>
<p>サマリー行が最後に表示されます。全体的に、テスト結果はFAILEDです。1回のテストパスと1回のテストが失敗しました。</p>
<p>さまざまなシナリオでテスト結果がどのように見えるかを見てきたので、テストで有用な<code>panic!</code>以外のマクロを見てみましょう。</p>
<a class="header" href="#assertマクロで結果を確認する" id="assertマクロで結果を確認する"><h3><code>assert!</code>マクロで結果を確認する</h3></a>
<p>標準ライブラリによって提供される<code>assert!</code>マクロは、テスト中のある条件が<code>true</code>と評価されるようにしたいときに便利です。<code>assert!</code>マクロには、ブール値に評価される引数を与えます。値が<code>true</code>の場合、<code>assert!</code>は何もせず、テストに合格します。 値が <code>false</code>の場合、<code>assert！</code>マクロは<code>panic！</code>マクロを呼び出し、テストを失敗させます。 <code>assert！</code>マクロを使うと、私たちのコードが意図した通りに機能していることを確認するのに役立ちます。</p>
<p>第5章のリスト5-15では、リスト11-5で繰り返される<code>Rectangle</code>構造体と<code>can_hold</code>メソッドを使用しました。このコードを<em>src/lib.rs</em>ファイルに置き、<code>assert!</code>マクロを使っていくつかのテストを書きましょう。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
</code></pre></pre>
<p><span class="caption">リスト 11-5: 第5章から<code>Rectangle</code>構造体とその<code>can_hold</code>メソッドを使用する</span></p>
<p><code>can_hold</code>メソッドは論理値を返すので、<code>assert!</code>マクロの完璧なユースケースになるわけです。リスト11-6で、長さが8、幅が7の<code>Rectangle</code>インスタンスを生成し、これが長さ5、幅1の別の<code>Rectangle</code>インスタンスを保持できるとアサーションすることでcan_holdを用いるテストを書きます。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre></pre>
<p><span class="caption">リスト 11-6:より大きな四角形がより小さな四角形を確かに保持できるかを確認するcan_hold用のテスト</span></p>
<p><code>tests</code>モジュールの中に新しい行を追加しました。<code>use super::*;</code>です。<code>tests</code>モジュールは、第7章の「プライバシー規則」で説明した通常の公開ルールに従う普通のモジュールです。<code>tests</code>モジュールは内部モジュールなので、外部モジュールのテスト対象コードを内部モジュールのスコープに持っていく必要があります。ここではglobを使用しているので、外部モジュールで定義するものはすべてこの<code>tests</code>モジュールで使用できます。</p>
<p>テストに<code>large_can_hold_smaller</code>という名前をつけて、必要な二つの<code>Rectangle</code>インスタンスを作成しました。それから<code>assert!</code>マクロを呼び出し、<code>greater.can_hold(&amp;smaller)</code>を呼び出した結果を渡しました。この式は<code>true</code>を返すと想定されているので、テストは成功するはずです。確認してみましょう。</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>このテストは合格します。別のテストを追加してみましょう。今回は、小さい四角形は、より大きな四角形を保持できないことをアサーションします。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre></pre>
<p>この場合の<code>can_hold</code>関数の正しい結果は<code>false</code>なので、<code>assert!</code>マクロに渡す前に否定する必要があります。その結果、<code>can_hold</code>が<code>false</code>を返した場合、テストは成功します。</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>2つのテストが合格しました。次に、コードにバグを導入したときに、テスト結果に何が起こるかを見てみましょう。大文字と小文字を長さを比較する際に小文字の記号に置き換えて、<code>can_hold</code>メソッドの実装を変更しましょう。</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"># fn main() {}
# #[derive(Debug)]
# pub struct Rectangle {
#     length: u32,
#     width: u32,
# }
// --snip--

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
</code></pre></pre>
<p>テストを実行すると、以下が生成されます。</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>このテストではバグが見つかりました。<code>greater.length</code>が8で<code>smaller.length</code>が5であるため、<code>can_hold</code>の長さの比較は<code>false</code>を返します。8は5以上だからです。</p>
<a class="header" href="#assert_eqとassert_neマクロで等値性をテストする" id="assert_eqとassert_neマクロで等値性をテストする"><h3><code>assert_eq!</code>と<code>assert_ne!</code>マクロで等値性をテストする</h3></a>
<p>機能をテストする一般的な方法は、テスト中のコードの結果と、コードが一致することを期待する値とを比較することです。これを行うには、<code>assert!</code>マクロを使い、<code>==</code>演算子を使って式を渡します。しかし、これは、標準ライブラリが<code>assert_eq!</code>と<code>assert_ne!</code>マクロのペアを提供し、このテストをより便利に行うような共通のテストです。これらのマクロは、それぞれ等式または不等式の2つの引数を比較します。アサーションに失敗した場合は、2つの値も出力されます。なぜなら、<em>なぜ</em>テストが失敗したかを簡単に見ることができるからです。逆に<code>assert!</code>マクロは、<code>==</code>式の値がfalse値になったことしか示唆せず、<code>false</code>値に導いた値は出力しません。</p>
<p>リスト11-7では、<code>add_two</code>という名前の関数を作成し、その引数に<code>2</code>を加えて結果を返します。次に、この関数を<code>assert_eq!</code>マクロを使ってテストします。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre></pre>
<p><span class="caption">リスト 11-7: <code>assert_eq!</code>マクロで<code>add_two</code>関数をテストする</span></p>
<p>テストが通ることを確認しましょう。</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>assert_eq!</code>マクロに与えた最初の引数<code>4</code>は、<code>add_two(2)</code>を呼び出した結果と同じです。このテストの行は<code>test tests::it_adds_two ... ok</code>であり、<code>ok</code>テキストはテストが成功したことを示します。</p>
<p><code>assert_eq!</code>を使ったテストが失敗したときの様子を見てみましょう。<code>add_two</code>関数の実装を変更して、代わりに<code>3</code>を追加してください。</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"># fn main() {}
pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
</code></pre></pre>
<p>テストをもう一度実行します。</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
        thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>テストではバグが見つかりました。<code>it_adds_two</code>のテストは失敗し、<code>assertion failed: '(left == right)'</code>というメッセージを表示し、<code>left</code>は<code>4</code>で、<code>right</code>は<code>5</code>だったと示しています。このメッセージは有用で、デバッグを開始する助けになります。 <code>assert_eq!</code>の<code>left</code>引数は<code>4</code>だったが、<code>add_two(2)</code>がある<code>right</code>引数は<code>5</code>だったことを意味しています。</p>
<p>いくつかの言語やテストフレームワークでは、2つの値が同じであることを宣言する関数のパラメータを<code>expected</code>と<code>actual</code>と呼び、引数を指定する順序が重要であることに注意してください。しかし、Rustでは、それらは<code>left</code>と<code>right</code>と呼び、期待する値とテスト対象コードが生成する値を指定する順序は関係ありません。このテストでアサーションを<code>assert_eq!(add_two(2), 4)</code>と書くと、<code>assertion failed:'(left == right)'</code>と<code>left</code>が<code>5</code>で<code>right</code>が<code>4</code>と表示されるわけです。</p>
<p><code>assert_ne!</code>マクロは、与えられた2つの値が等しくない場合に合格し、等しい場合に失敗します。このマクロは、価値が何になるかがわからない場合に最も役立ちますが、コードが意図したとおりに機能している場合には絶対に価値がないことを知ります。たとえば、何らかの方法で入力を変更することが保証されている関数をテストする場合、入力を変更する方法はテストを実行する曜日によって異なりますが、関数の出力が入力と等しくないことを示します。</p>
<p>表面上で、<code>assert_eq!</code>と<code>assert_ne!</code>マクロは<code>==</code>と<code>!=</code>の演算子をそれぞれ使います。アサーションが失敗すると、これらのマクロは引数を出力します。これは、比較される値が<code>PartialEq</code>と<code>Debug</code>トレイトを実装しなければならないことを意味します。すべてのプリミティブ型とほとんどの標準ライブラリ型は、これらのトレイトを実装しています。定義する構造体と列挙体の場合、それらの型の値が等しいかどうかを宣言するために<code>PartialEq</code>を実装する必要があります。アサーションが失敗したときに値を出力するには <code>Debug</code>を実装する必要があります。第5章のリスト5-12で述べたように、どちらのトレイトも継承可能トレイトなので、これは構造体または列挙型の定義に<code>#[derive(PartialEq, Debug)]</code>アノテーションを追加するのと同じくらい簡単です。これらおよび他の継承可能トレイトの詳細については、付録C「継承可能トレイト」を参照してください。</p>
<a class="header" href="#aカスタムの失敗メッセージを追加する" id="aカスタムの失敗メッセージを追加する"><h3>カスタムの失敗メッセージを追加する</h3></a>
<p>また、 <code>assert!</code>、<code>assert_eq!</code>、<code>assert_ne!</code>マクロにオプションの引数として失敗メッセージとともに出力されるカスタムメッセージを追加することもできます。<code>assert!</code>に対する必須の引数の1つまたは<code>assert_eq!</code>と<code>assert_ne!</code>の2つの必須の引数の後に指定された引数は<code>format!</code>マクロに渡され (format!マクロについては第8章の「<code>+</code>演算子または、<code>format!</code>マクロで連結する」節で議論しました)、 <code>{}</code>のプレースホルダと値を含む書式文字列を渡すことができます。カスタムメッセージは、アサーションが意味するものを明文化するのに便利です。テストが失敗した場合は、コードの問題の詳細を知ることができます。</p>
<p>たとえば、名前で人で挨拶する関数があり、関数に渡す名前が出力に現れることをテストしたいとしましょう。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
</code></pre></pre>
<p>このプログラムの必要事項はまだ合意が得られておらず、挨拶の先頭の<code>Hello</code>というテキストは変わるだろうということは確かです。要件が変わった時にテストを更新しなくてもよいようにしたいと決定したので、<code>greeting</code>関数から返る値と正確な等値性を確認するのではなく、出力が入力引数のテキストを含むことをアサーションするだけにします。</p>
<p><code>greeting</code>が<code>name</code>を含まないように変更して、このテストの失敗を見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"># fn main() {}
pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
</code></pre></pre>
<p>このテストを実行すると、以下が出力されます。</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'assertion failed:
result.contains(&quot;Carol&quot;)', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>この結果は、アサーションが失敗し、アサーションがどのラインにあるかを示します。この場合、より有用な失敗メッセージは、<code>greeting</code>関数から得た値を表示します。テスト関数を変更して、<code>greeting</code>関数から得た実際の値で埋められたプレースホルダを持つフォーマット文字列から作られたカスタムエラーメッセージを与えましょう。</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>テストを実行すると、より有益なエラーメッセージが表示されます。</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'Greeting did not
contain name, value was `Hello!`', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>実際にテスト結果に表示された値がわかります。これは、発生すると予想されるものではなく、発生したことをデバッグするのに役立ちます。</p>
<a class="header" href="#should_panicでパニックを確認する" id="should_panicでパニックを確認する"><h3><code>should_panic</code>でパニックを確認する</h3></a>
<p>コードが正しい値を返すことを確認することに加えて、コードが予期したとおりにエラー状態を処理することを確認することも重要です。たとえば、第9章のリスト9-10で作成した<code>Guess</code>型を考えてみましょう。<code>Guess</code>を使う他のコードは<code>Guess</code>インスタンスが1から100の間の値しか含まないという保証に依存します。その範囲外の値を持つ<code>Guess</code>インスタンスを作成しようとするテストを書くことができます。</p>
<p>これを行うには、もう一つの属性<code>should_panic</code>をテスト関数に追加します。この属性は、関数内のコードがパニックになった場合にテストに合格します。関数内のコードがパニックに陥らなければ、テストは失敗します。</p>
<p>リスト11-8は<code>Guess::new</code>のエラー状態が次のようになるのを期待していることをチェックするテストを示しています。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre></pre>
<p><span class="caption">リスト 11-8: 状況が<code>panic!</code>を引き起こすとテストする</span></p>
<p><code>#[should_panic]</code>属性は<code>#[test]</code>属性の後で、それが適用されるテスト関数の前に置かれます。このテストに合格したときの結果を見てみましょう。</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>では、値が100より大きい場合、<code>new</code>関数がパニックになるという条件を取り除いて、コードにバグを導入しましょう。</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"># fn main() {}
# pub struct Guess {
#     value: i32,
# }
#
// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
</code></pre></pre>
<p>リスト11-8のテストを実行すると失敗します。</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>この場合は非常に有用なメッセージはありませんが、テスト関数を見ると<code>#[should_panic]</code>と注釈されています。テスト機能のコードがパニックを引き起こさなかったことを意味します。</p>
<p><code>should_panic</code>を使ったテストは、コードがある程度のパニックを引き起こしたことだけを示しているので、不正確になる可能性があります。<code>should_panic</code>テストは、起こることを期待していたのとは異なる理由でパニックになっても、合格します。 <code>should_panic</code>テストをより正確にするために、<code>should_panic</code>属性に<code>expected</code>パラメータを追加することができます。テストハーネスは、失敗メッセージに指定されたテキストが含まれていることを確認します。 たとえば、リスト11-9の<code>Guess</code>の修正されたコードを考えてみましょう。ここで<code>new</code>関数は、値が小さすぎるか大きすぎるかによってメッセージが異なります。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
# pub struct Guess {
#     value: i32,
# }
#
// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre></pre>
<p><span class="caption">リスト 11-9: 状況が特定のパニックメッセージで<code>panic!</code>を引き起こすことをテストする</span></p>
<p><code>should_panic</code>属性の<code>expected</code>引数に置いた値が<code>Guess::new</code>関数がパニックしたメッセージの一部になっているので、 このテストは通ります。予想されるパニックメッセージ全体を指定することもでき、そうすれば今回の場合、<code>Guess value must be less than or equal to 100, got 200.</code>となります。<code>should_panic</code>の予想される引数に指定すると決めたものは、パニックメッセージの固有性や活動性、テストの正確性によります。今回の場合、パニックメッセージの一部でも、テスト関数内のコードが、<code>else if value &gt; 100</code>ケースを実行していると確認するのに事足りるのです。</p>
<p><code>expected</code>メッセージで<code>should_panic</code>テストが失敗したときに何が起こるかを知るために、<code>if value &lt; 1</code>と<code>else if value &gt; 100</code>ブロックの本体を入れ替えて、もう一度コードにバグを導入してみましょう。</p>
<pre><code class="language-rust ignore not_desired_behavior">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>今回は<code>should_panic</code>テストを実行すると失敗します。</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
        thread 'tests::greater_than_100' panicked at 'Guess value must be
greater than or equal to 1, got 200.', src/lib.rs:11:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>失敗メッセージは、このテストが期待通りにパニックになったことを示しますが、予想される文字列の<code>'Guess value must be less than or equal to 100'</code>を含んでいませんでした。この場合、私たちが得たパニックメッセージは、<code>Guess value must be greater than or equal to 1, got 200</code>となりました。そうしてバグの所在地を割り出し始めることができるわけです。</p>
<a class="header" href="#aテストで-resultt-eを使う" id="aテストで-resultt-eを使う"><h3>テストで <code>Result&lt;T, E&gt;</code>を使う</h3></a>
<p>これまでは、失敗したときにパニックするテストを書いてきました。<code>Result&lt;T, E&gt;</code>を使ったテストも書くことができます。最初の例がありますが、代わりに結果があります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
#}</code></pre></pre>
<p>ここでは、<code>it_works</code>関数を変更して結果を返します。また、<code>assert_eq!</code>ではなく、成功例の場合は<code>Ok(())</code>を、失敗の場合は<code>String</code>を内部に持つ<code>Err</code>を返します。これまでのように、このテストは失敗または成功しますが、パニックに基づくのではなく、<code>Result&lt;T, E&gt;</code>を使用してその決定を行います。このため、これらの関数の1つと<code>#[should_panic]</code>を使うことはできません。代わりに<code>Err</code>を返すべきです。</p>
<p>テストを書くためのいくつかの方法を知ったので、テストを実行し、<code>cargo test</code>で使用できるさまざまなオプションを調べるときに何が起きているのかを見てみましょう。</p>
<a class="header" href="#aテストの実行され方を制御する" id="aテストの実行され方を制御する"><h2>テストの実行され方を制御する</h2></a>
<p><code>cargo run</code>がコードをコンパイルしてバイナリを実行するのと同様に、<code>cargo test</code>はコードをテストモードでコンパイルし、結果のテストバイナリを実行します。コマンドラインオプションを指定して、<code>cargo test</code>のデフォルト動作を変更することができます。たとえば、<code>cargo test</code>によって生成されるバイナリのデフォルトの動作は、すべてのテストを並列に実行し、テスト実行中に生成された出力をキャプチャして出力が表示されルノを防ぎ、テスト結果に関連する出力を読みやすくすることです 。</p>
<p>いくつかのコマンドラインオプションは<code>cargo test</code>に行き、いくつかはテストバイナリに行きます。これらの2つのタイプの引数を分けるために、<code>cargo test</code>に続いてセパレータ<code>--</code>をつけた引数と、テストバイナリに行くものをリストします。 <code>cargo test --help</code>は<code>cargo test</code>で使うオプションを表示し、<code>cargo test --help</code>はセパレータ<code>--</code>の後に使うオプションを表示します。</p>
<a class="header" href="#aテストを並列または連続して実行する" id="aテストを並列または連続して実行する"><h3>テストを並列または連続して実行する</h3></a>
<p>複数のテストを実行すると、デフォルトではスレッドを使用して並列実行されます。これは、テストがより速く実行されることを意味し、コードが機能しているかどうかを迅速にフィードバックできます。テストは同時に実行されているので、現在の作業ディレクトリや環境変数などの共有環境を含め、テストがお互いに依存するか、共有状態に依存しないことを確認してください。</p>
<p>たとえば、それぞれのテストで、<em>test-output.txt</em>という名前のディスク上にファイルを作成し、そのファイルにデータを書き込むコードを実行するとします。各テストでは、そのファイルのデータが読み込まれ、ファイルにはテストごとに異なる特定の値が含まれていることが示されます。テストは同時に実行されるため、あるテストで別のテストがファイルを書き込んだり読み込んだりするまでにファイルを上書きすることがあります。2番目のテストは失敗します。これは、コードが正しくないためではなく、テストが並行して実行されている間に互いに干渉したためです。1つの解決策は、各テストが異なるファイルに書き込むことを確認することです。別の解決策は、一度に1つずつテストを実行することです。</p>
<p>テストを並行して実行したくない場合や、使用するスレッド数をより細かく制御したい場合は、<code>--test-threads</code>フラグと使用したいスレッド数をテストバイナリに送ることができます。次の例を見てください。</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<p>テストスレッドの数を<code>1</code>に設定し、プログラムに並列性を使用しないように指示します。1つのスレッドを使用してテストを実行すると、それらを並列に実行するより時間がかかりますが、テストが状態を共有する場合、テストは互いに干渉しません。</p>
<a class="header" href="#a関数の出力を表示する" id="a関数の出力を表示する"><h3>関数の出力を表示する</h3></a>
<p>デフォルトでは、テストに合格すると、Rustのテストライブラリは標準出力に出力されたものをすべて取得します。たとえば、テストで <code>println!</code>を呼び出してテストに合格すると、端末に<code>println!</code>という出力は表示されません。テストが成功したことを示す行だけが表示されます。テストが失敗した場合は、残りの失敗メッセージと共に標準出力に表示されたものがすべて表示されます。</p>
<p>たとえば、コードリスト11-10には、パラメータの値を出力して10を返すばかげた関数と、渡されたテストと失敗したテストがあります。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust panics">
# #![allow(unused_variables)]
#fn main() {
fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 11-10: <code>println!</code>を呼び出す関数用のテスト</span></p>
<p><code>cargo test</code>でこれらのテストを実行すると、次の出力が表示されます。</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
        I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>この出力のどこにも、私が値4を得ていることがわかります。これは、渡されたテストが実行されたときに表示されるものです。 その出力がキャプチャされました。失敗したテストからの出力である<code>I got the value 8</code>はテストサマリー出力エリアに出現し、ここには、テスト失敗の原因も表示されています。</p>
<p>テストを渡すための印刷された値も見たい場合は、<code>--nocapture</code>フラグを使って出力キャプチャの動作を無効にすることができます。</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<p>リスト11-10のテストを <code>--nocapture</code>フラグで再実行すると、次のような出力が表示されます。</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>テスト用の出力とテスト結果はインターリーブされていることに注意してください。その理由は、前のセクションで説明したように、テストが並行して実行されているためです。<code>--test-threads=1</code>オプションと<code>--nocapture</code>フラグを使い、出力がどのようなものか見てみましょう。</p>
<a class="header" href="#a名前でテストの一部を実行する" id="a名前でテストの一部を実行する"><h3>名前でテストの一部を実行する</h3></a>
<p>場合によっては、完全なテストスイートを実行するのに時間がかかることがあります。特定の領域のコードで作業している場合は、そのコードに関連するテストのみを実行することができます。<code>cargo test</code>に引数として実行したいテストの名前を渡すことで、実行するテストを選択することができます。</p>
<p>テストのサブセットを実行する方法を示すために、リスト11-11に示すように、<code>add_two</code>関数の3つのテストを作成し、実行するものを選択します。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
#}</code></pre></pre>
<p><span class="caption">リスト 11-11: 3つの異なる名前の3つのテスト</span></p>
<p>前に見たように、引数を渡さずにテストを実行すると、すべてのテストが並行して実行されます。</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="#a単独のテストを走らせる" id="a単独のテストを走らせる"><h4>単独のテストを走らせる</h4></a>
<p>テスト関数の名前を<code>cargo test</code>に渡して、そのテストだけを実行することができます。</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p><code>one_hundred</code>という名前のテストだけが実行されました。他の2つのテストはその名前と一致しません。テスト出力では、サマリー行の最後に<code>2 filtered out</code>と表示して、このコマンドが実行したものよりも多くのテストがあることがわかります。</p>
<p>このように複数のテストの名前を指定することはできません。<code>cargo test</code>に与えられた最初の値のみが使用されます。しかし、複数のテストを実行する方法があります。</p>
<a class="header" href="#a複数のテストを実行するためのフィルタリング" id="a複数のテストを実行するためのフィルタリング"><h4>複数のテストを実行するためのフィルタリング</h4></a>
<p>テスト名の一部を指定することができ、その名前と一致する名前のテストが実行されます。たとえば、テストの名前のうち2つに<code>add</code>が含まれているので、<code>cargo test add</code>を実行して2つのテストを実行できます。</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>このコマンドは、名前に<code>add</code>を付けてすべてのテストを実行し、<code>one_hundred</code>という名前のテストを除外しました。また、テストが表示されるモジュールはテストの名前の一部になりますので、モジュールの名前をフィルタリングしてモジュール内のすべてのテストを実行できます。</p>
<a class="header" href="#a特に希望のない限りテストを無視する" id="a特に希望のない限りテストを無視する"><h3>特に希望のない限りテストを無視する</h3></a>
<p>場合によっては、いくつかの特定のテストが実行に非常に時間がかかることがあるので、ほとんどの<code>cargo test</code>の実行中にそれらを除外したいかもしれません。実行したいすべてのテストを引数としてリストするのではなく、時間のかかるテストに <code>ignore</code>属性を使って注釈を付けて除外することができます。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
#}</code></pre></pre>
<p><code>#[test]</code>の後に、除外したいテストに<code>#[ignore]</code>行を追加します。テストを実行すると、<code>it_works</code>が実行されますが、<code>expensive_test</code>は実行しません。</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>expensive_test</code>関数は<code>ignored</code>としてリストされます。無視されたテストだけを実行したい場合は、<code>cargo test -- --ignored</code>を使うことができます。</p>
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>どのテストを実行するかを制御することで、<code>cargo test</code>の結果が速くなることを確認できます。<code>ignored</code>テストの結果を確認することが道理に合い、結果を待つだけの時間ができたときに、 代わりに<code>cargo test -- --ignored</code>を走らせることができます。</p>
<a class="header" href="#aテストの体系化" id="aテストの体系化"><h2>テストの体系化</h2></a>
<p>この章の冒頭で述べたように、テストは複雑な規律であり、二兎により用語や体系化が異なります。Rustコミュニティでは、テストについて、<em>単体テスト</em>と<em>結合テスト</em>の2つのカテゴリに分かれて考えています。単体テストは、小さくて集中的で、一度に1つのモジュールを単独でテストし、プライベートインターフェイスをテストできます。統合テストは完全にあなたのライブラリの外部にあり、パブリックインターフェイスのみを使用し、テストごとに複数のモジュールを実行する可能性がある他の外部コードと同じ方法でコードを使用します。</p>
<p>どちらのテストを書くのも、ライブラリの一部が個別かつ共同でしてほしいことをしていることを確認するのに重要なのです。</p>
<a class="header" href="#a単体テスト" id="a単体テスト"><h3>単体テスト</h3></a>
<p>単体テストの目的は、コードの各単位を他のコードと孤立してテストし、コードがどこにあるかを素早く特定し、期待どおりに動作しないようにすることです。それぞれのファイルの* src *ディレクトリにある単体テストをテストしているコードに置きます。慣例は、各ファイルに<code>tests</code>という名前のモジュールを作成し、テスト関数を含み、<code>cfg(test)</code>でモジュールに注釈を付けることです。</p>
<a class="header" href="#aテストモジュールとcfgtest" id="aテストモジュールとcfgtest"><h4>テストモジュールと<code>#[cfg(test)]</code></h4></a>
<p>テストモジュールの <code>#[cfg(test)]</code>アノテーションは<code>cargo build</code>を実行したときではなく<code>cargo test</code>を実行したときにのみテストコードをコンパイルして実行するようRustに指示します。これにより、ライブラリが構築され、結果としてコンパイルされた成果物にスペースが節約されるだけで、テストが含まれないため、コンパイル時間が節約されます。統合テストは別のディレクトリにあるので、<code>#[cfg(test)]</code>アノテーションは必要ありません。しかし、単体テストはコードと同じファイルに入っているので、<code>#[cfg(test)]</code>を使ってそれらをコンパイル結果に含めないように指定します。</p>
<p>この章の最初の節で新しい<code>adder</code>プロジェクトを生成した時に、Cargoがこのコードも生成してくれたことを思い出してください:</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>このコードは自動的に生成されたテストモジュールです。属性<code>cfg</code>は<em>configuration</em>の略であり、以下の項目は特定の設定オプションを指定した場合にのみ含めるべきであることをRustに伝えます。この場合、構成オプションはtestをコンパイルして実行するためにRustによって提供される<code>test</code>です。<code>cfg</code>属性を使うことで、<code>cargo test</code>で積極的にテストを実行する場合にのみ、Cargoはテストコードをコンパイルします。これには、<code>#[test]</code>で注釈を付けられた関数に加えて、このモジュール内にあるヘルパー関数が含まれます。</p>
<a class="header" href="#a非公開関数をテストする" id="a非公開関数をテストする"><h4>非公開関数をテストする</h4></a>
<p>プライベート機能を直接テストする必要があるかどうかについては、テストコミュニティ内で議論されており、他の言語ではプライベート機能をテストすることが困難または不可能になっています。どのテストイデオロギーを遵守しているかに関係なく、Rustのプライバシールールではプライベート機能をテストできます。リスト11-12のプライベート関数<code>internal_adder</code>を含むコードを考えてください。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}

pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre></pre>
<p><span class="caption">リスト 11-12: プライベート関数のテスト</span></p>
<p><code>internal_adder</code>関数は<code>pub</code>としてマークされていませんが、テストは単にRustコードであり、<code>tests</code>モジュールはちょうど別のモジュールなので、テストのスコープに<code>internal_adder</code>を持って呼び出すことができます。プライベート関数がテストされるべきだと思っていないなら、そうするように強制するRustには何もありません。</p>
<a class="header" href="#a結合テスト" id="a結合テスト"><h3>結合テスト</h3></a>
<p>Rustでは、統合テストは完全にライブラリの外部にあります。他のコードと同じ方法でライブラリを使用します。つまり、ライブラリの公開APIの一部である関数のみを呼び出すことができます。その目的は、ライブラリの多くの部分が正しく連携しているかどうかをテストすることです。独自に正しく動作するコード単位では、統合されたときに問題が発生する可能性があるため、統合コードのテストカバレッジも重要です。統合テストを作成するには、まず<em>tests</em>ディレクトリが必要です。</p>
<a class="header" href="#testsディレクトリ" id="testsディレクトリ"><h4><em>tests</em>ディレクトリ</h4></a>
<p><em>src</em>の横のプロジェクトディレクトリの最上位に<em>tests</em>ディレクトリを作成します。Cargoはこのディレクトリに統合テストファイルを探すことを知っています。次に、このディレクトリにいくつでもテストファイルを作成することができ、Cargoはそれぞれのファイルを個々のクレートとしてコンパイルします。</p>
<p>統合テストを作成しましょう。リスト11-12のコードを<em>src/lib.rs</em>ファイルに残して<em>tests</em>ディレクトリを作成し、<em>tests/integration_test.rs</em>という名前の新しいファイルを作成し、リスト11-13のコードを入力します。</p>
<p><span class="filename">ファイル名: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">リスト 11-13: <code>adder</code>クレートの関数の結合テスト</span></p>
<p>コードの先頭に<code>use adder</code>を追加しました。単体テストでは不要でした。なぜなら、<code>tests</code>ディレクトリの各テストは別々のクレートなので、私たちのライブラリを各テストクレートのスコープに持っていく必要があるからです。</p>
<p><em>tests/integration_test.rs</em>のコードに<code>#[cfg(test)]</code>を使って注釈を付ける必要はありません。Cargoは<code>tests</code>ディレクトリを特別に扱い、<code>cargo test</code>を実行するときにのみこのディレクトリのファイルをコンパイルします。今すぐ<code>cargo test</code>を実行してください。</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>出力の3つのセクションには、ユニットテスト、統合テスト、およびドキュメントテストが含まれます。ユニットテストの最初のセクションは、これまでのユニットテストの1行（リスト11-12で追加した<code>internal</code>という名前）とユニットテストのサマリー行です。</p>
<p>統合テストのセクションは <code>Running target/debug/deps/integration_test-ce99bcc2479f4607</code>という行から始まります（出力の最後のハッシュは異なります）。次に、その統合テストでは各テスト関数の行があり、<code>Doc-tests adder</code>セクションが始まる直前に統合テストの結果の要約行があります。</p>
<p>より多くの単体テスト機能を追加することでユニットテストセクションに結果ラインが追加されるのと同様に、より多くのテスト機能を統合テストファイルに追加することで、この統合テストファイルのセクションに多くの結果ラインが追加されます。 各統合テストファイルには独自のセクションがあるので、<em>tests</em>ディレクトリにさらにファイルを追加すると、より多くの統合テストセクションが作成されます。</p>
<p>テスト関数の名前を<code>cargo test</code>の引数として指定することで、特定の統合テスト関数を実行することができます。特定の統合テストファイルですべてのテストを実行するには、<code>cargo test</code>の<code>--test</code>引数の後ろにファイル名を続けてください。</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>このコマンドは、<em>tests/integration_test.rs</em>ファイル内のテストのみを実行します。</p>
<a class="header" href="#a結合テスト内のサブモジュール" id="a結合テスト内のサブモジュール"><h4>結合テスト内のサブモジュール</h4></a>
<p>より多くの統合テストを追加すると、<em>tests</em>ディレクトリに複数のファイルを作成して整理するのに役立つ場合があります。 たとえば、テスト機能をテストしている機能でグループ化できます。先に述べたように、<em>tests</em>ディレクトリ内の各ファイルは、別個のクレートとしてコンパイルされます。</p>
<p>各結合テストファイルをそれ自身のクレートとして扱うと、エンドユーザが読者のクレートを使用するかのような個別のスコープを生成するのに役立ちます。ですが、これは<em>tests</em>ディレクトリのファイルが、コードをモジュールとファイルに分ける方法に関して第7章で学んだように、<em>src</em>のファイルとは同じ振る舞いを共有しないことを意味します。</p>
<p><em>tests</em>ディレクトリ内のファイルのさまざまな動作は、複数の統合テストファイルで役立つヘルパー関数ができ、第7章の「モジュールを別のファイルに移動する」節の手順に従って共通モジュールに抽出しようとした時に最も気付きやすくなります。例えば、<em>tests/common.rs</em>を作成し、そこに<code>setup</code>という名前の関数を配置したら、 複数のテストファイルの複数のテスト関数から呼び出したい<code>setup</code>に何らかのコードを追加することができます。</p>
<p><span class="filename">ファイル名: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn setup() {
    // setup code specific to your library's tests would go here
}
#}</code></pre></pre>
<p>テストを再実行すると、<em>common.rs</em>ファイルのテスト出力に新しいセクションが表示されます。ただし、このファイルにはテスト関数が含まれておらず、どこからでも<code>setup</code>関数を呼び出すことはありませんでした。</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>テスト結果に<code>common 0</code>が表示されている状態で<code>running 0 tests</code>が表示されているのは、望んでいる結果ではありません。 他の統合テストファイルといくつかのコードを共有したかっただけです。</p>
<p><em>tests/common.rs</em>を作成するのではなく、テスト出力に<code>common</code>が現れるのを避けるため、<em>tests/common/mod.rs</em>を作成します。これは、Rustも理解している別の命名規則です。この方法でファイルを命名すると、Rustは<code>common</code>モジュールを統合テストファイルとして扱わないように指示します。<code>setup</code>関数コードを<em>tests/common/mod.rs</em>に移動して<em>tests/common.rs</em>ファイルを削除すると、テスト出力のセクションは表示されなくなります。<em>tests</em>ディレクトリのサブディレクトリにあるファイルは、別々のファイルとしてコンパイルされたり、テスト出力にセクションがありません。</p>
<p><em>tests/common/mod.rs</em>を作成したら、統合テストファイルのいずれかからモジュールとして使用できます。<em>tests/integration_test.rs</em>の<code>it_adds_two</code>テストから<code>setup</code>関数を呼び出す例を示します。</p>
<p><span class="filename">ファイル名: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><code>mod common;</code>宣言はリスト7-25で示したモジュール宣言と同じです。次に、テスト関数で<code>common::setup()</code>関数を呼び出すことができます。</p>
<a class="header" href="#aバイナリクレート用の結合テスト" id="aバイナリクレート用の結合テスト"><h4>バイナリクレート用の結合テスト</h4></a>
<p>プロジェクトが<em>src/main.rs</em>ファイルのみを含み、<em>src/lib.rs</em>ファイルを持たないバイナリクレートである場合、<em>tests</em>ディレクトリに統合テストを作成して関数を呼び出すことはできません <em>src/main.rs</em>ファイルで<code>use</code>ステートメントでスコープに定義されています。ライブラリークレートのみが、他のクレートが使用できる機能を公開します。バイナリクレートは、単独で実行されることを意図しています。</p>
<p>これは、バイナリを提供するRustプロジェクトが<em>src/lib.rs</em>ファイルに存在するロジックを呼び出す簡単な<em>src/main.rs</em>ファイルを持っている理由の1つです。その構造を使用して、統合テストは、重要な機能を利用できるようにするために、ライブラリクレートを<code>use</code>でテストできます。重要な機能が動作する場合は、<em>src/main.rs</em>ファイル内の少量のコードも同様に動作し、少量のコードをテストする必要はありません。</p>
<a class="header" href="#aまとめ-10" id="aまとめ-10"><h2>まとめ</h2></a>
<p>Rustのテスト機能は、たとえ変更を加えたとしても、コードがどのように機能して期待通りに機能するかを指定する方法を提供します。単体テストはライブラリの別々の部分を個別に実行し、プライベートな実装の詳細をテストできます。統合テストでは、ライブラリの多くの部分が正しく連携していることを確認し、ライブラリのパブリックAPIを使用して、外部コードが使用するのと同じ方法でコードをテストします。Rustのタイプのシステムと所有権のルールはいくつかの種類のバグを防ぐのに役立ちますが、テストがロジックバグを減らすためには、コードがどのように動作することが予想されるかに関係しています。</p>
<p>この章で学んだ知識とこれまでの章で学んだ知識を組み合わせてプロジェクトを進めましょう。</p>
<a class="header" href="#a入出力プロジェクト-コマンドラインプログラムを構築する" id="a入出力プロジェクト-コマンドラインプログラムを構築する"><h1>入出力プロジェクト: コマンドラインプログラムを構築する</h1></a>
<p>この章では、これまでに学んだ多くのスキルと、いくつかの標準的なライブラリ機能の概要を取り上げます。ファイルやコマンドラインの入出力と対話するコマンドラインツールを構築して、現在持っているRustの概念のいくつかを練習します。</p>
<p>Rustのスピード、安全性、シングルバイナリ出力、クロスプラットフォームサポートは、コマンドラインツールを作成するのに理想的な言語なので、このプロジェクトでは古典的なコマンドラインツール<code>grep</code>(<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint)を独自のバージョンで作成します。最も単純な使用例では、<code>grep</code>は指定されたファイルを指定された文字列で検索します。そうするために、<code>grep</code>は引数としてファイル名と文字列をとります。次に、ファイルを読み込み、そのファイル内で文字列引数を含む行を見つけ出し、それらの行を出力します。</p>
<p>その間、多くのコマンドラインツールが使用するターミナルの機能をコマンドラインツールで使用する方法を示します。環境変数の値を読んで、ユーザーがツールの動作を設定できるようにします。標準出力(<code>stdout</code>)の代わりに標準エラーコンソールストリーム(<code>stderr</code>)にも出力するので、例えば、ユーザは正常な出力をファイルにリダイレクトし、画面上にエラーメッセージが表示されることがあります。</p>
<p>あるRustのコミュニティーメンバーであるAndrew Gallantは、既に完全機能を備えた非常に高速な<code>grep</code>のバージョンを作成しました。これは<code>ripgrep</code>です。これと比較すると、grepのバージョンはかなりシンプルですが、この章では<code>ripgrep</code>のような実際のプロジェクトを理解するのに必要な知識をいくつか紹介します。</p>
<p><code>grep</code>プロジェクトはこれまでに学んだ多くのコンセプトを組み合わせます。</p>
<ul>
<li>コードを体系化する(モジュール、第7章で学んだことを使用)</li>
<li>vector型と文字列を使用する(コレクション、第8章)</li>
<li>エラーを処理する(第9章)</li>
<li>適切な箇所でトレイトとライフタイムを使用する(第10章)</li>
<li>テストを記述する(第11章)</li>
</ul>
<p>また、クロージャ、イテレータ、およびトレイトオブジェクトについても簡単に紹介します（第13章および第17章で詳しく説明します）。</p>
<a class="header" href="#accepting-command-line-arguments" id="accepting-command-line-arguments"><h2>Accepting Command Line Arguments</h2></a>
<p>Let’s create a new project with, as always, <code>cargo new</code>. We’ll call our project
<code>minigrep</code> to distinguish it from the <code>grep</code> tool that you might already have
on your system.</p>
<pre><code class="language-text">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>The first task is to make <code>minigrep</code> accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with <code>cargo run</code>, a string to search for, and a path to a file to
search in, like so:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Right now, the program generated by <code>cargo new</code> cannot process arguments we
give it. Some existing libraries on <a href="https://crates.io/">Crates.io</a> can help
with writing a program that accepts command line arguments, but because you’re
just learning this concept, let’s implement this capability ourselves.</p>
<a class="header" href="#reading-the-argument-values" id="reading-the-argument-values"><h3>Reading the Argument Values</h3></a>
<p>To enable <code>minigrep</code> to read the values of command line arguments we pass to
it, we’ll need a function provided in Rust’s standard library, which is
<code>std::env::args</code>. This function returns an <em>iterator</em> of the command line
arguments that were given to <code>minigrep</code>. We haven’t discussed iterators yet
(we’ll cover them fully in Chapter 13), but for now, you only need to know two
details about iterators: iterators produce a series of values, and we can call
the <code>collect</code> method on an iterator to turn it into a collection, such as a
vector, containing all the elements the iterator produces.</p>
<p>Use the code in Listing 12-1 to allow your <code>minigrep</code> program to read any
command line arguments passed to it and then collect the values into a vector:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">Listing 12-1: Collecting the command line arguments into
a vector and printing them</span></p>
<p>First, we bring the <code>std::env</code> module into scope with a <code>use</code> statement so we
can use its <code>args</code> function. Notice that the <code>std::env::args</code> function is
nested in two levels of modules. As we discussed in Chapter 7, in cases where
the desired function is nested in more than one module, it’s conventional to
bring the parent module into scope rather than the function. By doing so, we
can easily use other functions from <code>std::env</code>. It’s also less ambiguous than
adding <code>use std::env::args</code> and then calling the function with just <code>args</code>,
because <code>args</code> might easily be mistaken for a function that’s defined in the
current module.</p>
<blockquote>
<a class="header" href="#the-args-function-and-invalid-unicode" id="the-args-function-and-invalid-unicode"><h3>The <code>args</code> Function and Invalid Unicode</h3></a>
<p>Note that <code>std::env::args</code> will panic if any argument contains invalid
Unicode. If your program needs to accept arguments containing invalid
Unicode, use <code>std::env::args_os</code> instead. That function returns an iterator
that produces <code>OsString</code> values instead of <code>String</code> values. We’ve chosen to
use <code>std::env::args</code> here for simplicity, because <code>OsString</code> values differ
per platform and are more complex to work with than <code>String</code> values.</p>
</blockquote>
<p>On the first line of <code>main</code>, we call <code>env::args</code>, and we immediately use
<code>collect</code> to turn the iterator into a vector containing all the values produced
by the iterator. We can use the <code>collect</code> function to create many kinds of
collections, so we explicitly annotate the type of <code>args</code> to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, <code>collect</code> is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.</p>
<p>Finally, we print the vector using the debug formatter, <code>:?</code>. Let’s try running
the code first with no arguments and then with two arguments:</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Notice that the first value in the vector is <code>&quot;target/debug/minigrep&quot;</code>, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case you want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.</p>
<a class="header" href="#saving-the-argument-values-in-variables" id="saving-the-argument-values-in-variables"><h3>Saving the Argument Values in Variables</h3></a>
<p>Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">Listing 12-2: Creating variables to hold the query
argument and filename argument</span></p>
<p>As we saw when we printed the vector, the program’s name takes up the first
value in the vector at <code>args[0]</code>, so we’re starting at index <code>1</code>. The first
argument <code>minigrep</code> takes is the string we’re searching for, so we put a
reference to the first argument in the variable <code>query</code>. The second argument
will be the filename, so we put a reference to the second argument in the
variable <code>filename</code>.</p>
<p>We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments <code>test</code>
and <code>sample.txt</code>:</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file-reading
capabilities instead.</p>
<a class="header" href="#reading-a-file" id="reading-a-file"><h2>Reading a File</h2></a>
<p>Now we’ll add functionality to read the file that is specified in the
<code>filename</code> command line argument. First, we need a sample file to test it with:
the best kind of file to use to make sure <code>minigrep</code> is working is one with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
<em>poem.txt</em> at the root level of your project, and enter the poem “I’m Nobody!
Who are you?”</p>
<p><span class="filename">Filename: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listing 12-3: A poem by Emily Dickinson makes a good test
case</span></p>
<p>With the text in place, edit <em>src/main.rs</em> and add code to read the file, as
shown in Listing 12-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs;

fn main() {
#     let args: Vec&lt;String&gt; = env::args().collect();
#
#     let query = &amp;args[1];
#     let filename = &amp;args[2];
#
#     println!(&quot;Searching for {}&quot;, query);
    // --snip--
    println!(&quot;In file {}&quot;, filename);

    let contents = fs::read_to_string(filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">Listing 12-4: Reading the contents of the file specified
by the second argument</span></p>
<p>First, we add another <code>use</code> statement to bring in a relevant part of the
standard library: we need <code>std::fs</code> to handle files.</p>
<p>In <code>main</code>, we’ve added a new statement: <code>fs::read_to_string</code> will take the
<code>filename</code>, open that file, and then return <code>Result&lt;String&gt;</code> with its contents.</p>
<p>After that line, we’ve again added a temporary <code>println!</code> statement that
prints the value of <code>contents</code> after the file is read, so we can check that the
program is working so far.</p>
<p>Let’s run this code with any string as the first command line argument (because
we haven’t implemented the searching part yet) and the <em>poem.txt</em> file as the
second argument:</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Great! The code read and then printed the contents of the file. But the code
has a few flaws. The <code>main</code> function has multiple responsibilities: generally,
functions are clearer and easier to maintain if each function is responsible
for only one idea. The other problem is that we’re not handling errors as well
as we could. The program is still small, so these flaws aren’t a big problem,
but as the program grows, it will be harder to fix them cleanly. It’s good
practice to begin refactoring early on when developing a program, because it’s
much easier to refactor smaller amounts of code. We’ll do that next.</p>
<a class="header" href="#refactoring-to-improve-modularity-and-error-handling" id="refactoring-to-improve-modularity-and-error-handling"><h2>Refactoring to Improve Modularity and Error Handling</h2></a>
<p>To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors.</p>
<p>First, our <code>main</code> function now performs two tasks: it parses arguments and
reads files. For such a small function, this isn’t a major problem. However, if
we continue to grow our program inside <code>main</code>, the number of separate tasks the
<code>main</code> function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It’s best to separate functionality so each
function is responsible for one task.</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>filename</code>
are configuration variables to our program, variables like <code>contents</code> are used
to perform the program’s logic. The longer <code>main</code> becomes, the more variables
we’ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It’s best to group the
configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when
reading the file fails, but the error message just prints
<code>something went wrong</code>. Reading a file can fail in a number of ways: for
example, the file could be missing, or we might not have permission to open
it. Right now, regardless of the situation, we’d print the
<code>something went wrong</code> error message, which wouldn’t give the user any
information!</p>
<p>Fourth, we use <code>expect</code> repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they’ll get an <code>index out of bounds</code> error from Rust that doesn’t clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
we’re printing messages that will be meaningful to our end users.</p>
<p>Let’s address these four problems by refactoring our project.</p>
<a class="header" href="#separation-of-concerns-for-binary-projects" id="separation-of-concerns-for-binary-projects"><h3>Separation of Concerns for Binary Projects</h3></a>
<p>The organizational problem of allocating responsibility for multiple tasks to
the <code>main</code> function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when <code>main</code> starts getting large. The
process has the following steps:</p>
<ul>
<li>
<p>Split your program into a <em>main.rs</em> and a <em>lib.rs</em> and move your program’s
logic to <em>lib.rs</em>.</p>
</li>
<li>
<p>As long as your command line parsing logic is small, it can remain in
<em>main.rs</em>.</p>
</li>
<li>
<p>When the command line parsing logic starts getting complicated, extract it
from <em>main.rs</em> and move it to <em>lib.rs</em>.</p>
</li>
<li>
<p>The responsibilities that remain in the <code>main</code> function after this process
should be limited to the following:</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>Handling the error if <code>run</code> returns an error</li>
</ul>
</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the
program, and <em>lib.rs</em> handles all the logic of the task at hand. Because you
can’t test the <code>main</code> function directly, this structure lets you test all of
your program’s logic by moving it into functions in <em>lib.rs</em>. The only code
that remains in <em>main.rs</em> will be small enough to verify its correctness by
reading it. Let’s rework our program by following this process.</p>
<a class="header" href="#extracting-the-argument-parser" id="extracting-the-argument-parser"><h4>Extracting the Argument Parser</h4></a>
<p>We’ll extract the functionality for parsing arguments into a function that
<code>main</code> will call to prepare for moving the command line parsing logic to
<em>src/lib.rs</em>. Listing 12-5 shows the new start of <code>main</code> that calls a new
function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em> for the moment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listing 12-5: Extracting a <code>parse_config</code> function from
<code>main</code></span></p>
<p>We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index <code>1</code> to the variable <code>query</code> and the
argument value at index <code>2</code> to the variable <code>filename</code> within the <code>main</code>
function, we pass the whole vector to the <code>parse_config</code> function. The
<code>parse_config</code> function then holds the logic that determines which argument
goes in which variable and passes the values back to <code>main</code>. We still create
the <code>query</code> and <code>filename</code> variables in <code>main</code>, but <code>main</code> no longer has the
responsibility of determining how the command line arguments and variables
correspond.</p>
<p>This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help identify the cause of problems when they occur.</p>
<a class="header" href="#grouping-configuration-values" id="grouping-configuration-values"><h4>Grouping Configuration Values</h4></a>
<p>We can take another small step to improve the <code>parse_config</code> function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.</p>
<p>Another indicator that shows there’s room for improvement is the <code>config</code> part
of <code>parse_config</code>, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.</p>
<blockquote>
<p>Note: Some people call this anti-pattern of using primitive values when a
complex type would be more appropriate <em>primitive obsession</em>.</p>
</blockquote>
<p>Listing 12-6 shows the addition of a struct named <code>Config</code> defined to have
fields named <code>query</code> and <code>filename</code>. We’ve also changed the <code>parse_config</code>
function to return an instance of the <code>Config</code> struct and updated <code>main</code> to use
the struct fields rather than having separate variables:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Listing 12-6: Refactoring <code>parse_config</code> to return an
instance of a <code>Config</code> struct</span></p>
<p>The signature of <code>parse_config</code> now indicates that it returns a <code>Config</code> value.
In the body of <code>parse_config</code>, where we used to return string slices that
reference <code>String</code> values in <code>args</code>, we now define <code>Config</code> to contain owned
<code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of the argument
values and is only letting the <code>parse_config</code> function borrow them, which means
we’d violate Rust’s borrowing rules if <code>Config</code> tried to take ownership of the
values in <code>args</code>.</p>
<p>We could manage the <code>String</code> data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the <code>clone</code> method on
the values. This will make a full copy of the data for the <code>Config</code> instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don’t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.</p>
<blockquote>
<a class="header" href="#the-trade-offs-of-using-clone" id="the-trade-offs-of-using-clone"><h3>The Trade-Offs of Using <code>clone</code></h3></a>
<p>There’s a tendency among many Rustaceans to avoid using <code>clone</code> to fix
ownership problems because of its runtime cost. In Chapter 13, you’ll learn
how to use more efficient methods in this type of situation. But for now,
it’s okay to copy a few strings to continue making progress because you’ll
make these copies only once and your filename and query string are very
small. It’s better to have a working program that’s a bit inefficient than to
try to hyperoptimize code on your first pass. As you become more experienced
with Rust, it’ll be easier to start with the most efficient solution, but for
now, it’s perfectly acceptable to call <code>clone</code>.</p>
</blockquote>
<p>We’ve updated <code>main</code> so it places the instance of <code>Config</code> returned by
<code>parse_config</code> into a variable named <code>config</code>, and we updated the code that
previously used the separate <code>query</code> and <code>filename</code> variables so it now uses
the fields on the <code>Config</code> struct instead.</p>
<p>Now our code more clearly conveys that <code>query</code> and <code>filename</code> are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the <code>config</code> instance in the fields
named for their purpose.</p>
<a class="header" href="#creating-a-constructor-for-config" id="creating-a-constructor-for-config"><h4>Creating a Constructor for <code>Config</code></h4></a>
<p>So far, we’ve extracted the logic responsible for parsing the command line
arguments from <code>main</code> and placed it in the <code>parse_config</code> function. Doing so
helped us to see that the <code>query</code> and <code>filename</code> values were related and that
relationship should be conveyed in our code. We then added a <code>Config</code> struct to
name the related purpose of <code>query</code> and <code>filename</code> and to be able to return the
values’ names as struct field names from the <code>parse_config</code> function.</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code>
instance, we can change <code>parse_config</code> from a plain function to a function
named <code>new</code> that is associated with the <code>Config</code> struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as <code>String</code>, by calling <code>String::new</code>. Similarly, by
changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we’ll
be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7
shows the changes we need to make:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 12-7: Changing <code>parse_config</code> into
<code>Config::new</code></span></p>
<p>We’ve updated <code>main</code> where we were calling <code>parse_config</code> to instead call
<code>Config::new</code>. We’ve changed the name of <code>parse_config</code> to <code>new</code> and moved it
within an <code>impl</code> block, which associates the <code>new</code> function with <code>Config</code>. Try
compiling this code again to make sure it works.</p>
<a class="header" href="#fixing-the-error-handling" id="fixing-the-error-handling"><h3>Fixing the Error Handling</h3></a>
<p>Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the <code>args</code> vector at index <code>1</code> or index <code>2</code> will cause the
program to panic if the vector contains fewer than three items. Try running the
program without any arguments; it will look like this:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>The line <code>index out of bounds: the len is 1 but the index is 1</code> is an error
message intended for programmers. It won’t help our end users understand what
happened and what they should do instead. Let’s fix that now.</p>
<a class="header" href="#improving-the-error-message" id="improving-the-error-message"><h4>Improving the Error Message</h4></a>
<p>In Listing 12-8, we add a check in the <code>new</code> function that will verify that the
slice is long enough before accessing index <code>1</code> and <code>2</code>. If the slice isn’t
long enough, the program panics and displays a better error message than the
<code>index out of bounds</code> message.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<p><span class="caption">Listing 12-8: Adding a check for the number of
arguments</span></p>
<p>This code is similar to the <code>Guess::new</code> function we wrote in Listing 9-10, where
we called <code>panic!</code> when the <code>value</code> argument was out of the range of valid
values. Instead of checking for a range of values here, we’re checking that the
length of <code>args</code> is at least <code>3</code> and the rest of the function can operate under
the assumption that this condition has been met. If <code>args</code> has fewer than three
items, this condition will be true, and we call the <code>panic!</code> macro to end the
program immediately.</p>
<p>With these extra few lines of code in <code>new</code>, let’s run the program without any
arguments again to see what the error looks like now:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps using
the technique we used in Listing 9-10 isn’t the best to use here: a call to
<code>panic!</code> is more appropriate for a programming problem rather than a usage
problem, as discussed in Chapter 9. Instead, we can use the other technique you
learned about in Chapter 9—returning a <code>Result</code> that indicates either success
or an error.</p>
<a class="header" href="#returning-a-result-from-new-instead-of-calling-panic" id="returning-a-result-from-new-instead-of-calling-panic"><h4>Returning a <code>Result</code> from <code>new</code> Instead of Calling <code>panic!</code></h4></a>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in
the successful case and will describe the problem in the error case. When
<code>Config::new</code> is communicating to <code>main</code>, we can use the <code>Result</code> type to
signal there was a problem. Then we can change <code>main</code> to convert an <code>Err</code>
variant into a more practical error for our users without the surrounding text
about <code>thread 'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>Listing 12-9 shows the changes we need to make to the return value of
<code>Config::new</code> and the body of the function needed to return a <code>Result</code>. Note
that this won’t compile until we update <code>main</code> as well, which we’ll do in the
next listing.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Listing 12-9: Returning a <code>Result</code> from
<code>Config::new</code></span></p>
<p>Our <code>new</code> function now returns a <code>Result</code> with a <code>Config</code> instance in the
success case and a <code>&amp;'static str</code> in the error case. Recall from “The Static
Lifetime” section in Chapter 10 that <code>&amp;'static str</code> is the type of string
literals, which is our error message type for now.</p>
<p>We’ve made two changes in the body of the <code>new</code> function: instead of calling
<code>panic!</code> when the user doesn’t pass enough arguments, we now return an <code>Err</code>
value, and we’ve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes
make the function conform to its new type signature.</p>
<p>Returning an <code>Err</code> value from <code>Config::new</code> allows the <code>main</code> function to
handle the <code>Result</code> value returned from the <code>new</code> function and exit the process
more cleanly in the error case.</p>
<a class="header" href="#calling-confignew-and-handling-errors" id="calling-confignew-and-handling-errors"><h4>Calling <code>Config::new</code> and Handling Errors</h4></a>
<p>To handle the error case and print a user-friendly message, we need to update
<code>main</code> to handle the <code>Result</code> being returned by <code>Config::new</code>, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code from <code>panic!</code> and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<p><span class="caption">Listing 12-10: Exiting with an error code if creating a
new <code>Config</code> fails</span></p>
<p>In this listing, we’ve used a method we haven’t covered before:
<code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library.
Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error
handling. If the <code>Result</code> is an <code>Ok</code> value, this method’s behavior is similar
to <code>unwrap</code>: it returns the inner value <code>Ok</code> is wrapping. However, if the value
is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is an
anonymous function we define and pass as an argument to <code>unwrap_or_else</code>. We’ll
cover closures in more detail in Chapter 13. For now, you just need to know
that <code>unwrap_or_else</code> will pass the inner value of the <code>Err</code>, which in this
case is the static string <code>not enough arguments</code> that we added in Listing 12-9,
to our closure in the argument <code>err</code> that appears between the vertical pipes.
The code in the closure can then use the <code>err</code> value when it runs.</p>
<p>We’ve added a new <code>use</code> line to bring <code>process</code> from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the <code>err</code> value and then call <code>process::exit</code>. The
<code>process::exit</code> function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
<code>panic!</code>-based handling we used in Listing 12-8, but we no longer get all the
extra output. Let’s try it:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<a class="header" href="#extracting-logic-from-main" id="extracting-logic-from-main"><h3>Extracting Logic from <code>main</code></h3></a>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in “Separation of Concerns for Binary
Projects”, we’ll extract a function named <code>run</code> that will hold all the logic
currently in the <code>main</code> function that isn’t involved with setting up
configuration or handling errors. When we’re done, <code>main</code> will be concise and
easy to verify by inspection, and we’ll be able to write tests for all the
other logic.</p>
<p>Listing 12-11 shows the extracted <code>run</code> function. For now, we’re just making
the small, incremental improvement of extracting the function. We’re still
defining the function in <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<p><span class="caption">Listing 12-11: Extracting a <code>run</code> function containing the
rest of the program logic</span></p>
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code>, starting
from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an
argument.</p>
<a class="header" href="#returning-errors-from-the-run-function" id="returning-errors-from-the-run-function"><h4>Returning Errors from the <code>run</code> Function</h4></a>
<p>With the remaining program logic separated into the <code>run</code> function, we can
improve the error handling, as we did with <code>Config::new</code> in Listing 12-9.
Instead of allowing the program to panic by calling <code>expect</code>, the <code>run</code>
function will return a <code>Result&lt;T, E&gt;</code> when something goes wrong. This will let
us further consolidate into <code>main</code> the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of <code>run</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listing 12-12: Changing the <code>run</code> function to return
<code>Result</code></span></p>
<p>We’ve made three significant changes here. First, we changed the return type of
the <code>run</code> function to <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. This function previously
returned the unit type, <code>()</code>, and we keep that as the value returned in the
<code>Ok</code> case.</p>
<p>For the error type, we used the <em>trait object</em> <code>Box&lt;dyn Error&gt;</code> (and we’ve
brought <code>std::error::Error</code> into scope with a <code>use</code> statement at the top).
We’ll cover trait objects in Chapter 17. For now, just know that <code>Box&lt;dyn Error&gt;</code> means the function will return a type that implements the <code>Error</code>
trait, but we don’t have to specify what particular type the return value
will be. This gives us flexibility to return error values that may be of
different types in different error cases. This is what the <code>dyn</code> means, it’s
short for “dynamic.”</p>
<p>Second, we’ve removed the call to <code>expect</code> in favor of <code>?</code>, as we talked about
in Chapter 9. Rather than <code>panic!</code> on an error, <code>?</code> will return the error value
from the current function for the caller to handle.</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case. We’ve
declared the <code>run</code> function’s success type as <code>()</code> in the signature, which
means we need to wrap the unit type value in the <code>Ok</code> value. This <code>Ok(())</code>
syntax might look a bit strange at first, but using <code>()</code> like this is the
idiomatic way to indicate that we’re calling <code>run</code> for its side effects only;
it doesn’t return a value we need.</p>
<p>When you run this code, it will compile but will display a warning:</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust tells us that our code ignored the <code>Result</code> value and the <code>Result</code> value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error handling code here! Let’s rectify that problem now.</p>
<a class="header" href="#handling-errors-returned-from-run-in-main" id="handling-errors-returned-from-run-in-main"><h4>Handling Errors Returned from <code>run</code> in <code>main</code></h4></a>
<p>We’ll check for errors and handle them using a technique similar to one we used
with <code>Config::new</code> in Listing 12-10, but with a slight difference:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>We use <code>if let</code> rather than <code>unwrap_or_else</code> to check whether <code>run</code> returns an
<code>Err</code> value and call <code>process::exit(1)</code> if it does. The <code>run</code> function doesn’t
return a value that we want to <code>unwrap</code> in the same way that <code>Config::new</code>
returns the <code>Config</code> instance. Because <code>run</code> returns <code>()</code> in the success case,
we only care about detecting an error, so we don’t need <code>unwrap_or_else</code> to
return the unwrapped value because it would only be <code>()</code>.</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in
both cases: we print the error and exit.</p>
<a class="header" href="#splitting-code-into-a-library-crate" id="splitting-code-into-a-library-crate"><h3>Splitting Code into a Library Crate</h3></a>
<p>Our <code>minigrep</code> project is looking good so far! Now we’ll split the
<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file so we can test
it and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>Let’s move all the code that isn’t the <code>main</code> function from <em>src/main.rs</em> to
<em>src/lib.rs</em>:</p>
<ul>
<li>The <code>run</code> function definition</li>
<li>The relevant <code>use</code> statements</li>
<li>The definition of <code>Config</code></li>
<li>The <code>Config::new</code> function definition</li>
</ul>
<p>The contents of <em>src/lib.rs</em> should have the signatures shown in Listing 12-13
(we’ve omitted the bodies of the functions for brevity). Note that this won’t
compile until we modify <em>src/main.rs</em> in the listing after this one.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
}
</code></pre>
<p><span class="caption">Listing 12-13: Moving <code>Config</code> and <code>run</code> into
<em>src/lib.rs</em></span></p>
<p>We’ve made liberal use of the <code>pub</code> keyword: on <code>Config</code>, on its fields and its
<code>new</code> method, and on the <code>run</code> function. We now have a library crate that has a
public API that we can test!</p>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em>, as shown in Listing 12-14:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep;
use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listing 12-14: Bringing the <code>minigrep</code> crate into the
scope of <em>src/main.rs</em></span></p>
<p>To bring the library crate into the binary crate, we use <code>use minigrep</code>.
Then we add a <code>use minigrep::Config</code> line to bring the <code>Config</code> type
into scope as well, and we prefix the <code>run</code> function with our crate name. Now
all the functionality should be connected and should work. Run the program with
<code>cargo run</code> and make sure everything works correctly.</p>
<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!</p>
<a class="header" href="#developing-the-librarys-functionality-with-test-driven-development" id="developing-the-librarys-functionality-with-test-driven-development"><h2>Developing the Library’s Functionality with Test-Driven Development</h2></a>
<p>Now that we’ve extracted the logic into <em>src/lib.rs</em> and left the argument
collecting and error handling in <em>src/main.rs</em>, it’s much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line. Feel free to write some tests for the functionality in
the <code>Config::new</code> and <code>run</code> functions on your own.</p>
<p>In this section, we’ll add the searching logic to the <code>minigrep</code> program by
using the Test-driven development (TDD) process. This software development
technique follows these steps:</p>
<ol>
<li>Write a test that fails and run it to make sure it fails for the reason you
expect.</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>Refactor the code you just added or changed and make sure the tests
continue to pass.</li>
<li>Repeat from step 1!</li>
</ol>
<p>This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.</p>
<p>We’ll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We’ll add this functionality in a function called
<code>search</code>.</p>
<a class="header" href="#writing-a-failing-test" id="writing-a-failing-test"><h3>Writing a Failing Test</h3></a>
<p>Because we don’t need them anymore, let’s remove the <code>println!</code> statements from
<em>src/lib.rs</em> and <em>src/main.rs</em> that we used to check the program’s behavior.
Then, in <em>src/lib.rs</em>, we’ll add a <code>tests</code> module with a test function, as we
did in Chapter 11. The test function specifies the behavior we want the
<code>search</code> function to have: it will take a query and the text to search for the
query in, and it will return only the lines from the text that contain the
query. Listing 12-15 shows this test, which won’t compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-15: Creating a failing test for the <code>search</code>
function we wish we had</span></p>
<p>This test searches for the string <code>&quot;duct&quot;</code>. The text we’re searching is three
lines, only one of which contains <code>&quot;duct&quot;</code>. We assert that the value returned
from the <code>search</code> function contains only the line we expect.</p>
<p>We aren’t able to run this test and watch it fail because the test doesn’t even
compile: the <code>search</code> function doesn’t exist yet! So now we’ll add just enough
code to get the test to compile and run by adding a definition of the <code>search</code>
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn’t match a vector
containing the line <code>&quot;safe, fast, productive.&quot;</code></p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-16: Defining just enough of the <code>search</code>
function so our test will compile</span></p>
<p>Notice that we need an explicit lifetime <code>'a</code> defined in the signature of
<code>search</code> and used with the <code>contents</code> argument and the return value. Recall in
Chapter 10 that the lifetime parameters specify which argument lifetime is
connected to the lifetime of the return value. In this case, we indicate that
the returned vector should contain string slices that reference slices of the
argument <code>contents</code> (rather than the argument <code>query</code>).</p>
<p>In other words, we tell Rust that the data returned by the <code>search</code> function
will live as long as the data passed into the <code>search</code> function in the
<code>contents</code> argument. This is important! The data referenced <em>by</em> a slice needs
to be valid for the reference to be valid; if the compiler assumes we’re making
string slices of <code>query</code> rather than <code>contents</code>, it will do its safety checking
incorrectly.</p>
<p>If we forget the lifetime annotations and try to compile this function, we’ll
get this error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:51
  |
5 | fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Rust can’t possibly know which of the two arguments we need, so we need to tell
it. Because <code>contents</code> is the argument that contains all of our text and we
want to return the parts of that text that match, we know <code>contents</code> is the
argument that should be connected to the return value using the lifetime syntax.</p>
<p>Other programming languages don’t require you to connect arguments to return
values in the signature. So although this might seem strange, it will get
easier over time. You might want to compare this example with the “Validating
References with Lifetimes” section in Chapter 10.</p>
<p>Now let’s run the test:</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
        thread 'tests::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Great, the test fails, exactly as we expected. Let’s get the test to pass!</p>
<a class="header" href="#writing-code-to-pass-the-test" id="writing-code-to-pass-the-test"><h3>Writing Code to Pass the Test</h3></a>
<p>Currently, our test is failing because we always return an empty vector. To fix
that and implement <code>search</code>, our program needs to follow these steps:</p>
<ul>
<li>Iterate through each line of the contents.</li>
<li>Check whether the line contains our query string.</li>
<li>If it does, add it to the list of values we’re returning.</li>
<li>If it doesn’t, do nothing.</li>
<li>Return the list of results that match.</li>
</ul>
<p>Let’s work through each step, starting with iterating through lines.</p>
<a class="header" href="#iterating-through-lines-with-the-lines-method" id="iterating-through-lines-with-the-lines-method"><h4>Iterating Through Lines with the <code>lines</code> Method</h4></a>
<p>Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note this
won’t compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
</code></pre>
<p><span class="caption">Listing 12-17: Iterating through each line in <code>contents</code>
</span></p>
<p>The <code>lines</code> method returns an iterator. We’ll talk about iterators in depth in
Chapter 13, but recall that you saw this way of using an iterator in Listing
3-5, where we used a <code>for</code> loop with an iterator to run some code on each item
in a collection.</p>
<a class="header" href="#searching-each-line-for-the-query" id="searching-each-line-for-the-query"><h4>Searching Each Line for the Query</h4></a>
<p>Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named <code>contains</code> that does this for
us! Add a call to the <code>contains</code> method in the <code>search</code> function, as shown in
Listing 12-18. Note this still won’t compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in <code>query</code></span></p>
<a class="header" href="#storing-matching-lines" id="storing-matching-lines"><h4>Storing Matching Lines</h4></a>
<p>We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the <code>for</code> loop and call the <code>push</code> method
to store a <code>line</code> in the vector. After the <code>for</code> loop, we return the vector, as
shown in Listing 12-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span></p>
<p>Now the <code>search</code> function should return only the lines that contain <code>query</code>,
and our test should pass. Let’s run the test:</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Our test passed, so we know it works!</p>
<p>At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in Chapter 13, where we’ll explore iterators in detail,
and look at how to improve it.</p>
<a class="header" href="#using-the-search-function-in-the-run-function" id="using-the-search-function-in-the-run-function"><h4>Using the <code>search</code> Function in the <code>run</code> Function</h4></a>
<p>Now that the <code>search</code> function is working and tested, we need to call <code>search</code>
from our <code>run</code> function. We need to pass the <code>config.query</code> value and the
<code>contents</code> that <code>run</code> reads from the file to the <code>search</code> function. Then <code>run</code>
will print each line returned from <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>We’re still using a <code>for</code> loop to return each line from <code>search</code> and print it.</p>
<p>Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, “frog”:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Now let’s try a word that will match multiple lines, like “body”:</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as “monomorphization”:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.</p>
<p>To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.</p>
<a class="header" href="#working-with-environment-variables" id="working-with-environment-variables"><h2>Working with Environment Variables</h2></a>
<p>We’ll improve <code>minigrep</code> by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but instead we’ll use an
environment variable. Doing so allows our users to set the environment variable
once and have all their searches be case insensitive in that terminal session.</p>
<a class="header" href="#writing-a-failing-test-for-the-case-insensitive-search-function" id="writing-a-failing-test-for-the-case-insensitive-search-function"><h3>Writing a Failing Test for the Case-Insensitive <code>search</code> Function</h3></a>
<p>We want to add a new <code>search_case_insensitive</code> function that we’ll call when
the environment variable is on. We’ll continue to follow the TDD process, so
the first step is again to write a failing test. We’ll add a new test for the
new <code>search_case_insensitive</code> function and rename our old test from
<code>one_result</code> to <code>case_sensitive</code> to clarify the differences between the two
tests, as shown in Listing 12-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-20: Adding a new failing test for the
case-insensitive function we’re about to add</span></p>
<p>Note that we’ve edited the old test’s <code>contents</code> too. We’ve added a new line
with the text <code>&quot;Duct tape.&quot;</code> using a capital D that shouldn’t match the query
“duct” when we’re searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don’t accidentally break the case-sensitive
search functionality that we’ve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.</p>
<p>The new test for the case-<em>insensitive</em> search uses <code>&quot;rUsT&quot;</code> as its query. In
the <code>search_case_insensitive</code> function we’re about to add, the query <code>&quot;rUsT&quot;</code>
should match the line containing <code>&quot;Rust:&quot;</code> with a capital R and match the line
<code>&quot;Trust me.&quot;</code> even though both have different casing than the query. This is
our failing test, and it will fail to compile because we haven’t yet defined
the <code>search_case_insensitive</code> function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the <code>search</code> function in Listing 12-16 to see the test compile and fail.</p>
<a class="header" href="#implementing-the-search_case_insensitive-function" id="implementing-the-search_case_insensitive-function"><h3>Implementing the <code>search_case_insensitive</code> Function</h3></a>
<p>The <code>search_case_insensitive</code> function, shown in Listing 12-21, will be almost
the same as the <code>search</code> function. The only difference is that we’ll lowercase
the <code>query</code> and each <code>line</code> so whatever the case of the input arguments,
they’ll be the same case when we check whether the line contains the query.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-21: Defining the <code>search_case_insensitive</code>
function to lowercase the query and the line before comparing them</span></p>
<p>First, we lowercase the <code>query</code> string and store it in a shadowed variable with
the same name. Calling <code>to_lowercase</code> on the query is necessary so no matter
whether the user’s query is <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code>, or <code>&quot;rUsT&quot;</code>, we’ll
treat the query as if it were <code>&quot;rust&quot;</code> and be insensitive to the case.</p>
<p>Note that <code>query</code> is now a <code>String</code> rather than a string slice, because calling
<code>to_lowercase</code> creates new data rather than referencing existing data. Say the
query is <code>&quot;rUsT&quot;</code>, as an example: that string slice doesn’t contain a lowercase
<code>u</code> or <code>t</code> for us to use, so we have to allocate a new <code>String</code> containing
<code>&quot;rust&quot;</code>. When we pass <code>query</code> as an argument to the <code>contains</code> method now, we
need to add an ampersand because the signature of <code>contains</code> is defined to take
a string slice.</p>
<p>Next, we add a call to <code>to_lowercase</code> on each <code>line</code> before we check whether it
contains <code>query</code> to lowercase all characters. Now that we’ve converted <code>line</code>
and <code>query</code> to lowercase, we’ll find matches no matter what the case of the
query is.</p>
<p>Let’s see if this implementation passes the tests:</p>
<pre><code class="language-text">running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Great! They passed. Now, let’s call the new <code>search_case_insensitive</code> function
from the <code>run</code> function. First, we’ll add a configuration option to the
<code>Config</code> struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors since we aren’t initializing this
field anywhere yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
#}</code></pre></pre>
<p>Note that we added the <code>case_sensitive</code> field that holds a Boolean. Next, we
need the <code>run</code> function to check the <code>case_sensitive</code> field’s value and use
that to decide whether to call the <code>search</code> function or the
<code>search_case_insensitive</code> function, as shown in Listing 12-22. Note this still
won’t compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::error::Error;
# use std::fs::{self, File};
# use std::io::prelude::*;
#
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# pub struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-22: Calling either <code>search</code> or
<code>search_case_insensitive</code> based on the value in <code>config.case_sensitive</code></span></p>
<p>Finally, we need to check for the environment variable. The functions for
working with environment variables are in the <code>env</code> module in the standard
library, so we want to bring that module into scope with a <code>use std::env;</code> line
at the top of <em>src/lib.rs</em>. Then we’ll use the <code>var</code> method from the <code>env</code>
module to check for an environment variable named <code>CASE_INSENSITIVE</code>, as shown
in Listing 12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }

// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-23: Checking for an environment variable named
<code>CASE_INSENSITIVE</code></span></p>
<p>Here, we create a new variable <code>case_sensitive</code>. To set its value, we call the
<code>env::var</code> function and pass it the name of the <code>CASE_INSENSITIVE</code> environment
variable. The <code>env::var</code> method returns a <code>Result</code> that will be the successful
<code>Ok</code> variant that contains the value of the environment variable if the
environment variable is set. It will return the <code>Err</code> variant if the
environment variable is not set.</p>
<p>We’re using the <code>is_err</code> method on the <code>Result</code> to check whether it’s an error
and therefore unset, which means it <em>should</em> do a case-sensitive search. If the
<code>CASE_INSENSITIVE</code> environment variable is set to anything, <code>is_err</code> will
return false and the program will perform a case-insensitive search. We don’t
care about the <em>value</em> of the environment variable, just whether it’s set or
unset, so we’re checking <code>is_err</code> rather than using <code>unwrap</code>, <code>expect</code>, or any
of the other methods we’ve seen on <code>Result</code>.</p>
<p>We pass the value in the <code>case_sensitive</code> variable to the <code>Config</code> instance so
the <code>run</code> function can read that value and decide whether to call <code>search</code> or
<code>search_case_insensitive</code>, as we implemented in Listing 12-22.</p>
<p>Let’s give it a try! First, we’ll run our program without the environment
variable set and with the query <code>to</code>, which should match any line that contains
the word “to” in all lowercase:</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Looks like that still works! Now, let’s run the program with <code>CASE_INSENSITIVE</code>
set to <code>1</code> but with the same query <code>to</code>.</p>
<p>If you’re using PowerShell, you will need to set the environment variable and
run the program in two commands rather than one:</p>
<pre><code class="language-text">$ $env:CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<p>We should get lines that contain “to” that might have uppercase letters:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excellent, we also got lines containing “To”! Our <code>minigrep</code> program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.</p>
<p>Some programs allow arguments <em>and</em> environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through either a command line argument or an environment
variable. Decide whether the command line argument or the environment variable
should take precedence if the program is run with one set to case sensitive and
one set to case insensitive.</p>
<p>The <code>std::env</code> module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.</p>
<a class="header" href="#writing-error-messages-to-standard-error-instead-of-standard-output" id="writing-error-messages-to-standard-error-instead-of-standard-output"><h2>Writing Error Messages to Standard Error Instead of Standard Output</h2></a>
<p>At the moment, we’re writing all of our output to the terminal using the
<code>println!</code> function. Most terminals provide two kinds of output: <em>standard
output</em> (<code>stdout</code>) for general information and <em>standard error</em> (<code>stderr</code>)
for error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.</p>
<p>The <code>println!</code> function is only capable of printing to standard output, so we
have to use something else to print to standard error.</p>
<a class="header" href="#checking-where-errors-are-written" id="checking-where-errors-are-written"><h3>Checking Where Errors Are Written</h3></a>
<p>First, let’s observe how the content printed by <code>minigrep</code> is currently being
written to standard output, including any error messages we want to write to
standard error instead. We’ll do that by redirecting the standard output stream
to a file while also intentionally causing an error. We won’t redirect the
standard error stream, so any content sent to standard error will continue to
display on the screen.</p>
<p>Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well-behaved:
we’re about to see that it saves the error message output to a file instead!</p>
<p>The way to demonstrate this behavior is by running the program with <code>&gt;</code> and the
filename, <em>output.txt</em>, that we want to redirect the standard output stream to.
We won’t pass any arguments, which should cause an error:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<p>The <code>&gt;</code> syntax tells the shell to write the contents of standard output to
<em>output.txt</em> instead of the screen. We didn’t see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what <em>output.txt</em> contains:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Yup, our error message is being printed to standard output. It’s much more
useful for error messages like this to be printed to standard error so only
data from a successful run ends up in the file. We’ll change that.</p>
<a class="header" href="#printing-errors-to-standard-error" id="printing-errors-to-standard-error"><h3>Printing Errors to Standard Error</h3></a>
<p>We’ll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, <code>main</code>. The standard library provides
the <code>eprintln!</code> macro that prints to the standard error stream, so let’s change
the two places we were calling <code>println!</code> to print errors to use <code>eprintln!</code>
instead.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Listing 12-24: Writing error messages to standard error
instead of standard output using <code>eprintln!</code></span></p>
<p>After changing <code>println!</code> to <code>eprintln!</code>, let’s run the program again in the
same way, without any arguments and redirecting standard output with <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Now we see the error onscreen and <em>output.txt</em> contains nothing, which is the
behavior we expect of command line programs.</p>
<p>Let’s run the program again with arguments that don’t cause an error but still
redirect standard output to a file, like so:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>We won’t see any output to the terminal, and <em>output.txt</em> will contain our
results:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>This demonstrates that we’re now using standard output for successful output
and standard error for error output as appropriate.</p>
<a class="header" href="#summary" id="summary"><h2>Summary</h2></a>
<p>This chapter recapped some of the major concepts you’ve learned so far and
covered how to perform common I/O operations in Rust. By using command line
arguments, files, environment variables, and the <code>eprintln!</code> macro for printing
errors, you’re now prepared to write command line applications. By using the
concepts in previous chapters, your code will be well organized, store data
effectively in the appropriate data structures, handle errors nicely, and be
well tested.</p>
<p>Next, we’ll explore some Rust features that were influenced by functional
languages: closures and iterators.</p>
<a class="header" href="#functional-language-features-iterators-and-closures" id="functional-language-features-iterators-and-closures"><h1>Functional Language Features: Iterators and Closures</h1></a>
<p>Rust’s design has taken inspiration from many existing languages and
techniques, and one significant influence is <em>functional programming</em>.
Programming in a functional style often includes using functions as values by
passing them in arguments, returning them from other functions, assigning them
to variables for later execution, and so forth.</p>
<p>In this chapter, we won’t debate the issue of what functional programming is or
isn’t but will instead discuss some features of Rust that are similar to
features in many languages often referred to as functional.</p>
<p>More specifically, we’ll cover:</p>
<ul>
<li><em>Closures</em>, a function-like construct you can store in a variable</li>
<li><em>Iterators</em>, a way of processing a series of elements</li>
<li>How to use these two features to improve the I/O project in Chapter 12</li>
<li>The performance of these two features (Spoiler alert: they’re faster than you
might think!)</li>
</ul>
<p>Other Rust features, such as pattern matching and enums, which we’ve covered in
other chapters, are influenced by the functional style as well. Mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, so we’ll devote this entire chapter to them.</p>
<a class="header" href="#closures-anonymous-functions-that-can-capture-their-environment" id="closures-anonymous-functions-that-can-capture-their-environment"><h2>Closures: Anonymous Functions that Can Capture Their Environment</h2></a>
<p>Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they’re defined. We’ll
demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<a class="header" href="#creating-an-abstraction-of-behavior-with-closures" id="creating-an-abstraction-of-behavior-with-closures"><h3>Creating an Abstraction of Behavior with Closures</h3></a>
<p>Let’s work on an example of a situation in which it’s useful to store a closure
to be executed later. Along the way, we’ll talk about the syntax of closures,
type inference, and traits.</p>
<p>Consider this hypothetical situation: we work at a startup that’s making an app
to generate custom exercise workout plans. The backend is written in Rust, and
the algorithm that generates the workout plan takes into account many factors,
such as the app user’s age, body mass index, exercise preferences, recent
workouts, and an intensity number they specify. The actual algorithm used isn’t
important in this example; what’s important is that this calculation takes a
few seconds. We want to call this algorithm only when we need to and only call
it once so we don’t make the user wait more than necessary.</p>
<p>We’ll simulate calling this hypothetical algorithm with the function
<code>simulated_expensive_calculation</code> shown in Listing 13-1, which will print
<code>calculating slowly...</code>, wait for two seconds, and then return whatever number
we passed in:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-1: A function to stand in for a hypothetical
calculation that takes about 2 seconds to run</span></p>
<p>Next is the <code>main</code> function, which contains the parts of the workout app
important for this example. This function represents the code that the app will
call when a user asks for a workout plan. Because the interaction with the
app’s frontend isn’t relevant to the use of closures, we’ll hardcode values
representing inputs to our program and print the outputs.</p>
<p>The required inputs are these:</p>
<ul>
<li>An intensity number from the user, which is specified when they request
a workout to indicate whether they want a low-intensity workout or a
high-intensity workout</li>
<li>A random number that will generate some variety in the workout plans</li>
</ul>
<p>The output will be the recommended workout plan. Listing 13-2 shows the <code>main</code>
function we’ll use:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
# fn generate_workout(intensity: u32, random_number: u32) {}
</code></pre></pre>
<p><span class="caption">Listing 13-2: A <code>main</code> function with hardcoded values to
simulate user input and random number generation</span></p>
<p>We’ve hardcoded the variable <code>simulated_user_specified_value</code> as 10 and the
variable <code>simulated_random_number</code> as 7 for simplicity’s sake; in an actual
program, we’d get the intensity number from the app frontend, and we’d use the
<code>rand</code> crate to generate a random number, as we did in the Guessing Game
example in Chapter 2. The <code>main</code> function calls a <code>generate_workout</code> function
with the simulated input values.</p>
<p>Now that we have the context, let’s get to the algorithm. The function
<code>generate_workout</code> in Listing 13-3 contains the business logic of the
app that we’re most concerned with in this example. The rest of the code
changes in this example will be made to this function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-3: The business logic that prints the workout
plans based on the inputs and calls to the <code>simulated_expensive_calculation</code>
function</span></p>
<p>The code in Listing 13-3 has multiple calls to the slow calculation function.
The first <code>if</code> block calls <code>simulated_expensive_calculation</code> twice, the <code>if</code>
inside the outer <code>else</code> doesn’t call it at all, and the code inside the
second <code>else</code> case calls it once.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>The desired behavior of the <code>generate_workout</code> function is to first check
whether the user wants a low-intensity workout (indicated by a number less
than 25) or a high-intensity workout (a number of 25 or greater).</p>
<p>Low-intensity workout plans will recommend a number of push-ups and sit-ups
based on the complex algorithm we’re simulating.</p>
<p>If the user wants a high-intensity workout, there’s some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration. If not, the user will get a number of
minutes of running based on the complex algorithm.</p>
<p>This code works the way the business wants it to now, but let’s say the data
science team decides that we need to make some changes to the way we call the
<code>simulated_expensive_calculation</code> function in the future. To simplify the
update when those changes happen, we want to refactor this code so it calls the
<code>simulated_expensive_calculation</code> function only once. We also want to cut the
place where we’re currently unnecessarily calling the function twice without
adding any other calls to that function in the process. That is, we don’t want
to call it if the result isn’t needed, and we still want to call it only once.</p>
<a class="header" href="#refactoring-using-functions" id="refactoring-using-functions"><h4>Refactoring Using Functions</h4></a>
<p>We could restructure the workout program in many ways. First, we’ll try
extracting the duplicated call to the <code>simulated_expensive_calculation</code>
function into a variable, as shown in Listing 13-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-4: Extracting the calls to
<code>simulated_expensive_calculation</code> to one place and storing the result in the
<code>expensive_result</code> variable</span></p>
<p>This change unifies all the calls to <code>simulated_expensive_calculation</code> and
solves the problem of the first <code>if</code> block unnecessarily calling the function
twice. Unfortunately, we’re now calling this function and waiting for the
result in all cases, which includes the inner <code>if</code> block that doesn’t use the
result value at all.</p>
<p>We want to define code in one place in our program, but only <em>execute</em> that
code where we actually need the result. This is a use case for closures!</p>
<a class="header" href="#refactoring-with-closures-to-store-code" id="refactoring-with-closures-to-store-code"><h4>Refactoring with Closures to Store Code</h4></a>
<p>Instead of always calling the <code>simulated_expensive_calculation</code> function before
the <code>if</code> blocks, we can define a closure and store the <em>closure</em> in a variable
rather than storing the result of the function call, as shown in Listing 13-5.
We can actually move the whole body of <code>simulated_expensive_calculation</code> within
the closure we’re introducing here:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
# expensive_closure(5);
#}</code></pre></pre>
<p><span class="caption">Listing 13-5: Defining a closure and storing it in the
<code>expensive_closure</code> variable</span></p>
<p>The closure definition comes after the <code>=</code> to assign it to the variable
<code>expensive_closure</code>. To define a closure, we start with a pair of vertical
pipes (<code>|</code>), inside which we specify the parameters to the closure; this syntax
was chosen because of its similarity to closure definitions in Smalltalk and
Ruby. This closure has one parameter named <code>num</code>: if we had more than one
parameter, we would separate them with commas, like <code>|param1, param2|</code>.</p>
<p>After the parameters, we place curly brackets that hold the body of the
closure—these are optional if the closure body is a single expression. The end
of the closure, after the curly brackets, needs a semicolon to complete the
<code>let</code> statement. The value returned from the last line in the closure body
(<code>num</code>) will be the value returned from the closure when it’s called, because
that line doesn’t end in a semicolon; just like in function bodies.</p>
<p>Note that this <code>let</code> statement means <code>expensive_closure</code> contains the
<em>definition</em> of an anonymous function, not the <em>resulting value</em> of calling the
anonymous function. Recall that we’re using a closure because we want to define
the code to call at one point, store that code, and call it at a later point;
the code we want to call is now stored in <code>expensive_closure</code>.</p>
<p>With the closure defined, we can change the code in the <code>if</code> blocks to call the
closure to execute the code and get the resulting value. We call a closure like
we do a function: we specify the variable name that holds the closure
definition and follow it with parentheses containing the argument values we
want to use, as shown in Listing 13-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-6: Calling the <code>expensive_closure</code> we’ve
defined</span></p>
<p>Now the expensive calculation is called in only one place, and we’re only
executing that code where we need the results.</p>
<p>However, we’ve reintroduced one of the problems from Listing 13-3: we’re still
calling the closure twice in the first <code>if</code> block, which will call the
expensive code twice and make the user wait twice as long as they need to. We
could fix this problem by creating a variable local to that <code>if</code> block to hold
the result of calling the closure, but closures provide us with another
solution. We’ll talk about that solution in a bit. But first let’s talk about
why there aren’t type annotations in the closure definition and the traits
involved with closures.</p>
<a class="header" href="#closure-type-inference-and-annotation" id="closure-type-inference-and-annotation"><h3>Closure Type Inference and Annotation</h3></a>
<p>Closures don’t require you to annotate the types of the parameters or the
return value like <code>fn</code> functions do. Type annotations are required on functions
because they’re part of an explicit interface exposed to your users. Defining
this interface rigidly is important for ensuring that everyone agrees on what
types of values a function uses and returns. But closures aren’t used in an
exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>Closures are usually short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler is
reliably able to infer the types of the parameters and the return type, similar
to how it’s able to infer the types of most variables.</p>
<p>Making programmers annotate the types in these small, anonymous functions would
be annoying and largely redundant with the information the compiler already has
available.</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for the closure we defined in Listing 13-5
would look like the definition shown in Listing 13-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
#}</code></pre></pre>
<p><span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span></p>
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. The following is a vertical comparison of the syntax for
the definition of a function that adds 1 to its parameter and a closure that
has the same behavior. We’ve added some spaces to line up the relevant parts.
This illustrates how closure syntax is similar to function syntax except for
the use of pipes and the amount of syntax that is optional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the brackets, which are
optional because the closure body has only one expression. These are all valid
definitions that will produce the same behavior when they’re called.</p>
<p>Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition: if
we then try to call the closure twice, using a <code>String</code> as an argument the
first time and a <code>u32</code> the second time, we’ll get an error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<p><span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span></p>
<p>The compiler gives us this error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked in to the closure in <code>example_closure</code>, and we get a type
error if we try to use a different type with the same closure.</p>
<a class="header" href="#storing-closures-using-generic-parameters-and-the-fn-traits" id="storing-closures-using-generic-parameters-and-the-fn-traits"><h3>Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</h3></a>
<p>Let’s return to our workout generation app. In Listing 13-6, our code was still
calling the expensive calculation closure more times than it needed to. One
option to solve this issue is to save the result of the expensive closure in a
variable for reuse and use the variable in each place we need the result,
instead of calling the closure again. However, this method could result in a
lot of repeated code.</p>
<p>Fortunately, another solution is available to us. We can create a struct that
will hold the closure and the resulting value of calling the closure. The
struct will execute the closure only if we need the resulting value, and it
will cache the resulting value so the rest of our code doesn’t have to be
responsible for saving and reusing the result. You may know this pattern as
<em>memoization</em> or <em>lazy evaluation</em>.</p>
<p>To make a struct that holds a closure, we need to specify the type of the
closure, because a struct definition needs to know the types of each of its
fields. Each closure instance has its own unique anonymous type: that is, even
if two closures have the same signature, their types are still considered
different. To define structs, enums, or function parameters that use closures,
we use generics and trait bounds, as we discussed in Chapter 10.</p>
<p>The <code>Fn</code> traits are provided by the standard library. All closures implement at
least one of the traits: <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>. We’ll discuss the
difference between these traits in the “Capturing the Environment with
Closures” section; in this example, we can use the <code>Fn</code> trait.</p>
<p>We add types to the <code>Fn</code> trait bound to represent the types of the parameters
and return values the closures must have to match this trait bound. In this
case, our closure has a parameter of type <code>u32</code> and returns a <code>u32</code>, so the
trait bound we specify is <code>Fn(u32) -&gt; u32</code>.</p>
<p>Listing 13-9 shows the definition of the <code>Cacher</code> struct that holds a closure
and an optional result value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-9: Defining a <code>Cacher</code> struct that holds a
closure in <code>calculation</code> and an optional result in <code>value</code></span></p>
<p>The <code>Cacher</code> struct has a <code>calculation</code> field of the generic type <code>T</code>. The
trait bounds on <code>T</code> specify that it’s a closure by using the <code>Fn</code> trait. Any
closure we want to store in the <code>calculation</code> field must have one <code>u32</code>
parameter (specified within the parentheses after <code>Fn</code>) and must return a
<code>u32</code> (specified after the <code>-&gt;</code>).</p>
<blockquote>
<p>Note: Functions can implement all three of the <code>Fn</code> traits too. If what we
want to do doesn’t require capturing a value from the environment, we can use
a function rather than a closure where we need something that implements an
<code>Fn</code> trait.</p>
</blockquote>
<p>The <code>value</code> field is of type <code>Option&lt;u32&gt;</code>. Before we execute the closure,
<code>value</code> will be <code>None</code>. When code using a <code>Cacher</code> asks for the <em>result</em> of the
closure, the <code>Cacher</code> will execute the closure at that time and store the
result within a <code>Some</code> variant in the <code>value</code> field. Then if the code asks for
the result of the closure again, instead of executing the closure again, the
<code>Cacher</code> will return the result held in the <code>Some</code> variant.</p>
<p>The logic around the <code>value</code> field we’ve just described is defined in Listing
13-10:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-10: The caching logic of <code>Cacher</code></span></p>
<p>We want <code>Cacher</code> to manage the struct fields’ values rather than letting the
calling code potentially change the values in these fields directly, so these
fields are private.</p>
<p>The <code>Cacher::new</code> function takes a generic parameter <code>T</code>, which we’ve defined
as having the same trait bound as the <code>Cacher</code> struct. Then <code>Cacher::new</code>
returns a <code>Cacher</code> instance that holds the closure specified in the
<code>calculation</code> field and a <code>None</code> value in the <code>value</code> field, because we haven’t
executed the closure yet.</p>
<p>When the calling code needs the result of evaluating the closure, instead of
calling the closure directly, it will call the <code>value</code> method. This method
checks whether we already have a resulting value in <code>self.value</code> in a <code>Some</code>;
if we do, it returns the value within the <code>Some</code> without executing the closure
again.</p>
<p>If <code>self.value</code> is <code>None</code>, the code calls the closure stored in
<code>self.calculation</code>, saves the result in <code>self.value</code> for future use, and
returns the value as well.</p>
<p>Listing 13-11 shows how we can use this <code>Cacher</code> struct in the function
<code>generate_workout</code> from Listing 13-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
# impl&lt;T&gt; Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
#
#     fn value(&amp;mut self, arg: u32) -&gt; u32 {
#         match self.value {
#             Some(v) =&gt; v,
#             None =&gt; {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             },
#         }
#     }
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-11: Using <code>Cacher</code> in the <code>generate_workout</code>
function to abstract away the caching logic</span></p>
<p>Instead of saving the closure in a variable directly, we save a new instance of
<code>Cacher</code> that holds the closure. Then, in each place we want the result, we
call the <code>value</code> method on the <code>Cacher</code> instance. We can call the <code>value</code>
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once.</p>
<p>Try running this program with the <code>main</code> function from Listing 13-2. Change the
values in the <code>simulated_user_specified_value</code> and <code>simulated_random_number</code>
variables to verify that in all the cases in the various <code>if</code> and <code>else</code>
blocks, <code>calculating slowly...</code> appears only once and only when needed. The
<code>Cacher</code> takes care of the logic necessary to ensure we aren’t calling the
expensive calculation more than we need to so <code>generate_workout</code> can focus on
the business logic.</p>
<a class="header" href="#limitations-of-the-cacher-implementation" id="limitations-of-the-cacher-implementation"><h3>Limitations of the <code>Cacher</code> Implementation</h3></a>
<p>Caching values is a generally useful behavior that we might want to use in
other parts of our code with different closures. However, there are two
problems with the current implementation of <code>Cacher</code> that would make reusing it
in different contexts difficult.</p>
<p>The first problem is that a <code>Cacher</code> instance assumes it will always get the
same value for the parameter <code>arg</code> to the <code>value</code> method. That is, this test of
<code>Cacher</code> will fail:</p>
<pre><code class="language-rust ignore panics">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<p>This test creates a new <code>Cacher</code> instance with a closure that returns the value
passed into it. We call the <code>value</code> method on this <code>Cacher</code> instance with an
<code>arg</code> value of 1 and then an <code>arg</code> value of 2, and we expect the call to
<code>value</code> with the <code>arg</code> value of 2 should return 2.</p>
<p>Run this test with the <code>Cacher</code> implementation in Listing 13-9 and Listing
13-10, and the test will fail on the <code>assert_eq!</code> with this message:</p>
<pre><code class="language-text">thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/main.rs
</code></pre>
<p>The problem is that the first time we called <code>c.value</code> with 1, the <code>Cacher</code>
instance saved <code>Some(1)</code> in <code>self.value</code>. Thereafter, no matter what we pass in
to the <code>value</code> method, it will always return 1.</p>
<p>Try modifying <code>Cacher</code> to hold a hash map rather than a single value. The keys
of the hash map will be the <code>arg</code> values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether <code>self.value</code> directly has a <code>Some</code> or a <code>None</code> value, the
<code>value</code> function will look up the <code>arg</code> in the hash map and return the value if
it’s present. If it’s not present, the <code>Cacher</code> will call the closure and save
the resulting value in the hash map associated with its <code>arg</code> value.</p>
<p>The second problem with the current <code>Cacher</code> implementation is that it only
accepts closures that take one parameter of type <code>u32</code> and return a <code>u32</code>. We
might want to cache the results of closures that take a string slice and return
<code>usize</code> values, for example. To fix this issue, try introducing more generic
parameters to increase the flexibility of the <code>Cacher</code> functionality.</p>
<a class="header" href="#capturing-the-environment-with-closures" id="capturing-the-environment-with-closures"><h3>Capturing the Environment with Closures</h3></a>
<p>In the workout generator example, we only used closures as inline anonymous
functions. However, closures have an additional capability that functions don’t
have: they can capture their environment and access variables from the scope in
which they’re defined.</p>
<p>Listing 13-12 has an example of a closure stored in the <code>equal_to_x</code> variable
that uses the <code>x</code> variable from the closure’s surrounding environment:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span></p>
<p>Here, even though <code>x</code> is not one of the parameters of <code>equal_to_x</code>, the
<code>equal_to_x</code> closure is allowed to use the <code>x</code> variable that’s defined in the
same scope that <code>equal_to_x</code> is defined in.</p>
<p>We can’t do the same with functions; if we try with the following example, our
code won’t compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<p>We get an error:</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ...
} closure form instead
 --&gt; src/main.rs
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<p>The compiler even reminds us that this only works with closures!</p>
<p>When a closure captures a value from its environment, it uses memory to store
the values for use in the closure body. This use of memory is overhead that we
don’t want to pay in more common cases where we want to execute code that
doesn’t capture its environment. Because functions are never allowed to capture
their environment, defining and using functions will never incur this overhead.</p>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably. These are encoded in the
three <code>Fn</code> traits as follows:</p>
<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known
as the closure’s <em>environment</em>. To consume the captured variables, the
closure must take ownership of these variables and move them into the closure
when it is defined. The <code>Once</code> part of the name represents the fact that the
closure can’t take ownership of the same variables more than once, so it can
be called only once.</li>
<li><code>FnMut</code> can change the environment because it mutably borrows values.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
</ul>
<p>When you create a closure, Rust infers which trait to use based on how the
closure uses the values from the environment. All closures implement <code>FnOnce</code>
because they can all be called at least once. Closures that don’t move the
captured variables also implement <code>FnMut</code>, and closures that don’t need mutable
access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the
<code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait)
because the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If you want to force the closure to take ownership of the values it uses in the
environment, you can use the <code>move</code> keyword before the parameter list. This
technique is mostly useful when passing a closure to a new thread to move the
data so it’s owned by the new thread.</p>
<p>We’ll have more examples of <code>move</code> closures in Chapter 16 when we talk about
concurrency. For now, here’s the code from Listing 13-12 with the <code>move</code>
keyword added to the closure definition and using vectors instead of integers,
because integers can be copied rather than moved; note that this code will not
yet compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>We receive the following error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
  implement the `Copy` trait
</code></pre>
<p>The <code>x</code> value is moved into the closure when the closure is defined, because we
added the <code>move</code> keyword. The closure then has ownership of <code>x</code>, and <code>main</code>
isn’t allowed to use <code>x</code> anymore in the <code>println!</code> statement. Removing
<code>println!</code> will fix this example.</p>
<p>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start
with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based
on what happens in the closure body.</p>
<p>To illustrate situations where closures that can capture their environment are
useful as function parameters, let’s move on to our next topic: iterators.</p>
<a class="header" href="#processing-a-series-of-items-with-iterators" id="processing-a-series-of-items-with-iterators"><h2>Processing a Series of Items with Iterators</h2></a>
<p>The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don’t
have to reimplement that logic yourself.</p>
<p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector <code>v1</code> by calling
the <code>iter</code> method defined on <code>Vec</code>. This code by itself doesn’t do anything
useful.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
#}</code></pre></pre>
<p><span class="caption">Listing 13-13: Creating an iterator</span></p>
<p>Once we’ve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with <code>for</code> loops to execute some code on
each item, although we glossed over what the call to <code>iter</code> did until now.</p>
<p>The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the <code>for</code> loop. The iterator is stored in the <code>v1_iter</code>
variable, and no iteration takes place at that time. When the <code>for</code> loop is
called using the iterator in <code>v1_iter</code>, each element in the iterator is used in
one iteration of the loop, which prints out each value.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-14: Using an iterator in a <code>for</code> loop</span></p>
<p>In languages that don’t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.</p>
<p>Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let’s examine how iterators do that.</p>
<a class="header" href="#the-iterator-trait-and-the-next-method" id="the-iterator-trait-and-the-next-method"><h3>The <code>Iterator</code> Trait and the <code>next</code> Method</h3></a>
<p>All iterators implement a trait named <code>Iterator</code> that is defined in the
standard library. The definition of the trait looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
#}</code></pre></pre>
<p>Notice this definition uses some new syntax: <code>type Item</code> and <code>Self::Item</code>,
which are defining an <em>associated type</em> with this trait. We’ll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the <code>Iterator</code> trait requires that you also define
an <code>Item</code> type, and this <code>Item</code> type is used in the return type of the <code>next</code>
method. In other words, the <code>Item</code> type will be the type returned from the
iterator.</p>
<p>The <code>Iterator</code> trait only requires implementors to define one method: the
<code>next</code> method, which returns one item of the iterator at a time wrapped in
<code>Some</code> and, when iteration is over, returns <code>None</code>.</p>
<p>We can call the <code>next</code> method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to <code>next</code> on the iterator created
from the vector:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-15: Calling the <code>next</code> method on an
iterator</span></p>
<p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code <em>consumes</em>, or uses up, the
iterator. Each call to <code>next</code> eats up an item from the iterator. We didn’t need
to make <code>v1_iter</code> mutable when we used a <code>for</code> loop because the loop took
ownership of <code>v1_iter</code> and made it mutable behind the scenes.</p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable
references to the values in the vector. The <code>iter</code> method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of
<code>iter</code>. Similarly, if we want to iterate over mutable references, we can call
<code>iter_mut</code> instead of <code>iter</code>.</p>
<a class="header" href="#methods-that-consume-the-iterator" id="methods-that-consume-the-iterator"><h3>Methods that Consume the Iterator</h3></a>
<p>The <code>Iterator</code> trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the <code>Iterator</code>
trait. Some of these methods call the <code>next</code> method in their definition, which
is why you’re required to implement the <code>next</code> method when implementing the
<code>Iterator</code> trait.</p>
<p>Methods that call <code>next</code> are called <em>consuming adaptors</em>, because calling them
uses up the iterator. One example is the <code>sum</code> method, which takes ownership of
the iterator and iterates through the items by repeatedly calling <code>next</code>, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the <code>sum</code> method:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-16: Calling the <code>sum</code> method to get the total
of all items in the iterator</span></p>
<p>We aren’t allowed to use <code>v1_iter</code> after the call to <code>sum</code> because <code>sum</code> takes
ownership of the iterator we call it on.</p>
<a class="header" href="#methods-that-produce-other-iterators" id="methods-that-produce-other-iterators"><h3>Methods that Produce Other Iterators</h3></a>
<p>Other methods defined on the <code>Iterator</code> trait, known as <em>iterator adaptors</em>,
allow you to change iterators into different kinds of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, you have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.</p>
<p>Listing 13-17 shows an example of calling the iterator adaptor method <code>map</code>,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
#}</code></pre></pre>
<p><span class="caption">Listing 13-17: Calling the iterator adaptor <code>map</code> to
create a new iterator</span></p>
<p>The warning we get is this:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>The code in Listing 13-17 doesn’t do anything; the closure we’ve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.</p>
<p>To fix this and consume the iterator, we’ll use the <code>collect</code> method, which we
used in Chapter 12 with <code>env::args</code> in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.</p>
<p>In Listing 13-18, we collect the results of iterating over the iterator that’s
returned from the call to <code>map</code> into a vector. This vector will end up
containing each item from the original vector incremented by 1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
#}</code></pre></pre>
<p><span class="caption">Listing 13-18: Calling the <code>map</code> method to create a new
iterator and then calling the <code>collect</code> method to consume the new iterator and
create a vector</span></p>
<p>Because <code>map</code> takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the <code>Iterator</code> trait
provides.</p>
<a class="header" href="#using-closures-that-capture-their-environment" id="using-closures-that-capture-their-environment"><h3>Using Closures that Capture Their Environment</h3></a>
<p>Now that we’ve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the <code>filter</code> iterator adaptor.
The <code>filter</code> method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns <code>true</code>, the value
will be included in the iterator produced by <code>filter</code>. If the closure returns
<code>false</code>, the value won’t be included in the resulting iterator.</p>
<p>In Listing 13-19, we use <code>filter</code> with a closure that captures the <code>shoe_size</code>
variable from its environment to iterate over a collection of <code>Shoe</code> struct
instances. It will return only shoes that are the specified size.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-19: Using the <code>filter</code> method with a closure
that captures <code>shoe_size</code></span></p>
<p>The <code>shoes_in_my_size</code> function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.</p>
<p>In the body of <code>shoes_in_my_size</code>, we call <code>into_iter</code> to create an iterator
that takes ownership of the vector. Then we call <code>filter</code> to adapt that
iterator into a new iterator that only contains elements for which the closure
returns <code>true</code>.</p>
<p>The closure captures the <code>shoe_size</code> parameter from the environment and
compares the value with each shoe’s size, keeping only shoes of the size
specified. Finally, calling <code>collect</code> gathers the values returned by the
adapted iterator into a vector that’s returned by the function.</p>
<p>The test shows that when we call <code>shoes_in_my_size</code>, we get back only shoes
that have the same size as the value we specified.</p>
<a class="header" href="#creating-our-own-iterators-with-the-iterator-trait" id="creating-our-own-iterators-with-the-iterator-trait"><h3>Creating Our Own Iterators with the <code>Iterator</code> Trait</h3></a>
<p>We’ve shown that you can create an iterator by calling <code>iter</code>, <code>into_iter</code>, or
<code>iter_mut</code> on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the <code>Iterator</code> trait on your own
types. As previously mentioned, the only method you’re required to provide a
definition for is the <code>next</code> method. Once you’ve done that, you can use all
other methods that have default implementations provided by the <code>Iterator</code>
trait!</p>
<p>To demonstrate, let’s create an iterator that will only ever count from 1 to 5.
First, we’ll create a struct to hold some values. Then we’ll make this struct
into an iterator by implementing the <code>Iterator</code> trait and using the values in
that implementation.</p>
<p>Listing 13-20 has the definition of the <code>Counter</code> struct and an associated
<code>new</code> function to create instances of <code>Counter</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-20: Defining the <code>Counter</code> struct and a <code>new</code>
function that creates instances of <code>Counter</code> with an initial value of 0 for
<code>count</code></span></p>
<p>The <code>Counter</code> struct has one field named <code>count</code>. This field holds a <code>u32</code>
value that will keep track of where we are in the process of iterating from 1
to 5. The <code>count</code> field is private because we want the implementation of
<code>Counter</code> to manage its value. The <code>new</code> function enforces the behavior of
always starting new instances with a value of 0 in the <code>count</code> field.</p>
<p>Next, we’ll implement the <code>Iterator</code> trait for our <code>Counter</code> type by defining
the body of the <code>next</code> method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-21: Implementing the <code>Iterator</code> trait on our
<code>Counter</code> struct</span></p>
<p>We set the associated <code>Item</code> type for our iterator to <code>u32</code>, meaning the
iterator will return <code>u32</code> values. Again, don’t worry about associated types
yet, we’ll cover them in Chapter 19.</p>
<p>We want our iterator to add 1 to the current state, so we initialized <code>count</code>
to 0 so it would return 1 first. If the value of <code>count</code> is less than 6, <code>next</code>
will return the current value wrapped in <code>Some</code>, but if <code>count</code> is 6 or higher,
our iterator will return <code>None</code>.</p>
<a class="header" href="#using-our-counter-iterators-next-method" id="using-our-counter-iterators-next-method"><h4>Using Our <code>Counter</code> Iterator’s <code>next</code> Method</h4></a>
<p>Once we’ve implemented the <code>Iterator</code> trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
<code>Counter</code> struct by calling the <code>next</code> method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Iterator for Counter {
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         self.count += 1;
#
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-22: Testing the functionality of the <code>next</code>
method implementation</span></p>
<p>This test creates a new <code>Counter</code> instance in the <code>counter</code> variable and then
calls <code>next</code> repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.</p>
<a class="header" href="#using-other-iterator-trait-methods" id="using-other-iterator-trait-methods"><h4>Using Other <code>Iterator</code> Trait Methods</h4></a>
<p>We implemented the <code>Iterator</code> trait by defining the <code>next</code> method, so we
can now use any <code>Iterator</code> trait method’s default implementations as defined in
the standard library, because they all use the <code>next</code> method’s functionality.</p>
<p>For example, if for some reason we wanted to take the values produced by an
instance of <code>Counter</code>, pair them with values produced by another <code>Counter</code>
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Counter {
#     fn new() -&gt; Counter {
#         Counter { count: 0 }
#     }
# }
#
# impl Iterator for Counter {
#     // Our iterator will produce u32s
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         // increment our count. This is why we started at zero.
#         self.count += 1;
#
#         // check to see if we've finished counting or not.
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-23: Using a variety of <code>Iterator</code> trait
methods on our <code>Counter</code> iterator</span></p>
<p>Note that <code>zip</code> produces only four pairs; the theoretical fifth pair <code>(5, None)</code> is never produced because <code>zip</code> returns <code>None</code> when either of its input
iterators return <code>None</code>.</p>
<p>All of these method calls are possible because we specified how the <code>next</code>
method works, and the standard library provides default implementations for
other methods that call <code>next</code>.</p>
<a class="header" href="#improving-our-io-project" id="improving-our-io-project"><h2>Improving Our I/O Project</h2></a>
<p>With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Let’s look at how iterators can improve our implementation of the
<code>Config::new</code> function and the <code>search</code> function.</p>
<a class="header" href="#removing-a-clone-using-an-iterator" id="removing-a-clone-using-an-iterator"><h3>Removing a <code>clone</code> Using an Iterator</h3></a>
<p>In Listing 12-6, we added code that took a slice of <code>String</code> values and created
an instance of the <code>Config</code> struct by indexing into the slice and cloning the
values, allowing the <code>Config</code> struct to own those values. In Listing 13-24,
we’ve reproduced the implementation of the <code>Config::new</code> function as it was in
Listing 12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre>
<p><span class="caption">Listing 13-24: Reproduction of the <code>Config::new</code> function
from Listing 12-23</span></p>
<p>At the time, we said not to worry about the inefficient <code>clone</code> calls because
we would remove them in the future. Well, that time is now!</p>
<p>We needed <code>clone</code> here because we have a slice with <code>String</code> elements in the
parameter <code>args</code>, but the <code>new</code> function doesn’t own <code>args</code>. To return
ownership of a <code>Config</code> instance, we had to clone the values from the <code>query</code>
and <code>filename</code> fields of <code>Config</code> so the <code>Config</code> instance can own its values.</p>
<p>With our new knowledge about iterators, we can change the <code>new</code> function to
take ownership of an iterator as its argument instead of borrowing a slice.
We’ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
<code>Config::new</code> function is doing because the iterator will access the values.</p>
<p>Once <code>Config::new</code> takes ownership of the iterator and stops using indexing
operations that borrow, we can move the <code>String</code> values from the iterator into
<code>Config</code> rather than calling <code>clone</code> and making a new allocation.</p>
<a class="header" href="#using-the-returned-iterator-directly" id="using-the-returned-iterator-directly"><h4>Using the Returned Iterator Directly</h4></a>
<p>Open your I/O project’s <em>src/main.rs</em> file, which should look like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p>We’ll change the start of the <code>main</code> function that we had in Listing 12-24 at
to the code in Listing 13-25. This won’t compile until we update <code>Config::new</code>
as well.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p><span class="caption">Listing 13-25: Passing the return value of <code>env::args</code> to
<code>Config::new</code></span></p>
<p>The <code>env::args</code> function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to <code>Config::new</code>, now
we’re passing ownership of the iterator returned from <code>env::args</code> to
<code>Config::new</code> directly.</p>
<p>Next, we need to update the definition of <code>Config::new</code>. In your I/O project’s
<em>src/lib.rs</em> file, let’s change the signature of <code>Config::new</code> to look like
Listing 13-26. This still won’t compile because we need to update the function
body.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
</code></pre>
<p><span class="caption">Listing 13-26: Updating the signature of <code>Config::new</code> to
expect an iterator</span></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the
type of the iterator it returns is <code>std::env::Args</code>. We’ve updated the
signature of the <code>Config::new</code> function so the parameter <code>args</code> has the type
<code>std::env::Args</code> instead of <code>&amp;[String]</code>. Because we’re taking ownership of
<code>args</code> and we’ll be mutating <code>args</code> by iterating over it, we can add the <code>mut</code>
keyword into the specification of the <code>args</code> parameter to make it mutable.</p>
<a class="header" href="#using-iterator-trait-methods-instead-of-indexing" id="using-iterator-trait-methods-instead-of-indexing"><h4>Using <code>Iterator</code> Trait Methods Instead of Indexing</h4></a>
<p>Next, we’ll fix the body of <code>Config::new</code>. The standard library documentation
also mentions that <code>std::env::Args</code> implements the <code>Iterator</code> trait, so we know
we can call the <code>next</code> method on it! Listing 13-27 updates the code from
Listing 12-23 to use the <code>next</code> method:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
# use std::env;
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre></pre>
<p><span class="caption">Listing 13-27: Changing the body of <code>Config::new</code> to use
iterator methods</span></p>
<p>Remember that the first value in the return value of <code>env::args</code> is the name of
the program. We want to ignore that and get to the next value, so first we call
<code>next</code> and do nothing with the return value. Second, we call <code>next</code> to get the
value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns a
<code>Some</code>, we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means
not enough arguments were given and we return early with an <code>Err</code> value. We do
the same thing for the <code>filename</code> value.</p>
<a class="header" href="#making-code-clearer-with-iterator-adaptors" id="making-code-clearer-with-iterator-adaptors"><h3>Making Code Clearer with Iterator Adaptors</h3></a>
<p>We can also take advantage of iterators in the <code>search</code> function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listing 13-28: The implementation of the <code>search</code>
function from Listing 12-19</span></p>
<p>We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate <code>results</code> vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldn’t have to manage
concurrent access to the <code>results</code> vector. Listing 13-29 shows this change:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<p><span class="caption">Listing 13-29: Using iterator adaptor methods in the
implementation of the <code>search</code> function</span></p>
<p>Recall that the purpose of the <code>search</code> function is to return all lines in
<code>contents</code> that contain the <code>query</code>. Similar to the <code>filter</code> example in Listing
13-19, this code uses the <code>filter</code> adaptor to keep only the lines that
<code>line.contains(query)</code> returns <code>true</code> for. We then collect the matching lines
into another vector with <code>collect</code>. Much simpler! Feel free to make the same
change to use iterator methods in the <code>search_case_insensitive</code> function as
well.</p>
<p>The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. It’s a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so it’s easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.</p>
<p>But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Let’s talk about
performance.</p>
<a class="header" href="#comparing-performance-loops-vs-iterators" id="comparing-performance-loops-vs-iterators"><h2>Comparing Performance: Loops vs. Iterators</h2></a>
<p>To determine whether to use loops or iterators, you need to know which version
of our <code>search</code> functions is faster: the version with an explicit <code>for</code> loop or
the version with iterators.</p>
<p>We ran a benchmark by loading the entire contents of <em>The Adventures of
Sherlock Holmes</em> by Sir Arthur Conan Doyle into a <code>String</code> and looking for the
word <em>the</em> in the contents. Here are the results of the benchmark on the
version of <code>search</code> using the <code>for</code> loop and the version using iterators:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>The iterator version was slightly faster! We won’t explain the benchmark code
here, because the point is not to prove that the two versions are equivalent
but to get a general sense of how these two implementations compare
performance-wise.</p>
<p>For a more comprehensive benchmark, you should check using various texts of
various sizes as the <code>contents</code>, different words and words of different lengths
as the <code>query</code>, and all kinds of other variations. The point is this:
iterators, although a high-level abstraction, get compiled down to roughly the
same code as if you’d written the lower-level code yourself. Iterators are one
of Rust’s <em>zero-cost abstractions</em>, by which we mean using the abstraction
imposes no additional runtime overhead. This is analogous to how Bjarne
Stroustrup, the original designer and implementor of C++, defines
<em>zero-overhead</em> in “Foundations of C++” (2012):</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you
don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
code any better.</p>
</blockquote>
<p>As another example, the following code is taken from an audio decoder. The
decoding algorithm uses the linear prediction mathematical operation to
estimate future values based on a linear function of the previous samples. This
code uses an iterator chain to do some math on three variables in scope: a
<code>buffer</code> slice of data, an array of 12 <code>coefficients</code>, and an amount by which
to shift data in <code>qlp_shift</code>. We’ve declared the variables within this example
but not given them any values; although this code doesn’t have much meaning
outside of its context, it’s still a concise, real-world example of how Rust
translates high-level ideas to low-level code.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>To calculate the value of <code>prediction</code>, this code iterates through each of the
12 values in <code>coefficients</code> and uses the <code>zip</code> method to pair the coefficient
values with the previous 12 values in <code>buffer</code>. Then, for each pair, we
multiply the values together, sum all the results, and shift the bits in the
sum <code>qlp_shift</code> bits to the right.</p>
<p>Calculations in applications like audio decoders often prioritize performance
most highly. Here, we’re creating an iterator, using two adaptors, and then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly you’d write by hand.
There’s no loop at all corresponding to the iteration over the values in
<code>coefficients</code>: Rust knows that there are 12 iterations, so it “unrolls” the
loop. <em>Unrolling</em> is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.</p>
<p>All of the coefficients get stored in registers, which means accessing the
values is very fast. There are no bounds checks on the array access at runtime.
All these optimizations that Rust is able to apply make the resulting code
extremely efficient. Now that you know this, you can use iterators and closures
without fear! They make code seem like it’s higher level but don’t impose a
runtime performance penalty for doing so.</p>
<a class="header" href="#summary-1" id="summary-1"><h2>Summary</h2></a>
<p>Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust’s capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rust’s goal to strive to provide zero-cost abstractions.</p>
<p>Now that we’ve improved the expressiveness of our I/O project, let’s look at
some more features of <code>cargo</code> that will help us share the project with the
world.</p>
<a class="header" href="#cargoとcratesioについてより詳しく" id="cargoとcratesioについてより詳しく"><h1>CargoとCrates.ioについてより詳しく</h1></a>
<p>これまでは、Cargoの最も基本的な機能だけを使ってコードを構築、実行、テストしましたが、それ以上のことができます。この章では、次のような他の高度な機能について説明します。</p>
<ul>
<li>リリースプロファイルを使用してビルドをカスタマイズする</li>
<li><a href="https://crates.io">crates.io</a><!-- ignore -->にライブラリを公開する</li>
<li>ワークスペースで大きなプロジェクトを整理する</li>
<li><a href="https://crates.io">crates.io</a><!-- ignore -->のバイナリをインストールする</li>
<li>カスタムコマンドを使用してCargoを拡張する</li>
</ul>
<p>Cargoは、この章で扱っている以上に機能するので、その機能の詳細については、<a href="https://doc.rust-lang.org/cargo/">この文書</a>を参照してください。</p>
<a class="header" href="#aリリースプロファイルでビルドをカスタマイズする" id="aリリースプロファイルでビルドをカスタマイズする"><h2>リリースプロファイルでビルドをカスタマイズする</h2></a>
<p>Rustにおいて<em>リリースプロファイル</em>とは、プログラマーがコードをコンパイルするためのさまざまなオプションをより詳細に制御できるように、構成が異なる事前定義されたカスタマイズ可能なプロファイルです。各プロファイルは他のプロファイルとは独立して構成されています。</p>
<p>Cargoには2つの主要なプロファイルがあります。<code>cargo build</code>を実行する際にCargoが使用する<code>dev</code>プロファイルと<code>cargo build --release</code>を実行する際に使用する<code>release</code>プロファイルです。<code>dev</code>プロファイルは開発のための適切なデフォルトで定義され、<code>release</code>プロファイルはリリースビルドに適切なデフォルトを持っています。</p>
<p>これらのプロファイル名は、ビルドの出力で馴染みのあるものかもしれません。</p>
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<p>このビルド出力に表示される<code>dev</code>と<code>release</code>は、コンパイラが異なるプロファイルを使用していることを示しています。</p>
<p>Cargoには、プロジェクトの<em>Cargo.toml</em>ファイルに<code>[profile.*]</code>セクションがない場合に適用される各プロファイルのデフォルト設定があります。カスタマイズしたいプロファイルに対して<code>[profile.*]</code>セクションを追加することで、デフォルト設定のサブセットを上書きすることができます。例えば、<code>dev</code>と<code>release</code>プロファイルの<code>opt-level</code>設定のデフォルト値は次のとおりです。</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p><code>opt-level</code>設定は、Rustがコードに適用する最適化の回数を0〜3の範囲で制御します。さらに最適化を適用するとコンパイル時間が延びるので、コードを頻繁に開発してコンパイルする場合は、結果として得られるコードが遅く実行されても、コンパイルがより速くなります。これが<code>dev</code>のデフォルト<code>opt-level</code>が<code>0</code>である理由です。コードをリリースする準備ができたら、コンパイルにもっと時間を費やすのが最善です。一度だけリリースモードでコンパイルしますが、コンパイルされたプログラムは何度も実行されるため、リリースモードでは実行速度が遅いコードのコンパイル時間が長くなります。そのため、 <code>release</code>プロファイルのデフォルトの<code>opt-level</code>は <code>3</code>です。</p>
<p><em>Cargo.toml</em>に別の値を追加することで、デフォルト設定を上書きすることができます。たとえば、開発プロファイルで最適化レベル1を使用する場合は、プロジェクトの<em>Cargo.toml</em>ファイルに次の2行を追加できます。</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>このコードはデフォルト設定の<code>0</code>を無効にします。今度は<code>cargo build</code>を実行すると、Cargoは<code>dev</code>プロファイルのデフォルトと<code>opt-level</code>へのカスタマイズを使用します。<code>opt-level</code>を<code>1</code>に設定しているので、Cargoはデフォルトよりも多くの最適化を適用しますが、リリースビルドよりも多くは適用しません。</p>
<p>各プロファイルの設定オプションとデフォルトの一覧については、<a href="https://doc.rust-lang.org/cargo/">Cargoのドキュメント</a>を参照してください。</p>
<a class="header" href="#cratesioにクレートを公開する" id="cratesioにクレートを公開する"><h2>Crates.ioにクレートを公開する</h2></a>
<p>私たちはプロジェクトの依存関係として<a href="https://crates.io">crates.io</a><!--ignore-->のパッケージを使用しましたが、独自のパッケージを公開して他の人とコードを共有することもできます。<a href="https://crates.io">crates.io</a>のcrateレジストリは、パッケージのソースコードを配布するので、主にオープンソースのコードをホストします。</p>
<p>RustとCargoには、公開されたパッケージを人々が使いやすく見つけやすくするための機能があります。これらの機能のいくつかについて次に説明し、次にパッケージを公開する方法を説明します。</p>
<a class="header" href="#a役に立つドキュメンテーションコメントを行う" id="a役に立つドキュメンテーションコメントを行う"><h3>役に立つドキュメンテーションコメントを行う</h3></a>
<p>パッケージを正確にドキュメント化することで、他のユーザーがいつ、どのように使用するのかを知ることができますので、時間をかけてドキュメントを書く価値があります。第3章では、2つのスラッシュ<code>//</code>を使って錆コードをコメントする方法について説明しました。Rustには、HTMLドキュメントを生成する<em>ドキュメンテーションコメント</em>として知られている、ドキュメントのための特定の種類のコメントもあります。HTMLには、レートの実装方法とは対照的に、クレートを使用する方法を知りたいプログラマー向けのパブリックAPI項目のドキュメントコメントの内容が表示されます。</p>
<p>ドキュメントコメントでは、2つではなく、3つのスラッシュ<code>///</code>を使用し、テキストの書式設定のためのMarkdown記法をサポートしています。ドキュメント化している項目の直前にドキュメンテーションコメントを置いてください。リスト14-1は、<code>my_crate</code>という名前のクレート内の<code>add_one</code>関数のドキュメンテーションコメントを示しています。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, my_crate::add_one(5));
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">リスト 14-1: 関数のドキュメンテーションコメント</span></p>
<p>ここでは、<code>add_one</code>関数が何をするのかを説明し、<code>Examples</code>という見出しでセクションを開始し、<code>add_one</code>関数の使い方を示すコードを提供します。<code>cargo doc</code>を実行することによって、このドキュメンテーションコメントからHTML文書を生成することができます。このコマンドはRustと一緒に配布された<code>rustdoc</code>ツールを実行し、生成されたHTMLドキュメントを<em>target/doc</em>ディレクトリに置きます。</p>
<p>利便性のために、<code>cargo doc --open</code>を実行すると、現在のクレートのドキュメント（クレートの依存関係のすべてのドキュメント）のHTMLがビルドされ、Webブラウザで結果が開きます。<code>add_one</code>関数に移動すると、図14-1に示すように、ドキュメンテーションコメントのテキストがどのように表示されるのかがわかります：</p>
<p><img alt="add_one関数のHTMLドキュメント" src="img/trpl14-01.png" class="center" /></p>
<p><span class="caption">図 14-1: <code>add_one</code>関数のHTMLドキュメント</span></p>
<a class="header" href="#aよく使われるセクション" id="aよく使われるセクション"><h4>よく使われるセクション</h4></a>
<p>リスト14-1の <code>#Examples</code>マークダウン見出しを使って、HTMLに&quot;Examples&quot;というタイトルのセクションを作成しました。ここでは、よく使用するセクションをいくつか紹介します。</p>
<ul>
<li><strong>Panics</strong>: ドキュメント化されている機能がパニックに陥る可能性のあるシナリオ。プログラムのパニックを望まない機能の呼び出し側は、これらの状況で関数を呼び出さないようにする必要があります。</li>
<li><strong>Errors</strong>:関数が結果を返す場合、発生する可能性があるエラーの種類とその条件が返される条件を記述することで、さまざまな種類のエラーを処理するコードをさまざまな方法で記述できるようになります。</li>
<li><strong>Safety</strong>: 関数が呼び出すのに<code>unsafe</code>(<code>unsafe</code>については第19章で議論します)なら、関数が安全でない理由を説明し、関数が呼び出し側が維持することを期待する不変量をカバーするセクションが存在するはずです。</li>
</ul>
<p>ほとんどのドキュメンテーションコメントはこれらのセクションのすべてを必要としませんが、コードを呼び出す人々が知りたいと思うコードの面を思い出させる良いチェックリストです。</p>
<a class="header" href="#aテストとしてのドキュメンテーションコメント" id="aテストとしてのドキュメンテーションコメント"><h4>テストとしてのドキュメンテーションコメント</h4></a>
<p>ドキュメンテーションコメントにサンプルコードブロックを追加すると、ライブラリの使い方を示すのに役立ちます。そうすることで追加のメリットが得られます。<code>cargo test</code>を実行すると、ドキュメンテーションのコード例がテストとして実行されます。例を持つドキュメントより優れているものはありません。しかし、ドキュメントが書かれてからコードが変更されたため、動作しない例よりも悪いものはありません。リスト14-1の<code>add_one</code>関数のドキュメンテーションで<code>cargo test</code>を実行すると、次のようなテスト結果のセクションが表示されます。</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>さて、例の<code>assert_eq!</code>がパニックするように、関数か例を変更し、再度<code>cargo test</code>を実行したら、docテストが、例とコードがお互いに同期されていないことを捕捉するところを目撃するでしょう。</p>
<a class="header" href="#a含まれている要素にコメントする" id="a含まれている要素にコメントする"><h4>含まれている要素にコメントする</h4></a>
<p>ドキュメンテーションコメントの別のスタイル<code>//!</code>は、コメントに続く項目にドキュメントを追加するのではなく、コメントを含む項目にドキュメントを追加します。通常、クレートルートファイル（慣習的に<em>src/lib.rs</em>）内またはこれらのドキュメントのコメントを使用して、クレートまたはモジュール全体をドキュメント化します。</p>
<p>たとえば、<code>add_one</code>関数を含む<code>my_crate</code>クレートの目的を説明するドキュメントを追加したい場合は、リスト14-2のように<code>//!</code>で始まるドキュメンテーションコメントを<em>src/lib.rs</em>ファイルの先頭につけることができます。</p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
</code></pre>
<p><span class="caption">リスト 14-2: 全体として<code>my_crate</code>クレートにドキュメントをつける</span></p>
<p><code>//!</code>で始まる最後の行の後にコードがないことに注目してください。<code>///</code>ではなく<code>//!</code>でコメントを開始したので、このコメントの後に続く項目ではなく、このコメントを含む項目をドキュメント化しています。この場合、このコメントを含む項目はクレートルートである<em>src/lib.rs</em>ファイルです。これらのコメントはクレート全体を解説します。</p>
<p><code>cargo doc --open</code>を実行すると、これらのコメントは、図14-2に示すように、クレート内のパブリックアイテムのリストの上にある<code>my_crate</code>のドキュメントの先頭ページに表示されます。</p>
<p><img alt="クレート全体を解説するコメントを含むmy_crateの描画されたドキュメンテーション" src="img/trpl14-02.png" class="center" /></p>
<p><span class="caption">図 14-2: クレート全体を解説するコメントを含む<code>my_crate</code>の描画されたドキュメンテーション</span></p>
<p>アイテム内のドキュメンテーションコメントは、特にクレートやモジュールの説明に役立ちます。これらを使用して、コンテナの全体的な目的を説明し、ユーザーがクレートの組織を理解するのを助けます。</p>
<a class="header" href="#pub-useで便利な公開apiをエクスポートする" id="pub-useで便利な公開apiをエクスポートする"><h3><code>pub use</code>で便利な公開APIをエクスポートする</h3></a>
<p>第7章では、<code>mod</code>キーワードを使用してコードをモジュールに編成する方法、<code>pub</code>キーワードを使用してアイテムをパブリックにする方法、<code>use</code>キーワードを使用してアイテムをスコープに持ち込む方法について説明しました。しかし、クレートを開発している間、自分にとって意味のある構造は、ユーザにとってはあまり便利でないかもしれません。構造体を複数のレベルを含む階層に編成することもできますが、階層の中で深く定義した型を使用したい人は、その型が存在するかどうかを調べるのが難しいかもしれません。そのような人は<code>use my_crate::UsefulType</code>の代わりに<code>use my_crate::some_module::another_module::UsefulType;</code>と入力するのを煩わしく感じる可能性もあります。</p>
<p>パブリックAPIの構造は、クレートを公開する際の主な考慮事項です。クレートを使用する人はあなたのものより構造にあまり精通しておらず、クレートが大きなモジュール階層を持っている場合、使用したい部分を見つけるのが難しいかもしれません。</p>
<p>良いことは、構造が他人が他のライブラリから使用するのに便利ではない場合、内部的な体系を再構築する必要はないということです。代わりに、要素を再エクスポートし、<code>pub use</code>で自分の非公開構造とは異なる公開構造にできます。再エクスポートは、ある場所の公開要素を一つ取り、別の場所で定義されているかのように別の場所で公開します。</p>
<p>たとえば、美術の概念をモデル化するために「アート」という名前のライブラリを作成したとします。 このライブラリには、リスト14-3に示すように、 <code>PrimaryColor</code>と<code>SecondaryColor</code>という名前の2つの列挙型と <code>mix</code>という名前の関数を含む<code>utils</code>モジュールを含む <code>kinds</code>モジュールの2つのモジュールがあります：</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">リスト 14-3:アイテムを<code>kind</code>と<code>utils</code>モジュールに編成した <code>art</code>ライブラリ</span></p>
<p>図14-3は、<code>cargo doc</code>によって生成されたこのクレートのドキュメントの最初のページを示しています。</p>
<p><img alt="`kinds`と`utils`モジュールを列挙する`art`のドキュメンテーションのトップページ" src="img/trpl14-03.png" class="center" /></p>
<p><span class="caption">図 14-3: <code>kinds</code>と<code>utils</code>モジュールを列挙する<code>art</code>のドキュメンテーションのトップページ</span></p>
<p><code>PrimaryColor</code>も<code>SecondaryColor</code>型も、<code>mix</code>関数もトップページには列挙されていないことに注意してください。<code>kinds</code>と<code>utils</code>をクリックしなければ、参照することができません。</p>
<p>このライブラリに依存する別のクレートには、現在定義されているモジュール構造を指定して<code>art</code>からの項目をスコープに持ってくる<code>use</code>ステートメントが必要です。リスト14-4は、<code>art</code>クレートの<code>PrimaryColor</code>と<code>mix</code>アイテムを使用するクレートの例を示しています。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">リスト 14-4: 内部構造もエクスポートされてartクレートの要素を使用するクレート</span></p>
<p>リスト14-4のコードの作者は、<code>art</code>クレートを使って、<code>PrimaryColor</code>が<code>kinds</code>モジュールにあり、<code>mix</code>が<code>utils</code>モジュールにあることを理解しなければなりませんでした。<code>art</code>クレートのモジュール構造は、 <code>art</code>クレートの使用者よりも、<code>art</code>クレートに取り組む開発者などに関係が深いです。クレートの一部を<code>kind</code>モジュールと<code>utils</code>モジュールに編成する内部構造は、<code>art</code>クレートの使い方を理解しようとする人にとって有益な情報を含んでいません。代わりに、<code>art</code>クレートのモジュール構造は混乱を招きます。なぜなら、開発者はどこを見るべきかを把握しなければならず、<code>use</code>ステートメントでモジュール名を指定する必要があるからです。</p>
<p>公開APIから内部構造を削除するには、リスト14-3の<code>art</code>クレートのコードを変更して、リスト14-5に示すように<code>pub use</code>ステートメントを追加してアイテムをトップレベルで再エクスポートすることができます。</p>
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use kinds::PrimaryColor;
pub use kinds::SecondaryColor;
pub use utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
</code></pre>
<p><span class="caption">リスト 14-5: pub use文を追加して要素を再エクスポートする</span></p>
<p><code>cargo doc</code>がこのクレート用に生成するAPIドキュメントは、図14-4に示すように、フロントページに再エクスポートをリストしてリンクするようになり、<code>PrimaryColor</code>と<code>SecondaryColor</code>タイプと<code>mix</code>関数を簡単にします 見つけるには。</p>
<p><img alt="再エクスポートを列挙する`art`のドキュメンテーションのトップページ" src="img/trpl14-04.png" class="center" /></p>
<p><span class="caption">図 14-4: 再エクスポートを列挙する<code>art</code>のドキュメンテーションのトップページ</span></p>
<p><code>art</code>クレートのユーザは、リスト14-4に示すように内部構造を表示したり使用したりすることができます（リスト14-6を参照）。</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
</code></pre>
<p><span class="caption">リスト 14-6: <code>art</code>クレートの再エクスポートされた要素を使用するプログラム/span&gt;</p>
<p>入れ子になったモジュールがたくさんある場合は、<code>pub use</code>でトップレベルのタイプを再エクスポートすると、クレートを使用する人の経験に大きな違いが生じます。</p>
<p>便利な公開API構造を作成することは、科学よりも芸術の領域であり、ユーザーにとって最適なAPIを見つけることができます。<code>pub use</code>を選択すると、クレートを内部的に構造化する方法に柔軟性がもたらされ、その内部構造をあなたのユーザに提示するものから切り離すことができます。インストールしたクレートのコードの一部を見て、内部構造が公開APIと異なるかどうかを確認してください。</p>
<a class="header" href="#cratesioのアカウントをセットアップする" id="cratesioのアカウントをセットアップする"><h3>Crates.ioのアカウントをセットアップする</h3></a>
<p>任意のクレートを公開する前に、<a href="https://crates.io">crates.io</a><!--ignore-->にアカウントを作成し、APIトークンを取得する必要があります。 これを行うには、ホームページの<a href="https://crates.io">crates.io</a><!--ignore-->にアクセスし、GitHubアカウントからログインしてください。 （GitHubアカウントは現在のところ必要ですが、将来アカウントを作成する他の方法をサポートしているかもしれません）。ログインしたら、<a href="https://crates.io/me/">https://crates.io/me/</a><!--ignore-->のアカウント設定にアクセスしてくださいあなたのAPIキーを取得します。次に、APIキーを使って<code>cargo login</code>コマンドを実行します。</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>このコマンドはCargoにAPIトークンを通知し、<em>~/.cargo/credentials</em>にローカルに格納します。このトークンは<em>シークレット</em>であることに注意してください。他の誰とも共有しないでください。何らかの理由で他の人と共有している場合は、それを取り消して<a href="https://crates.io">crates.io</a><!-- ignore -->に新しいトークンを生成する必要があります。</p>
<a class="header" href="#a新しいクレートにメタデータを追加する" id="a新しいクレートにメタデータを追加する"><h3>新しいクレートにメタデータを追加する</h3></a>
<p>アカウントはできたので、公開したいクレートを持っているとしましょう。公開する前に、クレートの<em>Cargo.toml</em>ファイルの<code>[package]</code>セクションに追加することによって、クレートにメタデータを追加する必要があります。</p>
<p>クレートには、独自の名前が必要でしょう。クレートをローカルで作成している間、クレートの名前はなんでもいい状態でした。 ただし、<a href="https://crates.io">crates.io</a><!--ignore-->のクレート名は、先着順に割り当てられます。いったんクレートの名前が取られてしまうと、誰もその名前のクレートを公開することはできません。サイトで使用する名前を検索し、使用されているかどうかを調べます。もしそうでなければ、<code>[package]</code>の<em>Cargo.toml</em>ファイルにある名前を編集して公開用の名前を使用します。</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>一意の名前を選択したとしても、この時点で<code>cargo publish</code>を実行してクレートを公開すると、警告が表示され、エラーが表示されます。</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
--snip--
error: api errors: missing or empty metadata fields: description, license.
</code></pre>
<p>その理由は、いくつかの重要な情報が欠落しているということです。クレートが何をしているのか、どのような条件で使用できるのかを人々が知るための説明とライセンスが必要です。このエラーを解決するには、この情報を<em>Cargo.toml</em>ファイルに含める必要があります。</p>
<p>クレートと一緒に検索結果に表示されるため、1つまたは2つの説明だけを追加します。<code>license</code>フィールドには、<em>ライセンス識別子の値</em>を与える必要があります。<a href="http://spdx.org/licenses/">Linux Foundationのソフトウェアパッケージデータ交換(SPDX)</a>には、この値に使用できる識別子がリストされています。たとえば、MITライセンスを使用してあなたの箱をライセンスしたことを指定するには、<code>MIT</code>識別子を追加します。</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>SPDXに表示されないライセンスを使用する場合は、そのライセンスのテキストをファイルに入れ、プロジェクトにファイルを組み込み、<code>license</code>キーを使用する代わりに、<code>license-file</code>を使用してその名前を指定する必要があります。</p>
<p>どのライセンスがプロジェクトに適しているかについてのガイダンスは、この本の範囲を超えています。Rustコミュニティの多くの人々は、<code>MIT OR Apache-2.0</code>の二重ライセンスを使って、Rustと同じ方法でプロジェクトのライセンスを取得しています。このプラクティスでは、複数のライセンスIDを指定して複数のライセンスを所有することもできます。</p>
<p>独自の名前、バージョン、クレート作成時に<code>cargo new</code>が追加した筆者の詳細、説明、ライセンスが追加され、公開準備のできたプロジェクト用の<em>Cargo.toml</em>ファイルは以下のような見た目になっていることでしょう:</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo's documentation</a>では、他の人がクレートを見つけやすく使いやすくするために指定できるメタデータについて説明しています。</p>
<a class="header" href="#cratesioに公開する" id="cratesioに公開する"><h3>Crates.ioに公開する</h3></a>
<p>アカウントを作成し、APIトークンを保存し、クレートの名前を選択し、必要なメタデータを指定したら、すぐに公開できます。クレートを公開すると<a href="https://crates.io">crates.io</a><!--ignore-->に特定のバージョンがアップロードされます。</p>
<p>公開は<em>永久</em>であるため、クレートを公開するときは注意してください。バージョンを上書きすることはできず、コードを削除することはできません。<a href="https://crates.io">crates.io</a><!--ignore-->の主要な目標の1つは、コードの永続的なアーカイブとして機能することで、<a href="https://crates.io">crates.io</a><!--ignore-->のボックスに依存するすべてのプロジェクトのビルドは引き続き動作します。バージョンの削除を許可すると、その目標を達成することは不可能になります。ただし、公開できるクレートバージョンの数に制限はありません。</p>
<p><code>cargo publish</code>コマンドを再度実行してください。今度は成功します。</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Rustコミュニティとコードを共有しました。誰でもプロジェクトの依存としてクレートを簡単に追加できます。</p>
<a class="header" href="#a既存のクレートの新バージョンを公開する" id="a既存のクレートの新バージョンを公開する"><h3>既存のクレートの新バージョンを公開する</h3></a>
<p>クレートを変更して新しいバージョンをリリースする準備が整ったら、<em>Cargo.toml</em>ファイルで指定された<code>version</code>値を変更して再公開します。<a href="http://semver.org/">セマンティックバージョンルール</a>を使って、あなたが行った変更の種類に基づいて適切な次のバージョン番号が何であるかを決定します。次に、新しいバージョンをアップロードするために<code>cargo publish</code>を実行します。</p>
<a class="header" href="#cargo-yankでcratesioからバージョンを削除する" id="cargo-yankでcratesioからバージョンを削除する"><h3><code>cargo yank</code>でCrates.ioからバージョンを削除する</h3></a>
<p>以前のバージョンのクレートを削除することはできませんが、今後のプロジェクトでは新しい依存関係として追加することはできません。これは、クレートバージョンが何らかの理由で壊れている場合に便利です。このような状況では、Cargoはクレートバージョンの取り下げをサポートしています。</p>
<p>バージョンを取り下げると、他の既存のプロジェクトには、引き続きダウンロードし、そのバージョンに依存させ続けつつ、 新規プロジェクトが新しくそのバージョンに依存しだすことを防ぎます。本質的に、取り下げは、<em>Cargo.lock</em>を持つすべてのプロジェクトが中断しないことを意味し、生成される<em>Cargo.lock</em>ファイルはヤンクされたバージョンを使用しません。</p>
<p>あるバージョンのクレートを取り下げるには、<code>cargo yank</code>を実行し、取り下げたいバージョンを指定します。</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<p>コマンドに <code>--undo</code>を追加することで、取り下げを元に戻して、バージョンに応じてプロジェクトを再開することもできます。</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p><em>取り下げ</em>はコードを削除しません。たとえば、誤ってアップロードされた秘密鍵を削除するための機能ではありません。そのような場合は、すぐにそれらの秘密鍵をリセットする必要があります。</p>
<a class="header" href="#cargoのワークスペース" id="cargoのワークスペース"><h2>Cargoのワークスペース</h2></a>
<p>第12章では、バイナリクレートとライブラリクレートを含むパッケージを作成しました。プロジェクトが進展するにつれて、ライブラリクレートは引き続き大きくなり、パッケージを複数のライブラリクレートにさらに分割したいと思うかもしれません。このような状況のためにCargoには、<em>ワークスペース</em>という機能があり、複数の関連パッケージを一元管理して管理することができます。</p>
<a class="header" href="#aワークスペースを生成する" id="aワークスペースを生成する"><h3>ワークスペースを生成する</h3></a>
<p><em>ワークスペース</em>は、同じ<em>Cargo.lock</em>と出力ディレクトリを共有する一連のパッケージです。ワークスペースを使ってプロジェクトを作ってみましょう。ワークスペースの構造に集中できるように、簡単なコードを使用します。ワークスペースを構成するには複数の方法があります。1つの共通の方法を示します。バイナリと2つのライブラリを含むワークスペースがあります。主な機能を提供するバイナリは、2つのライブラリに依存します。一つのライブラリは<code>add_one</code>関数を提供し、二つ目のライブラリは<code>add_two</code>関数を提供します。これらの3つのクレートは、同じワークスペースの一部になります。作業領域の新しいディレクトリを作成します。</p>
<pre><code class="language-text">$ mkdir add
$ cd add
</code></pre>
<p>次に、<em>add</em>ディレクトリにワークスペース全体を構成する<em>Cargo.toml</em>ファイルを作成します。このファイルには、他の<em>Cargo.toml</em>ファイルで見た<code>[package]</code>セクションやメタデータはありません。代わりに、<code>[workspace]</code>セクションから始まり、バイナリクレートへのパスを指定することでワークスペースにメンバを追加することができます。この場合、そのパスは<em>adder</em>です：</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>次に、<em>add</em>ディレクトリ内で<code>cargo new</code>を実行して<code>adder</code>バイナリクレートを作成します。</p>
<pre><code class="language-text">$ cargo new adder
     Created binary (application) `adder` project
</code></pre>
<p>この時点で、<code>cargo build</code>を実行して作業領域を構築することができます。<em>add</em>ディレクトリのファイルは次のようになります。</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>ワークスペースには、コンパイルされた成果物が配置される最上位に1つの<em>target</em>ディレクトリがあります。<code>adder</code>クレートには独自の<em>target</em>ディレクトリがありません。<em>adder</em>ディレクトリの内側から`cargo build'を実行しても、コンパイルされた成果物は<em>add/adder/target</em>ではなく<em>add/target</em>になります。Cargoは、このようなワークスペースの<em>target</em>ディレクトリを構造化します。なぜなら、ワークスペース内のクレートは互いに依存するためです。各クレートに独自の<em>target</em>ディレクトリがある場合、各クレートはワークスペース内の他の各クレートを再コンパイルして、自身の<em>target</em>ディレクトリにアーティファクトを持たなければなりません。1つの<em>target</em>ディレクトリを共有することで、不必要な再構築を避けることができます。</p>
<a class="header" href="#aワークスペース内に2番目のクレートを作成する" id="aワークスペース内に2番目のクレートを作成する"><h3>ワークスペース内に2番目のクレートを作成する</h3></a>
<p>次に、ワークスペースに<code>add-one</code>という名前の別のメンバークレートを作成します。<em>Cargo.toml</em>を変更して、<code>members</code>リストに<em>add-one</em>を指定します</p>
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<p>次に、<code>add-one</code>という名前の新しいライブラリクレートを生成します。</p>
<pre><code class="language-text">$ cargo new add-one --lib
     Created library `add-one` project
</code></pre>
<p><em>add</em>ディレクトリにこれらのディレクトリとファイルがあるはずです。</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p><em>add-one/src/lib.rs</em>ファイルに、<code>add_one</code>関数を追加しましょう。</p>
<p><span class="filename">ファイル名: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>ワークスペースにライブラリクレートがあるので、バイナリクレート<code>adder</code>をライブラリクレート<code>add-one</code>に依存させることができます。まず、<em>addder/Cargo.toml</em>に<code>add-one</code>にパス依存を追加する必要があります。</p>
<p><span class="filename">ファイル名: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<p>Cargoでは、ワークスペース内のクレートが互いに依存するとは想定されていないため、クレート間の依存関係について明示する必要があります。</p>
<p>次に、<code>adder</code>クレート内の<code>add-one</code>クレートから<code>add_one</code>関数を使用しましょう。<em>adder/src/main.rs</em>ファイルを開き、上に<code>use</code>行を追加して、新しい<code>add-one</code>ライブラリクレートをスコープに入れてください。リスト14-7のように、<code>main</code>関数を変更して<code>add_one</code>関数を呼び出します。</p>
<p><span class="filename">ファイル名: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<p><span class="caption">リスト 14-7:<code>add-one</code>ライブラリクレートを<code>adder</code>クレートから使用する</span></p>
<p>最上位の<em>add</em>ディレクトリで<code>cargo build</code>を実行してワークスペースを構築しましょう。</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<p><em>add</em>ディレクトリからバイナリクレートを実行するには、<code>-p</code>引数を使用し、パッケージ名を<code>cargo run</code>で指定する必要があります。</p>
<pre><code class="language-text">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>これは<em>addder/src/main.rs</em>のコードを実行します。これは<code>add-one</code>クレートに依存します。</p>
<a class="header" href="#aワークスペースの外部クレートに依存する" id="aワークスペースの外部クレートに依存する"><h4>ワークスペースの外部クレートに依存する</h4></a>
<p>ワークスペースには、各クレートのディレクトリに<em>Cargo.lock</em>があるのではなく、ワークスペースの最上位に<em>Cargo.lock</em>ファイルが1つしかありません。これにより、すべてのクレートがすべての依存関係の同じバージョンを使用していることが保証されます。 <em>adder/Cargo.toml</em>と<em>add-one/Cargo.toml</em>ファイルに<code>rand</code>クレートを追加すると、Cargoはそれらの両方を<code>rand</code>の一つのバージョンに解決し、それを一つの<em>Cargo.lock</em>に記録します。同じ依存関係を使用するワークスペース内のすべてのクレートを作成すると、ワークスペース内のクレートが常に互いに互換性があることを意味します。<em>add-one/Cargo.toml</em>ファイルの<code>[dependencies]</code>セクションに<code>rand</code>クレートを追加して、<code>add-one</code>クレートで<code>rand</code>クレートを使用できるようにしましょう。</p>
<p><span class="filename">ファイル名: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>これで、<em>add-one/src/lib.rs</em>ファイルに<code>extern crate rand;</code>を追加でき、<code>add</code>ディレクトリで<code>cargo build</code>を実行することでワークスペース全体をビルドすると、randクレートを持ってきてコンパイルします。</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   --snip--
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<p><em>Cargo.lock</em>には、<code>add-one</code>の<code>rand</code>への依存性に関する情報が含まれるようになりました。しかし、<code>rand</code>がワークスペースのどこかで使用されていても、<em>Cargo.toml</em>ファイルに<code>rand</code>を追加しない限り、ワークスペースの他のクレートには使用できません。 例えば、<code>adder</code>クレートの<em>adder/src/main.rs</em>ファイルに<code>extern crate rand;</code>を追加すると、エラーが発生します。</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
 --&gt; adder/src/main.rs:1:1
  |
1 | use rand;
</code></pre>
<p>これを修正するには、<code>adder</code>クレート用の<em>Cargo.toml</em>ファイルを編集し、<code>rand</code>もそのクレートの依存関係であることを示します。<code>adder</code>クレートを作ると、<em>Cargo.lock</em>の<code>adder</code>の依存関係のリストに<code>rand</code>が追加されますが、<code>rand</code>の追加コピーはダウンロードされません。 Cargoは、<code>rand</code>クレートを使用する作業スペースのすべてのクレートが同じバージョンを使用することを保証しています。同じバージョンの<code>rand</code>をワークスペース全体で使用すると、複数のコピーを持たず、ワークスペース内のクレートが互いに互換性があるため、スペースが節約されます。</p>
<a class="header" href="#aワークスペースにテストを追加する" id="aワークスペースにテストを追加する"><h4>ワークスペースにテストを追加する</h4></a>
<p>もう一つの機能強化のために、<code>add_one::add_one</code>関数のテストを<code>add_one</code>クレートの中に追加しましょう。</p>
<p><span class="filename">ファイル名: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
#}</code></pre></pre>
<p>トップレベルの<em>add</em>ディレクトリで<code>cargo test</code>を実行してください。</p>
<pre><code class="language-text">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>出力の最初のセクションは、<code>add-one</code>の<code>it_works</code>テストが成功したことを示しています。次のセクションでは、<code>adder</code>クレートにゼロテストが見つかり、最後のセクションで<code>add-one</code>クレートでのドキュメンテーションテストがゼロであることが示されています。このように構造化されたワークスペースで<code>cargo test</code>を実行すると、ワークスペース内のすべてのクレートのテストが実行されます。</p>
<p>また、<code>-p</code>フラグを使用してテストするクレートの名前を指定することで、トップレベルディレクトリからワークスペース内のある特定のクレートのテストを実行することもできます。</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>この出力は<code>cargo test</code>が<code>add-one</code>クレートのテストを実行し、<code>adder</code>クレートテストを実行しなかったことを示しています。</p>
<p>ワークスペース内のクレートを*https://crates.io/*に公開する場合、ワークスペース内の各クレートは個別に公開する必要があります。<code>cargo publish</code>コマンドは<code>--all</code>フラグや<code>-p</code>フラグを持たないので、各クレートのディレクトリに移動し、ワークスペースの各クレートに<code>cargo publish</code>を実行してクレートを公開する必要があります。</p>
<p>さらに練習するには、 <code>add-one</code>クレートと同様の方法で<code>add-two</code>クレートをこのワークスペースに追加してください。</p>
<p>プロジェクトが成長するにつれて、ワークスペースの使用を検討してください。一つの大きなコードよりも小さく、個々のコンポーネントを理解する方が簡単です。さらに、ワークスペース内にクレートを保持すると、頻繁に変更されると、それらの間の調整をより簡単に行うことができます。</p>
<a class="header" href="#cargo-installでcratesioからバイナリをインストールする" id="cargo-installでcratesioからバイナリをインストールする"><h2><code>cargo install</code>でCrates.ioからバイナリをインストールする</h2></a>
<p><code>cargo install</code>コマンドを使うとバイナリクレートをローカルにインストールして使うことができます。これはシステムパッケージを置き換えるものではありません。Rustの開発者が他の人が<a href="https://crates.io">crates.io</a><!--ignore-->で共有しているツールをインストールするのに便利な方法です。 バイナリターゲットを持つパッケージのみインストールできることに注意してください。<em>バイナリターゲット</em>とは、 クレートが<em>src/main.rs</em>ファイルやバイナリとして指定された他のファイルを持つ場合に生成される実行可能なプログラムのことであり、単独では実行不可能なものの、他のプログラムに含むのには適しているライブラリターゲットとは一線を画します。通常、クレートには、<em>README</em>ファイルに、クレートがライブラリかバイナリターゲットか、両方をもつかという情報があります。</p>
<p><code>cargo install</code>でインストールされたすべてのバイナリは、インストールルートの<em>bin</em>フォルダに保存されます。<em>rustup.rs</em>を使用してRustをインストールした場合、カスタム構成がない場合、このディレクトリは*$HOME/.cargo/bin*になります。<code>$PATH</code>ディレクトリに<code>cargo install</code>でインストールしたプログラムを実行できることを確認してください。</p>
<p>たとえば、第12章では、ファイルを検索するための<code>ripgrep</code>というgrepツールのRust実装があると述べました。<code>ripgrep</code>をインストールしたい場合は、以下を実行できます。</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<p>出力の最後の行には、インストールされているバイナリの場所と名前が表示されます。これは<code>ripgrep</code>の場合は<code>rg</code>です。インストールディレクトリが<code>$PATH</code>にある限り、<code>rg --help</code>を実行して、より速いRustらしいファイル検索ツールを使うことができます。</p>
<a class="header" href="#a独自のコマンドでcargoを拡張する" id="a独自のコマンドでcargoを拡張する"><h2>独自のコマンドでCargoを拡張する</h2></a>
<p>Cargoは、Cargoを変更することなく新しいサブコマンドで拡張できるように設計されています。<code>$PATH</code>のバイナリが<code>cargo-something</code>という名前の場合、<code>cargo something</code>を実行して、それがCargoサブコマンドであるかのように実行することができます。<code>cargo --list</code>を実行すると、このようなカスタムコマンドも表示されます。拡張機能をインストールするために<code>cargo install</code>を使用でき、組み込みのCargoツールと同じように実行できることは、Cargoの設計の非常に便利な利点です。</p>
<a class="header" href="#aまとめ-11" id="aまとめ-11"><h2>まとめ</h2></a>
<p>Cargoと<a href="https://crates.io">crates.io</a><!-- ignore -->でコードを共有することは、Rustエコシステムをさまざまなタスクに役立つものにする要素の1つです。Rustの標準ライブラリは小さく安定していますが、言語とは異なるタイムラインで簡単に共有、使用、改善することができます。<a href="https://crates.io">crates.io</a><!-- ignore -->で便利なコードを共有することを恥ずかしくないでください。それは他の人にとっても有用である可能性が高いです。</p>
<a class="header" href="#smart-pointers" id="smart-pointers"><h1>Smart Pointers</h1></a>
<p>A <em>pointer</em> is a general concept for a variable that contains an address in
memory. This address refers to, or “points at,” some other data. The most
common kind of pointer in Rust is a reference, which you learned about in
Chapter 4. References are indicated by the <code>&amp;</code> symbol and borrow the value they
point to. They don’t have any special capabilities other than referring to
data. Also, they don’t have any overhead and are the kind of pointer we use
most often.</p>
<p><em>Smart pointers</em>, on the other hand, are data structures that not only act like
a pointer but also have additional metadata and capabilities. The concept of
smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist
in other languages as well. In Rust, the different smart pointers defined in
the standard library provide functionality beyond that provided by references.
One example that we’ll explore in this chapter is the <em>reference counting</em>
smart pointer type. This pointer enables you to have multiple owners of data by
keeping track of the number of owners and, when no owners remain, cleaning up
the data.</p>
<p>In Rust, which uses the concept of ownership and borrowing, an additional
difference between references and smart pointers is that references are
pointers that only borrow data; in contrast, in many cases, smart pointers
<em>own</em> the data they point to.</p>
<p>We’ve already encountered a few smart pointers in this book, such as <code>String</code>
and <code>Vec&lt;T&gt;</code> in Chapter 8, although we didn’t call them smart pointers at the
time. Both these types count as smart pointers because they own some memory and
allow you to manipulate it. They also have metadata (such as their capacity)
and extra capabilities or guarantees (such as with <code>String</code> ensuring its data
will always be valid UTF-8).</p>
<p>Smart pointers are usually implemented using structs. The characteristic that
distinguishes a smart pointer from an ordinary struct is that smart pointers
implement the <code>Deref</code> and <code>Drop</code> traits. The <code>Deref</code> trait allows an instance
of the smart pointer struct to behave like a reference so you can write code
that works with either references or smart pointers. The <code>Drop</code> trait allows
you to customize the code that is run when an instance of the smart pointer
goes out of scope. In this chapter, we’ll discuss both traits and demonstrate
why they’re important to smart pointers.</p>
<p>Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter won’t cover every existing smart pointer. Many
libraries have their own smart pointers, and you can even write your own. We’ll
cover the most common smart pointers in the standard library:</p>
<ul>
<li><code>Box&lt;T&gt;</code> for allocating values on the heap</li>
<li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li>
<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces
the borrowing rules at runtime instead of compile time</li>
</ul>
<p>In addition, we’ll cover the <em>interior mutability</em> pattern where an immutable
type exposes an API for mutating an interior value. We’ll also discuss
<em>reference cycles</em>: how they can leak memory and how to prevent them.</p>
<p>Let’s dive in!</p>
<a class="header" href="#using-boxt-to-point-to-data-on-the-heap" id="using-boxt-to-point-to-data-on-the-heap"><h2>Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap</h2></a>
<p>The most straightforward smart pointer is a <em>box</em>, whose type is written
<code>Box&lt;T&gt;</code>. Boxes allow you to store data on the heap rather than the stack. What
remains on the stack is the pointer to the heap data. Refer to Chapter 4 to
review the difference between the stack and the heap.</p>
<p>Boxes don’t have performance overhead, other than storing their data on the
heap instead of on the stack. But they don’t have many extra capabilities
either. You’ll use them most often in these situations:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want
to use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but
ensure the data won’t be copied when you do so</li>
<li>When you want to own a value and you care only that it’s a type that
implements a particular trait rather than being of a specific type</li>
</ul>
<p>We’ll demonstrate the first situation in the “Enabling Recursive Types with
Boxes” section. In the second case, transferring ownership of a large amount of
data can take a long time because the data is copied around on the stack. To
improve performance in this situation, we can store the large amount of data on
the heap in a box. Then, only the small amount of pointer data is copied around
on the stack, while the data it references stays in one place on the heap. The
third case is known as a <em>trait object</em>, and Chapter 17 devotes an entire
section, “Using Trait Objects That Allow for Values of Different Types,” just
to that topic. So what you learn here you’ll apply again in Chapter 17!</p>
<a class="header" href="#using-a-boxt-to-store-data-on-the-heap" id="using-a-boxt-to-store-data-on-the-heap"><h3>Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</h3></a>
<p>Before we discuss this use case for <code>Box&lt;T&gt;</code>, we’ll cover the syntax and how to
interact with values stored within a <code>Box&lt;T&gt;</code>.</p>
<p>Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Listing 15-1: Storing an <code>i32</code> value on the heap using a
box</span></p>
<p>We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the
value <code>5</code>, which is allocated on the heap. This program will print <code>b = 5</code>; in
this case, we can access the data in the box similar to how we would if this
data were on the stack. Just like any owned value, when a box goes out of
scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The
deallocation happens for the box (stored on the stack) and the data it points
to (stored on the heap).</p>
<p>Putting a single value on the heap isn’t very useful, so you won’t use boxes by
themselves in this way very often. Having values like a single <code>i32</code> on the
stack, where they’re stored by default, is more appropriate in the majority of
situations. Let’s look at a case where boxes allow us to define types that we
wouldn’t be allowed to if we didn’t have boxes.</p>
<a class="header" href="#enabling-recursive-types-with-boxes" id="enabling-recursive-types-with-boxes"><h3>Enabling Recursive Types with Boxes</h3></a>
<p>At compile time, Rust needs to know how much space a type takes up. One type
whose size can’t be known at compile time is a <em>recursive type</em>, where a value
can have as part of itself another value of the same type. Because this nesting
of values could theoretically continue infinitely, Rust doesn’t know how much
space a value of a recursive type needs. However, boxes have a known size, so
by inserting a box in a recursive type definition, you can have recursive types.</p>
<p>Let’s explore the <em>cons list</em>, which is a data type common in functional
programming languages, as an example of a recursive type. The cons list type
we’ll define is straightforward except for the recursion; therefore, the
concepts in the example we’ll work with will be useful any time you get into
more complex situations involving recursive types.</p>
<a class="header" href="#more-information-about-the-cons-list" id="more-information-about-the-cons-list"><h4>More Information About the Cons List</h4></a>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language
and its dialects. In Lisp, the <code>cons</code> function (short for “construct function”)
constructs a new pair from its two arguments, which usually are a single value
and another pair. These pairs containing pairs form a list.</p>
<p>The cons function concept has made its way into more general functional
programming jargon: “to cons <em>x</em> onto <em>y</em>” informally means to construct a new
container instance by putting the element <em>x</em> at the start of this new
container, followed by the container <em>y</em>.</p>
<p>Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called <code>Nil</code>
without a next item. A cons list is produced by recursively calling the <code>cons</code>
function. The canonical name to denote the base case of the recursion is <code>Nil</code>.
Note that this is not the same as the “null” or “nil” concept in Chapter 6,
which is an invalid or absent value.</p>
<p>Although functional programming languages use cons lists frequently, the cons
list isn’t a commonly used data structure in Rust. Most of the time when you
have a list of items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use. Other, more
complex recursive data types <em>are</em> useful in various situations, but by
starting with the cons list, we can explore how boxes let us define a recursive
data type without much distraction.</p>
<p>Listing 15-2 contains an enum definition for a cons list. Note that this code
won’t compile yet because the <code>List</code> type doesn’t have a known size, which
we’ll demonstrate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">Listing 15-2: The first attempt at defining an enum to
represent a cons list data structure of <code>i32</code> values</span></p>
<blockquote>
<p>Note: We’re implementing a cons list that holds only <code>i32</code> values for the
purposes of this example. We could have implemented it using generics, as we
discussed in Chapter 10, to define a cons list type that could store values of
any type.</p>
</blockquote>
<p>Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in
Listing 15-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">Listing 15-3: Using the <code>List</code> enum to store the list <code>1, 2, 3</code></span></p>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code> value is
another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This <code>List</code> value
is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally
<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p><span class="caption">Listing 15-4: The error we get when attempting to define
a recursive enum</span></p>
<p>The error shows this type “has infinite size.” The reason is that we’ve defined
<code>List</code> with a variant that is recursive: it holds another value of itself
directly. As a result, Rust can’t figure out how much space it needs to store a
<code>List</code> value. Let’s break down why we get this error a bit. First, let’s look
at how Rust decides how much space it needs to store a value of a non-recursive
type.</p>
<a class="header" href="#computing-the-size-of-a-non-recursive-type" id="computing-the-size-of-a-non-recursive-type"><h4>Computing the Size of a Non-Recursive Type</h4></a>
<p>Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p>To determine how much space to allocate for a <code>Message</code> value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that <code>Message::Quit</code> doesn’t need any space, <code>Message::Move</code> needs enough
space to store two <code>i32</code> values, and so forth. Because only one variant will be
used, the most space a <code>Message</code> value will need is the space it would take to
store the largest of its variants.</p>
<p>Contrast this with what happens when Rust tries to determine how much space a
recursive type like the <code>List</code> enum in Listing 15-2 needs. The compiler starts
by looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value
of type <code>List</code>. Therefore, <code>Cons</code> needs an amount of space equal to the size of
an <code>i32</code> plus the size of a <code>List</code>. To figure out how much memory the <code>List</code>
type needs, the compiler looks at the variants, starting with the <code>Cons</code>
variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type
<code>List</code>, and this process continues infinitely, as shown in Figure 15-1.</p>
<p><img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 15-1: An infinite <code>List</code> consisting of infinite
<code>Cons</code> variants</span></p>
<a class="header" href="#using-boxt-to-get-a-recursive-type-with-a-known-size" id="using-boxt-to-get-a-recursive-type-with-a-known-size"><h4>Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size</h4></a>
<p>Rust can’t figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-4. But the error does include
this helpful suggestion:</p>
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p>In this suggestion, “indirection” means that instead of storing a value
directly, we’ll change the data structure to store the value indirectly by
storing a pointer to the value instead.</p>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code>
needs: a pointer’s size doesn’t change based on the amount of data it’s
pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead
of another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code>
value that will be on the heap rather than inside the <code>Cons</code> variant.
Conceptually, we still have a list, created with lists “holding” other lists,
but this implementation is now more like placing the items next to one another
rather than inside one another.</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage
of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Listing 15-5: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in
order to have a known size</span></p>
<p>The <code>Cons</code> variant will need the size of an <code>i32</code> plus the space to store the
box’s pointer data. The <code>Nil</code> variant stores no values, so it needs less space
than the <code>Cons</code> variant. We now know that any <code>List</code> value will take up the
size of an <code>i32</code> plus the size of a box’s pointer data. By using a box, we’ve
broken the infinite, recursive chain, so the compiler can figure out the size
it needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code> variant
looks like now.</p>
<p><img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">Figure 15-2: A <code>List</code> that is not infinitely sized
because <code>Cons</code> holds a <code>Box</code></span></p>
<p>Boxes provide only the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have any performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We’ll look at more use cases for boxes
in Chapter 17, too.</p>
<p>The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait,
which allows <code>Box&lt;T&gt;</code> values to be treated like references. When a <code>Box&lt;T&gt;</code>
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the <code>Drop</code> trait implementation. Let’s explore these two
traits in more detail. These two traits will be even more important to the
functionality provided by the other smart pointer types we’ll discuss in the
rest of this chapter.</p>
<a class="header" href="#treating-smart-pointers-like-regular-references-with-the-deref-trait" id="treating-smart-pointers-like-regular-references-with-the-deref-trait"><h2>Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</h2></a>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the
<em>dereference operator</em>, <code>*</code> (as opposed to the multiplication or glob
operator). By implementing <code>Deref</code> in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.</p>
<p>Let’s first look at how the dereference operator works with regular references.
Then we’ll try to define a custom type that behaves like <code>Box&lt;T&gt;</code>, and see why
the dereference operator doesn’t work like a reference on our newly defined
type. We’ll explore how implementing the <code>Deref</code> trait makes it possible for
smart pointers to work in a similar way as references. Then we’ll look at
Rust’s <em>deref coercion</em> feature and how it lets us work with either references
or smart pointers.</p>
<blockquote>
<p>There’s one big difference between the <code>MyBox&lt;T&gt;</code> type we’re about to build
and the real <code>Box&lt;T&gt;</code>: our version will not store its data on the heap. We
are focusing this example on <code>Deref</code>, and so where the data is actually stored
is less important than the pointer-like behavior.</p>
</blockquote>
<a class="header" href="#following-the-pointer-to-the-value-with-the-dereference-operator" id="following-the-pointer-to-the-value-with-the-dereference-operator"><h3>Following the Pointer to the Value with the Dereference Operator</h3></a>
<p>A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an <code>i32</code> value and then use the dereference operator to follow the
reference to the data:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an <code>i32</code> value</span></p>
<p>The variable <code>x</code> holds an <code>i32</code> value, <code>5</code>. We set <code>y</code> equal to a reference to
<code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an
assertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference
to the value it’s pointing to (hence <em>dereference</em>). Once we dereference <code>y</code>,
we have access to the integer value <code>y</code> is pointing to that we can compare with
<code>5</code>.</p>
<p>If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation
error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` is
not satisfied
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `&amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
</code></pre>
<p>Comparing a number and a reference to a number isn’t allowed because they’re
different types. We must use the dereference operator to follow the reference
to the value it’s pointing to.</p>
<a class="header" href="#using-boxt-like-a-reference" id="using-boxt-like-a-reference"><h3>Using <code>Box&lt;T&gt;</code> Like a Reference</h3></a>
<p>We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a
reference; the dereference operator will work as shown in Listing 15-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listing 15-7: Using the dereference operator on a
<code>Box&lt;i32&gt;</code></span></p>
<p>The only difference between Listing 15-7 and Listing 15-6 is that here we set
<code>y</code> to be an instance of a box pointing to the value in <code>x</code> rather than a
reference pointing to the value of <code>x</code>. In the last assertion, we can use the
dereference operator to follow the box’s pointer in the same way that we did
when <code>y</code> was a reference. Next, we’ll explore what is special about <code>Box&lt;T&gt;</code>
that enables us to use the dereference operator by defining our own box type.</p>
<a class="header" href="#defining-our-own-smart-pointer" id="defining-our-own-smart-pointer"><h3>Defining Our Own Smart Pointer</h3></a>
<p>Let’s build a smart pointer similar to the <code>Box&lt;T&gt;</code> type provided by the
standard library to experience how smart pointers behave differently than
references by default. Then we’ll look at how to add the ability to use the
dereference operator.</p>
<p>The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way. We’ll also define a
<code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-8: Defining a <code>MyBox&lt;T&gt;</code> type</span></p>
<p>We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code>, because
we want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct
with one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of
type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and
changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The
code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference
<code>MyBox</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">Listing 15-9: Attempting to use <code>MyBox&lt;T&gt;</code> in the same
way we used references and <code>Box&lt;T&gt;</code></span></p>
<p>Here’s the resulting compilation error:</p>
<pre><code class="language-text">error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<p>Our <code>MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that
ability on our type. To enable dereferencing with the <code>*</code> operator, we
implement the <code>Deref</code> trait.</p>
<a class="header" href="#treating-a-type-like-a-reference-by-implementing-the-deref-trait" id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"><h3>Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</h3></a>
<p>As discussed in Chapter 10, to implement a trait, we need to provide
implementations for the trait’s required methods. The <code>Deref</code> trait, provided
by the standard library, requires us to implement one method named <code>deref</code> that
borrows <code>self</code> and returns a reference to the inner data. Listing 15-10
contains an implementation of <code>Deref</code> to add to the definition of <code>MyBox</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Deref;

# struct MyBox&lt;T&gt;(T);
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-10: Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code></span></p>
<p>The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code> trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you don’t need to worry about them for now; we’ll cover them in
more detail in Chapter 19.</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a
reference to the value we want to access with the <code>*</code> operator. The <code>main</code>
function in Listing 15-9 that calls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now compiles,
and the assertions pass!</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.
The <code>deref</code> method gives the compiler the ability to take a value of any type
that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that
it knows how to dereference.</p>
<p>When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this
code:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a
plain dereference so we don’t have to think about whether or not we need to
call the <code>deref</code> method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
<code>Deref</code>.</p>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the plain
dereference outside the parentheses in <code>*(y.deref())</code> is still necessary, is the
ownership system. If the <code>deref</code> method returned the value directly instead of
a reference to the value, the value would be moved out of <code>self</code>. We don’t want
to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in this case or in most
cases where we use the dereference operator.</p>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and
then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.
Because the substitution of the <code>*</code> operator does not recurse infinitely, we
end up with data of type <code>i32</code>, which matches the <code>5</code> in <code>assert_eq!</code> in
Listing 15-9.</p>
<a class="header" href="#implicit-deref-coercions-with-functions-and-methods" id="implicit-deref-coercions-with-functions-and-methods"><h3>Implicit Deref Coercions with Functions and Methods</h3></a>
<p><em>Deref coercion</em> is a convenience that Rust performs on arguments to functions
and methods. Deref coercion converts a reference to a type that implements
<code>Deref</code> into a reference to a type that <code>Deref</code> can convert the original type
into. Deref coercion happens automatically when we pass a reference to a
particular type’s value as an argument to a function or method that doesn’t
match the parameter type in the function or method definition. A sequence of
calls to the <code>deref</code> method converts the type we provided into the type the
parameter needs.</p>
<p>Deref coercion was added to Rust so that programmers writing function and
method calls don’t need to add as many explicit references and dereferences
with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.</p>
<p>To see deref coercion in action, let’s use the <code>MyBox&lt;T&gt;</code> type we defined in
Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-11: A <code>hello</code> function that has the parameter
<code>name</code> of type <code>&amp;str</code></span></p>
<p>We can call the <code>hello</code> function with a string slice as an argument, such as
<code>hello(&quot;Rust&quot;);</code> for example. Deref coercion makes it possible to call <code>hello</code>
with a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MyBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MyBox&lt;T&gt; {
#     fn new(x: T) -&gt; MyBox&lt;T&gt; {
#         MyBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn hello(name: &amp;str) {
#     println!(&quot;Hello, {}!&quot;, name);
# }
#
fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Listing 15-12: Calling <code>hello</code> with a reference to a
<code>MyBox&lt;String&gt;</code> value, which works because of deref coercion</span></p>
<p>Here we’re calling the <code>hello</code> function with the argument <code>&amp;m</code>, which is a
reference to a <code>MyBox&lt;String&gt;</code> value. Because we implemented the <code>Deref</code> trait
on <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code>
by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code>
on <code>String</code> that returns a string slice, and this is in the API documentation
for <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which
matches the <code>hello</code> function’s definition.</p>
<p>If Rust didn’t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value
of type <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MyBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MyBox&lt;T&gt; {
#     fn new(x: T) -&gt; MyBox&lt;T&gt; {
#         MyBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn hello(name: &amp;str) {
#     println!(&quot;Hello, {}!&quot;, name);
# }
#
fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Listing 15-13: The code we would have to write if Rust
didn’t have deref coercion</span></p>
<p>The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then the <code>&amp;</code> and
<code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to
match the signature of <code>hello</code>. The code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the
types and use <code>Deref::deref</code> as many times as necessary to get a reference to
match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!</p>
<a class="header" href="#how-deref-coercion-interacts-with-mutability" id="how-deref-coercion-interacts-with-mutability"><h3>How Deref Coercion Interacts with Mutability</h3></a>
<p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on
immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code>
operator on mutable references.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three
cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>The first two cases are the same except for mutability. The first case states
that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can
get a <code>&amp;U</code> transparently. The second case states that the same deref coercion
happens for mutable references.</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is <em>not</em> possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn’t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that
there is only one immutable reference to that data, and the borrowing rules
don’t guarantee that. Therefore, Rust can’t make the assumption that converting
an immutable reference to a mutable reference is possible.</p>
<a class="header" href="#running-code-on-cleanup-with-the-drop-trait" id="running-code-on-cleanup-with-the-drop-trait"><h2>Running Code on Cleanup with the <code>Drop</code> Trait</h2></a>
<p>The second trait important to the smart pointer pattern is <code>Drop</code>, which lets
you customize what happens when a value is about to go out of scope. You can
provide an implementation for the <code>Drop</code> trait on any type, and the code you
specify can be used to release resources like files or network connections.
We’re introducing <code>Drop</code> in the context of smart pointers because the
functionality of the <code>Drop</code> trait is almost always used when implementing a
smart pointer. For example, <code>Box&lt;T&gt;</code> customizes <code>Drop</code> to deallocate the space
on the heap that the box points to.</p>
<p>In some languages, the programmer must call code to free memory or resources
every time they finish using an instance of a smart pointer. If they forget,
the system might become overloaded and crash. In Rust, you can specify that a
particular bit of code be run whenever a value goes out of scope, and the
compiler will insert this code automatically. As a result, you don’t need to be
careful about placing cleanup code everywhere in a program that an instance of
a particular type is finished with—you still won’t leak resources!</p>
<p>Specify the code to run when a value goes out of scope by implementing the
<code>Drop</code> trait. The <code>Drop</code> trait requires you to implement one method named
<code>drop</code> that takes a mutable reference to <code>self</code>. To see when Rust calls <code>drop</code>,
let’s implement <code>drop</code> with <code>println!</code> statements for now.</p>
<p>Listing 15-14 shows a <code>CustomSmartPointer</code> struct whose only custom
functionality is that it will print <code>Dropping CustomSmartPointer!</code> when the
instance goes out of scope. This example demonstrates when Rust runs the <code>drop</code>
function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;my stuff&quot;) };
    let d = CustomSmartPointer { data: String::from(&quot;other stuff&quot;) };
    println!(&quot;CustomSmartPointers created.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 15-14: A <code>CustomSmartPointer</code> struct that
implements the <code>Drop</code> trait where we would put our cleanup code</span></p>
<p>The <code>Drop</code> trait is included in the prelude, so we don’t need to bring it into
scope. We implement the <code>Drop</code> trait on <code>CustomSmartPointer</code> and provide an
implementation for the <code>drop</code> method that calls <code>println!</code>. The body of the
<code>drop</code> function is where you would place any logic that you wanted to run when
an instance of your type goes out of scope. We’re printing some text here to
demonstrate when Rust will call <code>drop</code>.</p>
<p>In <code>main</code>, we create two instances of <code>CustomSmartPointer</code> and then print
<code>CustomSmartPointers created.</code>. At the end of <code>main</code>, our instances of
<code>CustomSmartPointer</code> will go out of scope, and Rust will call the code we put
in the <code>drop</code> method, printing our final message. Note that we didn’t need to
call the <code>drop</code> method explicitly.</p>
<p>When we run this program, we’ll see the following output:</p>
<pre><code class="language-text">CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust automatically called <code>drop</code> for us when our instances went out of scope,
calling the code we specified. Variables are dropped in the reverse order of
their creation, so <code>d</code> was dropped before <code>c</code>. This example gives you a visual
guide to how the <code>drop</code> method works; usually you would specify the cleanup
code that your type needs to run rather than a print message.</p>
<a class="header" href="#dropping-a-value-early-with-stdmemdrop" id="dropping-a-value-early-with-stdmemdrop"><h3>Dropping a Value Early with <code>std::mem::drop</code></h3></a>
<p>Unfortunately, it’s not straightforward to disable the automatic <code>drop</code>
functionality. Disabling <code>drop</code> isn’t usually necessary; the whole point of the
<code>Drop</code> trait is that it’s taken care of automatically. Occasionally, however,
you might want to clean up a value early. One example is when using smart
pointers that manage locks: you might want to force the <code>drop</code> method that
releases the lock to run so other code in the same scope can acquire the lock.
Rust doesn’t let you call the <code>Drop</code> trait’s <code>drop</code> method manually; instead
you have to call the <code>std::mem::drop</code> function provided by the standard library
if you want to force a value to be dropped before the end of its scope.</p>
<p>If we try to call the <code>Drop</code> trait’s <code>drop</code> method manually by modifying the
<code>main</code> function from Listing 15-14, as shown in Listing 15-15, we’ll get a
compiler error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<p><span class="caption">Listing 15-15: Attempting to call the <code>drop</code> method from
the <code>Drop</code> trait manually to clean up early</span></p>
<p>When we try to compile this code, we’ll get this error:</p>
<pre><code class="language-text">error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
</code></pre>
<p>This error message states that we’re not allowed to explicitly call <code>drop</code>. The
error message uses the term <em>destructor</em>, which is the general programming term
for a function that cleans up an instance. A <em>destructor</em> is analogous to a
<em>constructor</em>, which creates an instance. The <code>drop</code> function in Rust is one
particular destructor.</p>
<p>Rust doesn’t let us call <code>drop</code> explicitly because Rust would still
automatically call <code>drop</code> on the value at the end of <code>main</code>. This would be a
<em>double free</em> error because Rust would be trying to clean up the same value
twice.</p>
<p>We can’t disable the automatic insertion of <code>drop</code> when a value goes out of
scope, and we can’t call the <code>drop</code> method explicitly. So, if we need to force
a value to be cleaned up early, we can use the <code>std::mem::drop</code> function.</p>
<p>The <code>std::mem::drop</code> function is different than the <code>drop</code> method in the <code>Drop</code>
trait. We call it by passing the value we want to force to be dropped early as
an argument. The function is in the prelude, so we can modify <code>main</code> in Listing
15-15 to call the <code>drop</code> function, as shown in Listing 15-16:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct CustomSmartPointer {
#     data: String,
# }
#
# impl Drop for CustomSmartPointer {
#     fn drop(&amp;mut self) {
#         println!(&quot;Dropping CustomSmartPointer!&quot;);
#     }
# }
#
fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 15-16: Calling <code>std::mem::drop</code> to explicitly
drop a value before it goes out of scope</span></p>
<p>Running this code will print the following:</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>The text <code>Dropping CustomSmartPointer with data `some data`!</code> is printed
between the <code>CustomSmartPointer created.</code> and <code>CustomSmartPointer dropped before the end of main.</code> text, showing that the <code>drop</code> method code is called to
drop <code>c</code> at that point.</p>
<p>You can use code specified in a <code>Drop</code> trait implementation in many ways to
make cleanup convenient and safe: for instance, you could use it to create your
own memory allocator! With the <code>Drop</code> trait and Rust’s ownership system, you
don’t have to remember to clean up because Rust does it automatically.</p>
<p>You also don’t have to worry about problems resulting from accidentally
cleaning up values still in use: the ownership system that makes sure
references are always valid also ensures that <code>drop</code> gets called only once when
the value is no longer being used.</p>
<p>Now that we’ve examined <code>Box&lt;T&gt;</code> and some of the characteristics of smart
pointers, let’s look at a few other smart pointers defined in the standard
library.</p>
<a class="header" href="#rct-the-reference-counted-smart-pointer" id="rct-the-reference-counted-smart-pointer"><h2><code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</h2></a>
<p>In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn’t be cleaned up unless it doesn’t have any
edges pointing to it.</p>
<p>To enable multiple ownership, Rust has a type called <code>Rc&lt;T&gt;</code>, which is an
abbreviation for <em>reference counting</em>. The <code>Rc&lt;T&gt;</code> type keeps track of the
number of references to a value which determines whether or not a value is
still in use. If there are zero references to a value, the value can be cleaned
up without any references becoming invalid.</p>
<p>Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it’s no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for
multiple parts of our program to read and we can’t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data’s owner, and the normal ownership
rules enforced at compile time would take effect.</p>
<p>Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we’ll cover how to do reference counting in
multithreaded programs.</p>
<a class="header" href="#using-rct-to-share-data" id="using-rct-to-share-data"><h3>Using <code>Rc&lt;T&gt;</code> to Share Data</h3></a>
<p>Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using <code>Box&lt;T&gt;</code>. This time, we’ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3:</p>
<p><img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Figure 15-3: Two lists, <code>b</code> and <code>c</code>, sharing ownership of
a third list, <code>a</code></span></p>
<p>We’ll create list <code>a</code> that contains 5 and then 10. Then we’ll make two more
lists: <code>b</code> that starts with 3 and <code>c</code> that starts with 4. Both <code>b</code> and <code>c</code>
lists will then continue on to the first <code>a</code> list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.</p>
<p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T&gt;</code>
won’t work, as shown in Listing 15-17:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Listing 15-17: Demonstrating we’re not allowed to have
two lists using <code>Box&lt;T&gt;</code> that try to share ownership of a third list</span></p>
<p>When we compile this code, we get this error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
</code></pre>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code>
is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when
creating <code>c</code>, we’re not allowed to because <code>a</code> has been moved.</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. The borrow checker wouldn’t let us compile
<code>let a = Cons(10, &amp;Nil);</code> for example, because the temporary <code>Nil</code> value would
be dropped before <code>a</code> could take a reference to it.</p>
<p>Instead, we’ll change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> in place of
<code>Box&lt;T&gt;</code>, as shown in Listing 15-18. Each <code>Cons</code> variant will now hold a value
and an <code>Rc&lt;T&gt;</code> pointing to a <code>List</code>. When we create <code>b</code>, instead of taking
ownership of <code>a</code>, we’ll clone the <code>Rc&lt;List&gt;</code> that <code>a</code> is holding, thereby
increasing the number of references from one to two and letting <code>a</code> and <code>b</code>
share ownership of the data in that <code>Rc&lt;List&gt;</code>. We’ll also clone <code>a</code> when
creating <code>c</code>, increasing the number of references from two to three. Every time
we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List&gt;</code> will
increase, and the data won’t be cleaned up unless there are zero references to
it.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listing 15-18: A definition of <code>List</code> that uses
<code>Rc&lt;T&gt;</code></span></p>
<p>We need to add a <code>use</code> statement to bring <code>Rc&lt;T&gt;</code> into scope because it’s not
in the prelude. In <code>main</code>, we create the list holding 5 and 10 and store it in
a new <code>Rc&lt;List&gt;</code> in <code>a</code>. Then when we create <code>b</code> and <code>c</code>, we call the
<code>Rc::clone</code> function and pass a reference to the <code>Rc&lt;List&gt;</code> in <code>a</code> as an
argument.</p>
<p>We could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust’s
convention is to use <code>Rc::clone</code> in this case. The implementation of
<code>Rc::clone</code> doesn’t make a deep copy of all the data like most types’
implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using <code>Rc::clone</code> for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
<code>Rc::clone</code>.</p>
<a class="header" href="#cloning-an-rct-increases-the-reference-count" id="cloning-an-rct-increases-the-reference-count"><h3>Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</h3></a>
<p>Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the <code>Rc&lt;List&gt;</code> in <code>a</code>.</p>
<p>In Listing 15-19, we’ll change <code>main</code> so it has an inner scope around list <code>c</code>;
then we can see how the reference count changes when <code>c</code> goes out of scope.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># enum List {
#     Cons(i32, Rc&lt;List&gt;),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listing 15-19: Printing the reference count</span></p>
<p>At each point in the program where the reference count changes, we print the
reference count, which we can get by calling the <code>Rc::strong_count</code> function.
This function is named <code>strong_count</code> rather than <code>count</code> because the <code>Rc&lt;T&gt;</code>
type also has a <code>weak_count</code>; we’ll see what <code>weak_count</code> is used for in the
“Preventing Reference Cycles” section.</p>
<p>This code prints the following:</p>
<pre><code class="language-text">count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>We can see that the <code>Rc&lt;List&gt;</code> in <code>a</code> has an initial reference count of 1; then
each time we call <code>clone</code>, the count goes up by 1. When <code>c</code> goes out of scope,
the count goes down by 1. We don’t have to call a function to decrease the
reference count like we have to call <code>Rc::clone</code> to increase the reference
count: the implementation of the <code>Drop</code> trait decreases the reference count
automatically when an <code>Rc&lt;T&gt;</code> value goes out of scope.</p>
<p>What we can’t see in this example is that when <code>b</code> and then <code>a</code> go out of scope
at the end of <code>main</code>, the count is then 0, and the <code>Rc&lt;List&gt;</code> is cleaned up
completely at that point. Using <code>Rc&lt;T&gt;</code> allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.</p>
<p>Via immutable references, <code>Rc&lt;T&gt;</code> allows you to share data between multiple
parts of your program for reading only. If <code>Rc&lt;T&gt;</code> allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the <code>RefCell&lt;T&gt;</code>
type that you can use in conjunction with an <code>Rc&lt;T&gt;</code> to work with this
immutability restriction.</p>
<a class="header" href="#refcellt-and-the-interior-mutability-pattern" id="refcellt-and-the-interior-mutability-pattern"><h2><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</h2></a>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
<code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern
mutation and borrowing. We haven’t yet covered unsafe code; we will in
Chapter 19. We can use types that use the interior mutability pattern when we
can ensure that the borrowing rules will be followed at runtime, even though
the compiler can’t guarantee that. The <code>unsafe</code> code involved is then wrapped
in a safe API, and the outer type is still immutable.</p>
<p>Let’s explore this concept by looking at the <code>RefCell&lt;T&gt;</code> type that follows the
interior mutability pattern.</p>
<a class="header" href="#enforcing-borrowing-rules-at-runtime-with-refcellt" id="enforcing-borrowing-rules-at-runtime-with-refcellt"><h3>Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></h3></a>
<p>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data
it holds. So, what makes <code>RefCell&lt;T&gt;</code> different from a type like <code>Box&lt;T&gt;</code>?
Recall the borrowing rules you learned in Chapter 4:</p>
<ul>
<li>At any given time, you can have <em>either</em> (but not both of) one mutable
reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p>With references and <code>Box&lt;T&gt;</code>, the borrowing rules’ invariants are enforced at
compile time. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <em>at runtime</em>.
With references, if you break these rules, you’ll get a compiler error. With
<code>RefCell&lt;T&gt;</code>, if you break these rules, your program will panic and exit.</p>
<p>The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust’s default.</p>
<p>The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, whereas they are disallowed by
the compile-time checks. Static analysis, like the Rust compiler, is inherently
conservative. Some properties of code are impossible to detect by analyzing the
code: the most famous example is the Halting Problem, which is beyond the scope
of this book but is an interesting topic to research.</p>
<p>Because some analysis is impossible, if the Rust compiler can’t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, it’s conservative. If Rust accepted an incorrect program, users
wouldn’t be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The <code>RefCell&lt;T&gt;</code> type is useful when you’re sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.</p>
<p>Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. We’ll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a
multithreaded program in Chapter 16.</p>
<p>Here is a recap of the reasons to choose <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>
have single owners.</li>
<li><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code>
allows only immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows
immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can
mutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is
immutable.</li>
</ul>
<p>Mutating the value inside an immutable value is the <em>interior mutability</em>
pattern. Let’s look at a situation in which interior mutability is useful and
examine how it’s possible.</p>
<a class="header" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value" id="interior-mutability-a-mutable-borrow-to-an-immutable-value"><h3>Interior Mutability: A Mutable Borrow to an Immutable Value</h3></a>
<p>A consequence of the borrowing rules is that when you have an immutable value,
you can’t borrow it mutably. For example, this code won’t compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>If you tried to compile this code, you’d get the following error:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable local variable `x` as mutable
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &amp;mut x;
  |                  ^ cannot borrow mutably
</code></pre>
<p>However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
value’s methods would not be able to mutate the value. Using <code>RefCell&lt;T&gt;</code> is
one way to get the ability to have interior mutability. But <code>RefCell&lt;T&gt;</code>
doesn’t get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, you’ll get a <code>panic!</code> instead of
a compiler error.</p>
<p>Let’s work through a practical example where we can use <code>RefCell&lt;T&gt;</code> to mutate
an immutable value and see why that is useful.</p>
<a class="header" href="#a-use-case-for-interior-mutability-mock-objects" id="a-use-case-for-interior-mutability-mock-objects"><h4>A Use Case for Interior Mutability: Mock Objects</h4></a>
<p>A <em>test double</em> is the general programming concept for a type used in place of
another type during testing. <em>Mock objects</em> are specific types of test doubles
that record what happens during a test so you can assert that the correct
actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects,
and Rust doesn’t have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
user’s quota for the number of API calls they’re allowed to make, for example.</p>
<p>Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesn’t need to know
that detail. All it needs is something that implements a trait we’ll provide
called <code>Messenger</code>. Listing 15-20 shows the library code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 0.75 &amp;&amp; percentage_of_max &lt; 0.9 {
            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 &amp;&amp; percentage_of_max &lt; 1.0 {
            self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-20: A library to keep track of how close a
value is to a maximum value and warn when the value is at certain levels</span></p>
<p>One important part of this code is that the <code>Messenger</code> trait has one method
called <code>send</code> that takes an immutable reference to <code>self</code> and the text of the
message. This is the interface our mock object needs to have. The other
important part is that we want to test the behavior of the <code>set_value</code> method
on the <code>LimitTracker</code>. We can change what we pass in for the <code>value</code> parameter,
but <code>set_value</code> doesn’t return anything for us to make assertions on. We want
to be able to say that if we create a <code>LimitTracker</code> with something that
implements the <code>Messenger</code> trait and a particular value for <code>max</code>, when we pass
different numbers for <code>value</code>, the messenger is told to send the appropriate
messages.</p>
<p>We need a mock object that, instead of sending an email or text message when we
call <code>send</code>, will only keep track of the messages it’s told to send. We can
create a new instance of the mock object, create a <code>LimitTracker</code> that uses the
mock object, call the <code>set_value</code> method on <code>LimitTracker</code>, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker won’t allow it:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-21: An attempt to implement a <code>MockMessenger</code>
that isn’t allowed by the borrow checker</span></p>
<p>This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code>
field with a <code>Vec</code> of <code>String</code> values to keep track of the messages it’s told
to send. We also define an associated function <code>new</code> to make it convenient to
create new <code>MockMessenger</code> values that start with an empty list of messages. We
then implement the <code>Messenger</code> trait for <code>MockMessenger</code> so we can give a
<code>MockMessenger</code> to a <code>LimitTracker</code>. In the definition of the <code>send</code> method, we
take the message passed in as a parameter and store it in the <code>MockMessenger</code>
list of <code>sent_messages</code>.</p>
<p>In the test, we’re testing what happens when the <code>LimitTracker</code> is told to set
<code>value</code> to something that is more than 75 percent of the <code>max</code> value. First, we
create a new <code>MockMessenger</code>, which will start with an empty list of messages.
Then we create a new <code>LimitTracker</code> and give it a reference to the new
<code>MockMessenger</code> and a <code>max</code> value of 100. We call the <code>set_value</code> method on the
<code>LimitTracker</code> with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the <code>MockMessenger</code> is keeping track
of should now have one message in it.</p>
<p>However, there’s one problem with this test, as shown here:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
</code></pre>
<p>We can’t modify the <code>MockMessenger</code> to keep track of the messages, because the
<code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the
suggestion from the error text to use <code>&amp;mut self</code> instead, because then the
signature of <code>send</code> wouldn’t match the signature in the <code>Messenger</code> trait
definition (feel free to try and see what error message you get).</p>
<p>This is a situation in which interior mutability can help! We’ll store the
<code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code>, and then the <code>send</code> message will be
able to modify <code>sent_messages</code> to store the messages we’ve seen. Listing 15-22
shows what that looks like:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
#         limit_tracker.set_value(75);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-22: Using <code>RefCell&lt;T&gt;</code> to mutate an inner
value while the outer value is considered immutable</span></p>
<p>The <code>sent_messages</code> field is now of type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of
<code>Vec&lt;String&gt;</code>. In the <code>new</code> function, we create a new <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
instance around the empty vector.</p>
<p>For the implementation of the <code>send</code> method, the first parameter is still an
immutable borrow of <code>self</code>, which matches the trait definition. We call
<code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a
mutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is
the vector. Then we can call <code>push</code> on the mutable reference to the vector to
keep track of the messages sent during the test.</p>
<p>The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an
immutable reference to the vector.</p>
<p>Now that you’ve seen how to use <code>RefCell&lt;T&gt;</code>, let’s dig into how it works!</p>
<a class="header" href="#keeping-track-of-borrows-at-runtime-with-refcellt" id="keeping-track-of-borrows-at-runtime-with-refcellt"><h4>Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></h4></a>
<p>When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code>
syntax, respectively. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code> and <code>borrow_mut</code>
methods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code>. The
<code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code>, and <code>borrow_mut</code>
returns the smart pointer type <code>RefMut&lt;T&gt;</code>. Both types implement <code>Deref</code>, so we
can treat them like regular references.</p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart
pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code>
increases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code>
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable
borrows or one mutable borrow at any point in time.</p>
<p>If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of <code>RefCell&lt;T&gt;</code> will panic at
runtime. Listing 15-23 shows a modification of the implementation of <code>send</code> in
Listing 15-22. We’re deliberately trying to create two mutable borrows active
for the same scope to illustrate that <code>RefCell&lt;T&gt;</code> prevents us from doing this
at runtime.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics">impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
</code></pre>
<p><span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that <code>RefCell&lt;T&gt;</code> will panic</span></p>
<p>We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned
from <code>borrow_mut</code>. Then we create another mutable borrow in the same way in the
variable <code>two_borrow</code>. This makes two mutable references in the same scope,
which isn’t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:</p>
<pre><code class="language-text">---- tests::it_sends_an_over_75_percent_warning_message stdout ----
    thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Notice that the code panicked with the message <code>already borrowed: BorrowMutError</code>. This is how <code>RefCell&lt;T&gt;</code> handles violations of the borrowing
rules at runtime.</p>
<p>Catching borrowing errors at runtime rather than compile time means that you
would find a mistake in your code later in the development process and possibly
not until your code was deployed to production. Also, your code would incur a
small runtime performance penalty as a result of keeping track of the borrows
at runtime rather than compile time. However, using <code>RefCell&lt;T&gt;</code> makes it
possible to write a mock object that can modify itself to keep track of the
messages it has seen while you’re using it in a context where only immutable
values are allowed. You can use <code>RefCell&lt;T&gt;</code> despite its trade-offs to get more
functionality than regular references provide.</p>
<a class="header" href="#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt" id="having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><h3>Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></h3></a>
<p>A common way to use <code>RefCell&lt;T&gt;</code> is in combination with <code>Rc&lt;T&gt;</code>. Recall that
<code>Rc&lt;T&gt;</code> lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an <code>Rc&lt;T&gt;</code> that holds a <code>RefCell&lt;T&gt;</code>, you can
get a value that can have multiple owners <em>and</em> that you can mutate!</p>
<p>For example, recall the cons list example in Listing 15-18 where we used
<code>Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list. Because
<code>Rc&lt;T&gt;</code> holds only immutable values, we can’t change any of the values in the
list once we’ve created them. Let’s add in <code>RefCell&lt;T&gt;</code> to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
<code>RefCell&lt;T&gt;</code> in the <code>Cons</code> definition, we can modify the value stored in all
the lists:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listing 15-24: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a
<code>List</code> that we can mutate</span></p>
<p>We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a
variable named <code>value</code> so we can access it directly later. Then we create a
<code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code>. We need to clone
<code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather
than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from
<code>value</code>.</p>
<p>We wrap the list <code>a</code> in an <code>Rc&lt;T&gt;</code> so when we create lists <code>b</code> and <code>c</code>, they
can both refer to <code>a</code>, which is what we did in Listing 15-18.</p>
<p>After we’ve created the lists in <code>a</code>, <code>b</code>, and <code>c</code>, we add 10 to the value in
<code>value</code>. We do this by calling <code>borrow_mut</code> on <code>value</code>, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
“Where’s the <code>-&gt;</code> Operator?”) to dereference the <code>Rc&lt;T&gt;</code> to the inner
<code>RefCell&lt;T&gt;</code> value. The <code>borrow_mut</code> method returns a <code>RefMut&lt;T&gt;</code> smart
pointer, and we use the dereference operator on it and change the inner value.</p>
<p>When we print <code>a</code>, <code>b</code>, and <code>c</code>, we can see that they all have the modified
value of 15 rather than 5:</p>
<pre><code class="language-text">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>This technique is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we have an outwardly
immutable <code>List</code> value. But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and it’s
sometimes worth trading a bit of speed for this flexibility in our data
structures.</p>
<p>The standard library has other types that provide interior mutability, such as
<code>Cell&lt;T&gt;</code>, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the <code>Cell&lt;T&gt;</code>. There’s also
<code>Mutex&lt;T&gt;</code>, which offers interior mutability that’s safe to use across threads;
we’ll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.</p>
<a class="header" href="#reference-cycles-can-leak-memory" id="reference-cycles-can-leak-memory"><h2>Reference Cycles Can Leak Memory</h2></a>
<p>Rust’s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a <em>memory leak</em>).
Preventing memory leaks entirely is not one of Rust’s guarantees in the same
way that disallowing data races at compile time is, meaning memory leaks are
memory safe in Rust. We can see that Rust allows memory leaks by using <code>Rc&lt;T&gt;</code>
and <code>RefCell&lt;T&gt;</code>: it’s possible to create references where items refer to each
other in a cycle. This creates memory leaks because the reference count of each
item in the cycle will never reach 0, and the values will never be dropped.</p>
<a class="header" href="#creating-a-reference-cycle" id="creating-a-reference-cycle"><h3>Creating a Reference Cycle</h3></a>
<p>Let’s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing
15-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Hidden fn main is here to disable the automatic wrapping in fn main that
doc tests do; the `use List` fails if this listing is put within a main -->
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 15-25: A cons list definition that holds a
<code>RefCell&lt;T&gt;</code> so we can modify what a <code>Cons</code> variant is referring to</span></p>
<p>We’re using another variation of the <code>List</code> definition in Listing 15-25. The
second element in the <code>Cons</code> variant is now <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that
instead of having the ability to modify the <code>i32</code> value as we did in Listing
15-24, we want to modify which <code>List</code> value a <code>Cons</code> variant is pointing to.
We’re also adding a <code>tail</code> method to make it convenient for us to access the
second item if we have a <code>Cons</code> variant.</p>
<p>In Listing 15-26, we’re adding a <code>main</code> function that uses the definitions in
Listing 15-25. This code creates a list in <code>a</code> and a list in <code>b</code> that points to
the list in <code>a</code>. Then it modifies the list in <code>a</code> to point to <code>b</code>, creating a
reference cycle. There are <code>println!</code> statements along the way to show what the
reference counts are at various points in this process.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use List::{Cons, Nil};
# use std::rc::Rc;
# use std::cell::RefCell;
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
#     Nil,
# }
#
# impl List {
#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
#         match self {
#             Cons(_, item) =&gt; Some(item),
#             Nil =&gt; None,
#         }
#     }
# }
#
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Listing 15-26: Creating a reference cycle of two <code>List</code>
values pointing to each other</span></p>
<p>We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code>
with an initial list of <code>5, Nil</code>. We then create an <code>Rc&lt;List&gt;</code> instance
holding another <code>List</code> value in the variable <code>b</code> that contains the value 10 and
points to the list in <code>a</code>.</p>
<p>We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We
do that by using the <code>tail</code> method to get a reference to the
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code>, which we put in the variable <code>link</code>. Then we use
the <code>borrow_mut</code> method on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside
from an <code>Rc&lt;List&gt;</code> that holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code>.</p>
<p>When we run this code, keeping the last <code>println!</code> commented out for the
moment, we’ll get this output:</p>
<pre><code class="language-text">a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> are 2
after we change the list in <code>a</code> to point to <code>b</code>. At the end of <code>main</code>, Rust
will try to drop <code>b</code> first, which will decrease the count in each of the
<code>Rc&lt;List&gt;</code> instances in <code>a</code> and <code>b</code> by 1.</p>
<p>However, because <code>a</code> is still referencing the <code>Rc&lt;List&gt;</code> that was in <code>b</code>, that
<code>Rc&lt;List&gt;</code> has a count of 1 rather than 0, so the memory the <code>Rc&lt;List&gt;</code> has on
the heap won’t be dropped. The memory will just sit there with a count of 1,
forever. To visualize this reference cycle, we’ve created a diagram in Figure
15-4.</p>
<p><img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" /></p>
<p><span class="caption">Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code>
pointing to each other</span></p>
<p>If you uncomment the last <code>println!</code> and run the program, Rust will try to
print this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it
overflows the stack.</p>
<p>In this case, right after we create the reference cycle, the program ends. The
consequences of this cycle aren’t very dire. However, if a more complex program
allocated lots of memory in a cycle and held onto it for a long time, the
program would use more memory than it needed and might overwhelm the system,
causing it to run out of available memory.</p>
<p>Creating reference cycles is not easily done, but it’s not impossible either.
If you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you don’t create cycles; you can’t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.</p>
<p>Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references don’t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want <code>Cons</code>
variants to own their list, so reorganizing the data structure isn’t possible.
Let’s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.</p>
<a class="header" href="#preventing-reference-cycles-turning-an-rct-into-a-weakt" id="preventing-reference-cycles-turning-an-rct-into-a-weakt"><h3>Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></h3></a>
<p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the
<code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned
up if its <code>strong_count</code> is 0. You can also create a <em>weak reference</em> to the
value within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a
reference to the <code>Rc&lt;T&gt;</code>. When you call <code>Rc::downgrade</code>, you get a smart
pointer of type <code>Weak&lt;T&gt;</code>. Instead of increasing the <code>strong_count</code> in the
<code>Rc&lt;T&gt;</code> instance by 1, calling <code>Rc::downgrade</code> increases the <code>weak_count</code> by 1.
The <code>Rc&lt;T&gt;</code> type uses <code>weak_count</code> to keep track of how many <code>Weak&lt;T&gt;</code>
references exist, similar to <code>strong_count</code>. The difference is the <code>weak_count</code>
doesn’t need to be 0 for the <code>Rc&lt;T&gt;</code> instance to be cleaned up.</p>
<p>Strong references are how you can share ownership of an <code>Rc&lt;T&gt;</code> instance. Weak
references don’t express an ownership relationship. They won’t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do
anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to, you must make sure the
value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code>
instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code>Some</code>
if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the
<code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;T&gt;</code>, Rust
will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and there
won’t be an invalid pointer.</p>
<p>As an example, rather than using a list whose items know only about the next
item, we’ll create a tree whose items know about their children items <em>and</em>
their parent items.</p>
<a class="header" href="#creating-a-tree-data-structure-a-node-with-child-nodes" id="creating-a-tree-data-structure-a-node-with-child-nodes"><h4>Creating a Tree Data Structure: a <code>Node</code> with Child Nodes</h4></a>
<p>To start, we’ll build a tree with nodes that know about their child nodes.
We’ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as
references to its children <code>Node</code> values:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with
variables so we can access each <code>Node</code> in the tree directly. To do this, we
define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to
modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in
<code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Next, we’ll use our struct definition and create one <code>Node</code> instance named
<code>leaf</code> with the value 3 and no children, and another instance named <code>branch</code>
with the value 5 and <code>leaf</code> as one of its children, as shown in Listing 15-27:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::Rc;
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">Listing 15-27: Creating a <code>leaf</code> node with no children
and a <code>branch</code> node with <code>leaf</code> as one of its children</span></p>
<p>We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code>, meaning the
<code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>. We can get from
<code>branch</code> to <code>leaf</code> through <code>branch.children</code>, but there’s no way to get from
<code>leaf</code> to <code>branch</code>. The reason is that <code>leaf</code> has no reference to <code>branch</code> and
doesn’t know they’re related. We want <code>leaf</code> to know that <code>branch</code> is its
parent. We’ll do that next.</p>
<a class="header" href="#adding-a-reference-from-a-child-to-its-parent" id="adding-a-reference-from-a-child-to-its-parent"><h4>Adding a Reference from a Child to Its Parent</h4></a>
<p>To make the child node aware of its parent, we need to add a <code>parent</code> field to
our <code>Node</code> struct definition. The trouble is in deciding what the type of
<code>parent</code> should be. We know it can’t contain an <code>Rc&lt;T&gt;</code>, because that would
create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and
<code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code>
values to never be 0.</p>
<p>Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!</p>
<p>So instead of <code>Rc&lt;T&gt;</code>, we’ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,
specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks
like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>A node will be able to refer to its parent node but doesn’t own its parent.
In Listing 15-28, we update <code>main</code> to use this new definition so the <code>leaf</code>
node will have a way to refer to its parent, <code>branch</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Listing 15-28: A <code>leaf</code> node with a weak reference to its
parent node <code>branch</code></span></p>
<p>Creating the <code>leaf</code> node looks similar to how creating the <code>leaf</code> node looked
in Listing 15-27 with the exception of the <code>parent</code> field: <code>leaf</code> starts out
without a parent, so we create a new, empty <code>Weak&lt;Node&gt;</code> reference instance.</p>
<p>At this point, when we try to get a reference to the parent of <code>leaf</code> by using
the <code>upgrade</code> method, we get a <code>None</code> value. We see this in the output from the
first <code>println!</code> statement:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code>
reference in the <code>parent</code> field, because <code>branch</code> doesn’t have a parent node.
We still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the
<code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code>
reference to its parent. We use the <code>borrow_mut</code> method on the
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the
<code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from
the <code>Rc&lt;Node&gt;</code> in <code>branch.</code></p>
<p>When we print the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code> variant
holding <code>branch</code>: now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The lack of infinite output indicates that this code didn’t create a reference
cycle. We can also tell this by looking at the values we get from calling
<code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<a class="header" href="#visualizing-changes-to-strong_count-and-weak_count" id="visualizing-changes-to-strong_count-and-weak_count"><h4>Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></h4></a>
<p>Let’s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code>
instances change by creating a new inner scope and moving the creation of
<code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">Listing 15-29: Creating <code>branch</code> in an inner scope and
examining strong and weak reference counts</span></p>
<p>After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak
count of 0. In the inner scope, we create <code>branch</code> and associate it with
<code>leaf</code>, at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code>
will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing
to <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we’ll see
it will have a strong count of 2, because <code>branch</code> now has a clone of the
<code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code>, but will still have a weak
count of 0.</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope and the strong count of
the <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped. The weak count of 1
from <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we
don’t get any memory leaks!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get
<code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong
count of 1 and a weak count of 0, because the variable <code>leaf</code> is now the only
reference to the <code>Rc&lt;Node&gt;</code> again.</p>
<p>All of the logic that manages the counts and value dropping is built into
<code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait. By
specifying that the relationship from a child to its parent should be a
<code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, you’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.</p>
<a class="header" href="#summary-2" id="summary-2"><h2>Summary</h2></a>
<p>This chapter covered how to use smart pointers to make different guarantees and
trade-offs than those Rust makes by default with regular references. The
<code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The
<code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so
that data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.</p>
<p>Also discussed were the <code>Deref</code> and <code>Drop</code> traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using <code>Weak&lt;T&gt;</code>.</p>
<p>If this chapter has piqued your interest and you want to implement your own
smart pointers, check out <a href="https://doc.rust-lang.org/stable/nomicon/">“The Rustonomicon”</a> for more useful
information.</p>
<p>Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new
smart pointers.</p>
<a class="header" href="#fearless-concurrency" id="fearless-concurrency"><h1>Fearless Concurrency</h1></a>
<p>Handling concurrent programming safely and efficiently is another of Rust’s
major goals. <em>Concurrent programming</em>, where different parts of a program
execute independently, and <em>parallel programming</em>, where different parts of a
program execute at the same time, are becoming increasingly important as more
computers take advantage of their multiple processors. Historically,
programming in these contexts has been difficult and error prone: Rust hopes to
change that.</p>
<p>Initially, the Rust team thought that ensuring memory safety and preventing
concurrency problems were two separate challenges to be solved with different
methods. Over time, the team discovered that the ownership and type systems are
a powerful set of tools to help manage memory safety <em>and</em> concurrency
problems! By leveraging ownership and type checking, many concurrency errors
are compile-time errors in Rust rather than runtime errors. Therefore, rather
than making you spend lots of time trying to reproduce the exact circumstances
under which a runtime concurrency bug occurs, incorrect code will refuse to
compile and present an error explaining the problem. As a result, you can fix
your code while you’re working on it rather than potentially after it has been
shipped to production. We’ve nicknamed this aspect of Rust <em>fearless</em>
<em>concurrency</em>. Fearless concurrency allows you to write code that is free of
subtle bugs and is easy to refactor without introducing new bugs.</p>
<blockquote>
<p>Note: For simplicity’s sake, we’ll refer to many of the problems as
<em>concurrent</em> rather than being more precise by saying <em>concurrent and/or
parallel</em>. If this book were about concurrency and/or parallelism, we’d be
more specific. For this chapter, please mentally substitute <em>concurrent
and/or parallel</em> whenever we use <em>concurrent</em>.</p>
</blockquote>
<p>Many languages are dogmatic about the solutions they offer for handling
concurrent problems. For example, Erlang has elegant functionality for
message-passing concurrency but has only obscure ways to share state between
threads. Supporting only a subset of possible solutions is a reasonable
strategy for higher-level languages, because a higher-level language promises
benefits from giving up some control to gain abstractions. However, lower-level
languages are expected to provide the solution with the best performance in any
given situation and have fewer abstractions over the hardware. Therefore, Rust
offers a variety of tools for modeling problems in whatever way is appropriate
for your situation and requirements.</p>
<p>Here are the topics we’ll cover in this chapter:</p>
<ul>
<li>How to create threads to run multiple pieces of code at the same time</li>
<li><em>Message-passing</em> concurrency, where channels send messages between threads</li>
<li><em>Shared-state</em> concurrency, where multiple threads have access to some piece
of data</li>
<li>The <code>Sync</code> and <code>Send</code> traits, which extend Rust’s concurrency guarantees to
user-defined types as well as types provided by the standard library</li>
</ul>
<a class="header" href="#using-threads-to-run-code-simultaneously" id="using-threads-to-run-code-simultaneously"><h2>Using Threads to Run Code Simultaneously</h2></a>
<p>In most current operating systems, an executed program’s code is run in a
<em>process</em>, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
features that run these independent parts are called <em>threads</em>.</p>
<p>Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, there’s no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:</p>
<ul>
<li>Race conditions, where threads are accessing data or resources in an
inconsistent order</li>
<li>Deadlocks, where two threads are waiting for each other to finish using a
resource the other thread has, preventing both threads from continuing</li>
<li>Bugs that happen only in certain situations and are hard to reproduce and fix
reliably</li>
</ul>
<p>Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.</p>
<p>Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called <em>1:1</em>,
meaning one operating system thread per one language thread.</p>
<p>Many programming languages provide their own special implementation of threads.
Programming language-provided threads are known as <em>green</em> threads, and
languages that use these green threads will execute them in the context of a
different number of operating system threads. For this reason, the
green-threaded model is called the <em>M:N</em> model: there are <code>M</code> green threads per
<code>N</code> operating system threads, where <code>M</code> and <code>N</code> are not necessarily the same
number.</p>
<p>Each model has its own advantages and trade-offs, and the trade-off most
important to Rust is runtime support. <em>Runtime</em> is a confusing term and can
have different meanings in different contexts.</p>
<p>In this context, by <em>runtime</em> we mean code that is included by the language in
every binary. This code can be large or small depending on the language, but
every non-assembly language will have some amount of runtime code. For that
reason, colloquially when people say a language has “no runtime,” they often
mean “small runtime.” Smaller runtimes have fewer features but have the
advantage of resulting in smaller binaries, which make it easier to combine the
language with other languages in more contexts. Although many languages are
okay with increasing the runtime size in exchange for more features, Rust needs
to have nearly no runtime and cannot compromise on being able to call into C to
maintain performance.</p>
<p>The green-threading M:N model requires a larger language runtime to manage
threads. As such, the Rust standard library only provides an implementation of
1:1 threading. Because Rust is such a low-level language, there are crates that
implement M:N threading if you would rather trade overhead for aspects such as
more control over which threads run when and lower costs of context switching,
for example.</p>
<p>Now that we’ve defined threads in Rust, let’s explore how to use the
thread-related API provided by the standard library.</p>
<a class="header" href="#creating-a-new-thread-with-spawn" id="creating-a-new-thread-with-spawn"><h3>Creating a New Thread with <code>spawn</code></h3></a>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span></p>
<p>Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until <code>i</code> is 9, it only got to 5
before the main thread shut down.</p>
<p>If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.</p>
<a class="header" href="#waiting-for-all-threads-to-finish-using-join-handles" id="waiting-for-all-threads-to-finish-using-join-handles"><h3>Waiting for All Threads to Finish Using <code>join</code> Handles</h3></a>
<p>The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but also can’t guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!</p>
<p>We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of <code>thread::spawn</code> in a variable.
The return type of <code>thread::spawn</code> is <code>JoinHandle</code>. A <code>JoinHandle</code> is an owned
value that, when we call the <code>join</code> method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the <code>JoinHandle</code> of the thread we created
in Listing 16-1 and call <code>join</code> to make sure the spawned thread finishes before
<code>main</code> exits:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-2: Saving a <code>JoinHandle</code> from <code>thread::spawn</code>
to guarantee the thread is run to completion</span></p>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the
thread represented by the handle terminates. <em>Blocking</em> a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to <code>join</code> after the main thread’s <code>for</code> loop, running Listing 16-2 should
produce output similar to this:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads continue alternating, but the main thread waits because of the
call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>But let’s see what happens when we instead move <code>handle.join()</code> before the
<code>for</code> loop in <code>main</code>, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>The main thread will wait for the spawned thread to finish and then run its
<code>for</code> loop, so the output won’t be interleaved anymore, as shown here:</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Small details, such as where <code>join</code> is called, can affect whether or not your
threads run at the same time.</p>
<a class="header" href="#using-move-closures-with-threads" id="using-move-closures-with-threads"><h3>Using <code>move</code> Closures with Threads</h3></a>
<p>The <code>move</code> closure is often used alongside <code>thread::spawn</code> because it allows
you to use data from one thread in another thread.</p>
<p>In Chapter 13, we mentioned we can use the <code>move</code> keyword before the parameter
list of a closure to force the closure to take ownership of the values it uses
in the environment. This technique is especially useful when creating new
threads in order to transfer ownership of values from one thread to another.</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t yet work, as you’ll see in a moment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span></p>
<p>The closure uses <code>v</code>, so it will capture <code>v</code> and make it part of the closure’s
environment. Because <code>thread::spawn</code> runs this closure in a new thread, we
should be able to access <code>v</code> inside that new thread. But when we compile this
example, we get the following error:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference
to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know if the reference
to <code>v</code> will always be valid.</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code>
that won’t be valid:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to <code>v</code> from a main thread that drops <code>v</code></span></p>
<p>If we were allowed to run this code, there’s a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to <code>v</code> inside, but the main thread immediately drops
<code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it
is also invalid. Oh no!</p>
<p>To fix the compiler error in Listing 16-3, we can use the error message’s
advice:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-5: Using the <code>move</code> keyword to force a closure
to take ownership of the values it uses</span></p>
<p>What would happen to the code in Listing 16-4 where the main thread called
<code>drop</code> if we use a <code>move</code> closure? Would <code>move</code> fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isn’t allowed for a different reason. If we added <code>move</code> to the closure, we
would move <code>v</code> into the closure’s environment, and we could no longer call
<code>drop</code> on it in the main thread. We would get this compiler error instead:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<p>Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of <code>v</code> to the spawned
thread, we’re guaranteeing Rust that the main thread won’t use <code>v</code> anymore. If
we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.</p>
<p>With a basic understanding of threads and the thread API, let’s look at what we
can <em>do</em> with threads.</p>
<a class="header" href="#using-message-passing-to-transfer-data-between-threads" id="using-message-passing-to-transfer-data-between-threads"><h2>Using Message Passing to Transfer Data Between Threads</h2></a>
<p>One increasingly popular approach to ensuring safe concurrency is <em>message
passing</em>, where threads or actors communicate by sending each other messages
containing data. Here’s the idea in a slogan from <a href="http://golang.org/doc/effective_go.html">the Go language
documentation</a>: “Do not communicate by
sharing memory; instead, share memory by communicating.”</p>
<p>One major tool Rust has for accomplishing message-sending concurrency is the
<em>channel</em>, a programming concept that Rust’s standard library provides an
implementation of. You can imagine a channel in programming as being like a
channel of water, such as a stream or a river. If you put something like a
rubber duck or boat into a stream, it will travel downstream to the end of the
waterway.</p>
<p>A channel in programming has two halves: a transmitter and a receiver. The
transmitter half is the upstream location where you put rubber ducks into the
river, and the receiver half is where the rubber duck ends up downstream. One
part of your code calls methods on the transmitter with the data you want to
send, and another part checks the receiving end for arriving messages. A
channel is said to be <em>closed</em> if either the transmitter or receiver half is
dropped.</p>
<p>Here, we’ll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We’ll be sending simple values between threads using a channel
to illustrate the feature. Once you’re familiar with the technique, you could
use channels to implement a chat system or a system where many threads perform
parts of a calculation and send the parts to one thread that aggregates the
results.</p>
<p>First, in Listing 16-6, we’ll create a channel but not do anything with it.
Note that this won’t compile yet because Rust can’t tell what type of values we
want to send over the channel.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
#     tx.send(()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to <code>tx</code> and <code>rx</code></span></p>
<p>We create a new channel using the <code>mpsc::channel</code> function; <code>mpsc</code> stands for
<em>multiple producer, single consumer</em>. In short, the way Rust’s standard library
implements channels means a channel can have multiple <em>sending</em> ends that
produce values but only one <em>receiving</em> end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. We’ll start with a single
producer for now, but we’ll add multiple producers when we get this example
working.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>The <code>mpsc::channel</code> function returns a tuple, the first element of which is the
sending end and the second element is the receiving end. The abbreviations <code>tx</code>
and <code>rx</code> are traditionally used in many fields for <em>transmitter</em> and <em>receiver</em>
respectively, so we name our variables as such to indicate each end. We’re
using a <code>let</code> statement with a pattern that destructures the tuples; we’ll
discuss the use of patterns in <code>let</code> statements and destructuring in
Chapter 18. Using a <code>let</code> statement this way is a convenient approach to
extract the pieces of the tuple returned by <code>mpsc::channel</code>.</p>
<p>Let’s move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Listing 16-7: Moving <code>tx</code> to a spawned thread and sending
“hi”</span></p>
<p>Again, we’re using <code>thread::spawn</code> to create a new thread and then using <code>move</code>
to move <code>tx</code> into the closure so the spawned thread owns <code>tx</code>. The spawned
thread needs to own the transmitting end of the channel to be able to send
messages through the channel.</p>
<p>The transmitting end has a <code>send</code> method that takes the value we want to send.
The <code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type, so if the receiving end has
already been dropped and there’s nowhere to send a value, the send operation
will return an error. In this example, we’re calling <code>unwrap</code> to panic in case
of an error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.</p>
<p>In Listing 16-8, we’ll get the value from the receiving end of the channel in
the main thread. This is like retrieving the rubber duck from the water at the
end of the river or like getting a chat message.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Listing 16-8: Receiving the value “hi” in the main thread
and printing it</span></p>
<p>The receiving end of a channel has two useful methods: <code>recv</code> and <code>try_recv</code>.
We’re using <code>recv</code>, short for <em>receive</em>, which will block the main thread’s
execution and wait until a value is sent down the channel. Once a value is
sent, <code>recv</code> will return it in a <code>Result&lt;T, E&gt;</code>. When the sending end of the
channel closes, <code>recv</code> will return an error to signal that no more values will
be coming.</p>
<p>The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result&lt;T, E&gt;</code>
immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code>
value if there aren’t any messages this time. Using <code>try_recv</code> is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls <code>try_recv</code> every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.</p>
<p>We’ve used <code>recv</code> in this example for simplicity; we don’t have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.</p>
<p>When we run the code in Listing 16-8, we’ll see the value printed from the main
thread:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>Perfect!</p>
<a class="header" href="#channels-and-ownership-transference" id="channels-and-ownership-transference"><h3>Channels and Ownership Transference</h3></a>
<p>The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Let’s do
an experiment to show how channels and ownership work together to prevent
problems: we’ll try to use a <code>val</code> value in the spawned thread <em>after</em> we’ve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn’t allowed:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">Listing 16-9: Attempting to use <code>val</code> after we’ve sent it
down the channel</span></p>
<p>Here, we try to print <code>val</code> after we’ve sent it down the channel via <code>tx.send</code>.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread’s modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
not implement the `Copy` trait
</code></pre>
<p>Our concurrency mistake has caused a compile time error. The <code>send</code> function
takes ownership of its parameter, and when the value is moved, the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.</p>
<a class="header" href="#sending-multiple-values-and-seeing-the-receiver-waiting" id="sending-multiple-values-and-seeing-the-receiver-waiting"><h3>Sending Multiple Values and Seeing the Receiver Waiting</h3></a>
<p>The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that
two separate threads were talking to each other over the channel. In Listing
16-10 we’ve made some modifications that will prove the code in Listing 16-8 is
running concurrently: the spawned thread will now send multiple messages and
pause for a second between each message.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-10: Sending multiple messages and pausing
between each</span></p>
<p>This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the <code>thread::sleep</code> function with a <code>Duration</code> value of
1 second.</p>
<p>In the main thread, we’re not calling the <code>recv</code> function explicitly anymore:
instead, we’re treating <code>rx</code> as an iterator. For each value received, we’re
printing it. When the channel is closed, iteration will end.</p>
<p>When running the code in Listing 16-10, you should see the following output
with a 1-second pause in between each line:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Because we don’t have any code that pauses or delays in the <code>for</code> loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.</p>
<a class="header" href="#creating-multiple-producers-by-cloning-the-transmitter" id="creating-multiple-producers-by-cloning-the-transmitter"><h3>Creating Multiple Producers by Cloning the Transmitter</h3></a>
<p>Earlier we mentioned that <code>mpsc</code> was an acronym for <em>multiple producer,
single consumer</em>. Let’s put <code>mpsc</code> to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitting half of the channel, as shown in Listing 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::thread;
# use std::sync::mpsc;
# use std::time::Duration;
#
# fn main() {
// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&amp;tx);
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!(&quot;Got: {}&quot;, received);
}

// --snip--
# }
</code></pre></pre>
<p><span class="caption">Listing 16-11: Sending multiple messages from multiple
producers</span></p>
<p>This time, before we create the first spawned thread, we call <code>clone</code> on the
sending end of the channel. This will give us a new sending handle we can pass
to the first spawned thread. We pass the original sending end of the channel to
a second spawned thread. This gives us two threads, each sending different
messages to the receiving end of the channel.</p>
<p>When you run the code, your output should look something like this:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>You might see the values in another order; it depends on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
<code>thread::sleep</code>, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.</p>
<p>Now that we’ve looked at how channels work, let’s look at a different method of
concurrency.</p>
<a class="header" href="#shared-state-concurrency" id="shared-state-concurrency"><h2>Shared-State Concurrency</h2></a>
<p>Message passing is a fine way of handling concurrency, but it’s not the only
one. Consider this part of the slogan from the Go language documentation again:
“communicate by sharing memory.”</p>
<p>What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts not use it and do the opposite instead?</p>
<p>In a way, channels in any programming language are similar to single ownership,
because once you transfer a value down a channel, you should no longer use that
value. Shared memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rust’s type system
and ownership rules greatly assist in getting this management correct. For an
example, let’s look at mutexes, one of the more common concurrency primitives
for shared memory.</p>
<a class="header" href="#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time" id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time"><h3>Using Mutexes to Allow Access to Data from One Thread at a Time</h3></a>
<p><em>Mutex</em> is an abbreviation for <em>mutual exclusion</em>, as in, a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutex’s <em>lock</em>. The lock is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as <em>guarding</em> the data it holds via the locking system.</p>
<p>Mutexes have a reputation for being difficult to use because you have to
remember two rules:</p>
<ul>
<li>You must attempt to acquire the lock before using the data.</li>
<li>When you’re done with the data that the mutex guards, you must unlock the
data so other threads can acquire the lock.</li>
</ul>
<p>For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they’re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel won’t work
as planned!</p>
<p>Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust’s type
system and ownership rules, you can’t get locking and unlocking wrong.</p>
<a class="header" href="#the-api-of-mutext" id="the-api-of-mutext"><h4>The API of <code>Mutex&lt;T&gt;</code></h4></a>
<p>As an example of how to use a mutex, let’s start by using a mutex in a
single-threaded context, as shown in Listing 16-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">Listing 16-12: Exploring the API of <code>Mutex&lt;T&gt;</code> in a
single-threaded context for simplicity</span></p>
<p>As with many types, we create a <code>Mutex&lt;T&gt;</code> using the associated function <code>new</code>.
To access the data inside the mutex, we use the <code>lock</code> method to acquire the
lock. This call will block the current thread so it can’t do any work until
it’s our turn to have the lock.</p>
<p>The call to <code>lock</code> would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
<code>unwrap</code> and have this thread panic if we’re in that situation.</p>
<p>After we’ve acquired the lock, we can treat the return value, named <code>num</code> in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in <code>m</code>: <code>Mutex&lt;i32&gt;</code> is not an
<code>i32</code>, so we <em>must</em> acquire the lock to be able to use the <code>i32</code> value. We
can’t forget; the type system won’t let us access the inner <code>i32</code> otherwise.</p>
<p>As you might suspect, <code>Mutex&lt;T&gt;</code> is a smart pointer. More accurately, the call
to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>. This smart pointer
implements <code>Deref</code> to point at our inner data; the smart pointer also has a
<code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code>
goes out of scope, which happens at the end of the inner scope in Listing
16-12. As a result, we don’t risk forgetting to release the lock and blocking
the mutex from being used by other threads because the lock release happens
automatically.</p>
<p>After dropping the lock, we can print the mutex value and see that we were able
to change the inner <code>i32</code> to 6.</p>
<a class="header" href="#sharing-a-mutext-between-multiple-threads" id="sharing-a-mutext-between-multiple-threads"><h4>Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</h4></a>
<p>Now, let’s try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>.
We’ll spin up 10 threads and have them each increment a counter value by 1, so
the counter goes from 0 to 10. Note that the next few examples will have
compiler errors, and we’ll use those errors to learn more about using
<code>Mutex&lt;T&gt;</code> and how Rust helps us use it correctly. Listing 16-13 has our
starting example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listing 16-13: Ten threads each increment a counter
guarded by a <code>Mutex&lt;T&gt;</code></span></p>
<p>We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we
did in Listing 16-12. Next, we create 10 threads by iterating over a range
of numbers. We use <code>thread::spawn</code> and give all the threads the same closure,
one that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code>
by calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, <code>num</code> will go out of scope and release the
lock so another thread can acquire it.</p>
<p>In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call <code>join</code> on each handle to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.</p>
<p>We hinted that this example wouldn’t compile. Now let’s find out why!</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:10:27
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>The error message states that the <code>counter</code> value is moved into the closure and
then captured when we call <code>lock</code>. That description sounds like what we wanted,
but it’s not allowed!</p>
<p>Let’s figure this out by simplifying the program. Instead of making 10 threads
in a <code>for</code> loop, let’s just make two threads without a loop and see what
happens. Replace the first <code>for</code> loop in Listing 16-13 with this code instead:</p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();

        *num += 1;
    });
    handles.push(handle);

    let handle2 = thread::spawn(move || {
        let mut num2 = counter.lock().unwrap();

        *num2 += 1;
    });
    handles.push(handle2);

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p>We make two threads and change the variable names used with the second thread
to <code>handle2</code> and <code>num2</code>. When we run the code this time, compiling gives us the
following:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:16:24
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:26:29
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>Aha! The first error message indicates that <code>counter</code> is moved into the closure
for the thread associated with <code>handle</code>. That move is preventing us from
capturing <code>counter</code> when we try to call <code>lock</code> on it and store the result in
<code>num2</code> in the second thread! So Rust is telling us that we can’t move ownership
of <code>counter</code> into multiple threads. This was hard to see earlier because our
threads were in a loop, and Rust can’t point to different threads in different
iterations of the loop. Let’s fix the compiler error with a multiple-ownership
method we discussed in Chapter 15.</p>
<a class="header" href="#multiple-ownership-with-multiple-threads" id="multiple-ownership-with-multiple-threads"><h4>Multiple Ownership with Multiple Threads</h4></a>
<p>In Chapter 15, we gave a value multiple owners by using the smart pointer
<code>Rc&lt;T&gt;</code> to create a reference counted value. Let’s do the same here and see
what happens. We’ll wrap the <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14 and clone
the <code>Rc&lt;T&gt;</code> before moving ownership to the thread. Now that we’ve seen the
errors, we’ll also switch back to using the <code>for</code> loop, and we’ll keep the
<code>move</code> keyword with the closure.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listing 16-14: Attempting to use <code>Rc&lt;T&gt;</code> to allow
multiple threads to own the <code>Mutex&lt;T&gt;</code></span></p>
<p>Once again, we compile and get... different errors! The compiler is teaching us
a lot.</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied in `[closure@src/main.rs:11:36:
15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
  --&gt; src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is
not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
   = note: required by `std::thread::spawn`
</code></pre>
<p>Wow, that error message is very wordy! Here are some important parts to focus
on: the first inline error says <code>`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. The reason for this is in the next important
part to focus on, the error message. The distilled error message says <code>the trait bound `Send` is not satisfied</code>. We’ll talk about <code>Send</code> in the next
section: it’s one of the traits that ensures the types we use with threads are
meant for use in concurrent situations.</p>
<p>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads. When <code>Rc&lt;T&gt;</code>
manages the reference count, it adds to the count for each call to <code>clone</code> and
subtracts from the count when each clone is dropped. But it doesn’t use any
concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts—subtle bugs that
could in turn lead to memory leaks or a value being dropped before we’re done
with it. What we need is a type exactly like <code>Rc&lt;T&gt;</code> but one that makes changes
to the reference count in a thread-safe way.</p>
<a class="header" href="#atomic-reference-counting-with-arct" id="atomic-reference-counting-with-arct"><h4>Atomic Reference Counting with <code>Arc&lt;T&gt;</code></h4></a>
<p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in
concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it’s an <em>atomically
reference counted</em> type. Atomics are an additional kind of concurrency
primitive that we won’t cover in detail here: see the standard library
documentation for <code>std::sync::atomic</code> for more details. At this point, you just
need to know that atomics work like primitive types but are safe to share
across threads.</p>
<p>You might then wonder why all primitive types aren’t atomic and why standard
library types aren’t implemented to use <code>Arc&lt;T&gt;</code> by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you’re just performing operations on values within a
single thread, your code can run faster if it doesn’t have to enforce the
guarantees atomics provide.</p>
<p>Let’s return to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> have the same API, so we fix
our program by changing the <code>use</code> line, the call to <code>new</code>, and the call to
<code>clone</code>. The code in Listing 16-15 will finally compile and run:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Listing 16-15: Using an <code>Arc&lt;T&gt;</code> to wrap the <code>Mutex&lt;T&gt;</code>
to be able to share ownership across multiple threads</span></p>
<p>This code will print the following:</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about <code>Mutex&lt;T&gt;</code> and thread safety. You could also use this
program’s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a <code>Mutex&lt;T&gt;</code> to have each
thread update the final result with its part.</p>
<a class="header" href="#similarities-between-refcelltrct-and-mutextarct" id="similarities-between-refcelltrct-and-mutextarct"><h3>Similarities Between <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></h3></a>
<p>You might have noticed that <code>counter</code> is immutable but we could get a mutable
reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides interior
mutability, as the <code>Cell</code> family does. In the same way we used <code>RefCell&lt;T&gt;</code> in
Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we use <code>Mutex&lt;T&gt;</code>
to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>Another detail to note is that Rust can’t protect you from all kinds of logic
errors when you use <code>Mutex&lt;T&gt;</code>. Recall in Chapter 15 that using <code>Rc&lt;T&gt;</code> came
with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to
each other, causing memory leaks. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of
creating <em>deadlocks</em>. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers
useful information.</p>
<p>We’ll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and
how we can use them with custom types.</p>
<a class="header" href="#extensible-concurrency-with-the-sync-and-send-traits" id="extensible-concurrency-with-the-sync-and-send-traits"><h2>Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</h2></a>
<p>Interestingly, the Rust language has <em>very</em> few concurrency features. Almost
every concurrency feature we’ve talked about so far in this chapter has been
part of the standard library, not the language. Your options for handling
concurrency are not limited to the language or the standard library; you can
write your own concurrency features or use those written by others.</p>
<p>However, two concurrency concepts are embedded in the language: the
<code>std::marker</code> traits <code>Sync</code> and <code>Send</code>.</p>
<a class="header" href="#allowing-transference-of-ownership-between-threads-with-send" id="allowing-transference-of-ownership-between-threads-with-send"><h3>Allowing Transference of Ownership Between Threads with <code>Send</code></h3></a>
<p>The <code>Send</code> marker trait indicates that ownership of the type implementing
<code>Send</code> can be transferred between threads. Almost every Rust type is <code>Send</code>,
but there are some exceptions, including <code>Rc&lt;T&gt;</code>: this cannot be <code>Send</code> because
if you cloned an <code>Rc&lt;T&gt;</code> value and tried to transfer ownership of the clone to
another thread, both threads might update the reference count at the same time.
For this reason, <code>Rc&lt;T&gt;</code> is implemented for use in single-threaded situations
where you don’t want to pay the thread-safe performance penalty.</p>
<p>Therefore, Rust’s type system and trait bounds ensure that you can never
accidentally send an <code>Rc&lt;T&gt;</code> value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. When we switched to <code>Arc&lt;T&gt;</code>, which is <code>Send</code>, the code
compiled.</p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as
well. Almost all primitive types are <code>Send</code>, aside from raw pointers, which
we’ll discuss in Chapter 19.</p>
<a class="header" href="#allowing-access-from-multiple-threads-with-sync" id="allowing-access-from-multiple-threads-with-sync"><h3>Allowing Access from Multiple Threads with <code>Sync</code></h3></a>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing
<code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code> is
<code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code>, meaning the reference can be
sent safely to another thread. Similar to <code>Send</code>, primitive types are <code>Sync</code>,
and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p>The smart pointer <code>Rc&lt;T&gt;</code> is also not <code>Sync</code> for the same reasons that it’s not
<code>Send</code>. The <code>RefCell&lt;T&gt;</code> type (which we talked about in Chapter 15) and the
family of related <code>Cell&lt;T&gt;</code> types are not <code>Sync</code>. The implementation of borrow
checking that <code>RefCell&lt;T&gt;</code> does at runtime is not thread-safe. The smart
pointer <code>Mutex&lt;T&gt;</code> is <code>Sync</code> and can be used to share access with multiple
threads as you saw in the “Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads”
section.</p>
<a class="header" href="#implementing-send-and-sync-manually-is-unsafe" id="implementing-send-and-sync-manually-is-unsafe"><h3>Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe</h3></a>
<p>Because types that are made up of <code>Send</code> and <code>Sync</code> traits are automatically
also <code>Send</code> and <code>Sync</code>, we don’t have to implement those traits manually. As
marker traits, they don’t even have any methods to implement. They’re just
useful for enforcing invariants related to concurrency.</p>
<p>Manually implementing these traits involves implementing unsafe Rust code.
We’ll talk about using unsafe Rust code in Chapter 19; for now, the important
information is that building new concurrent types not made up of <code>Send</code> and
<code>Sync</code> parts requires careful thought to uphold the safety guarantees.
<a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon</a> has more information about these guarantees and how to
uphold them.</p>
<a class="header" href="#summary-3" id="summary-3"><h2>Summary</h2></a>
<p>This isn’t the last you’ll see of concurrency in this book: the project in
Chapter 20 will use the concepts in this chapter in a more realistic situation
than the smaller examples discussed here.</p>
<p>As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.</p>
<p>The Rust standard library provides channels for message passing and smart
pointer types, such as <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won’t end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!</p>
<p>Next, we’ll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms
relate to those you might be familiar with from object-oriented programming.</p>
<a class="header" href="#object-oriented-programming-features-of-rust" id="object-oriented-programming-features-of-rust"><h1>Object Oriented Programming Features of Rust</h1></a>
<p>Object-oriented programming (OOP) is a way of modeling programs. Objects came
from Simula in the 1960s. Those objects influenced Alan Kay’s programming
architecture in which objects pass messages to each other. He coined the term
<em>object-oriented programming</em> in 1967 to describe this architecture. Many
competing definitions describe what OOP is; some definitions would classify
Rust as object oriented, but other definitions would not. In this chapter,
we’ll explore certain characteristics that are commonly considered object
oriented and how those characteristics translate to idiomatic Rust. We’ll then
show you how to implement an object-oriented design pattern in Rust and discuss
the trade-offs of doing so versus implementing a solution using some of Rust’s
strengths instead.</p>
<a class="header" href="#characteristics-of-object-oriented-languages" id="characteristics-of-object-oriented-languages"><h2>Characteristics of Object-Oriented Languages</h2></a>
<p>There is no consensus in the programming community about what features a
language must have to be considered object oriented. Rust is influenced by many
programming paradigms, including OOP; for example, we explored the features
that came from functional programming in Chapter 13. Arguably, OOP languages
share certain common characteristics, namely objects, encapsulation, and
inheritance. Let’s look at what each of those characteristics means and whether
Rust supports it.</p>
<a class="header" href="#objects-contain-data-and-behavior" id="objects-contain-data-and-behavior"><h3>Objects Contain Data and Behavior</h3></a>
<p>The book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley
Professional, 1994) colloquially referred to as <em>The Gang of Four</em> book, is a
catalog of object-oriented design patterns. It defines OOP this way:</p>
<blockquote>
<p>Object-oriented programs are made up of objects. An <em>object</em> packages both
data and the procedures that operate on that data. The procedures are
typically called <em>methods</em> or <em>operations</em>.</p>
</blockquote>
<p>Using this definition, Rust is object oriented: structs and enums have data,
and <code>impl</code> blocks provide methods on structs and enums. Even though structs and
enums with methods aren’t <em>called</em> objects, they provide the same
functionality, according to the Gang of Four’s definition of objects.</p>
<a class="header" href="#encapsulation-that-hides-implementation-details" id="encapsulation-that-hides-implementation-details"><h3>Encapsulation that Hides Implementation Details</h3></a>
<p>Another aspect commonly associated with OOP is the idea of <em>encapsulation</em>,
which means that the implementation details of an object aren’t accessible to
code using that object. Therefore, the only way to interact with an object is
through its public API; code using the object shouldn’t be able to reach into
the object’s internals and change data or behavior directly. This enables the
programmer to change and refactor an object’s internals without needing to
change the code that uses the object.</p>
<p>We discussed how to control encapsulation in Chapter 7: we can use the <code>pub</code>
keyword to decide which modules, types, functions, and methods in our code
should be public, and by default everything else is private. For example, we
can define a struct <code>AveragedCollection</code> that has a field containing a vector
of <code>i32</code> values. The struct can also have a field that contains the average of
the values in the vector, meaning the average doesn’t have to be computed
on demand whenever anyone needs it. In other words, <code>AveragedCollection</code> will
cache the calculated average for us. Listing 17-1 has the definition of the
<code>AveragedCollection</code> struct:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-1: An <code>AveragedCollection</code> struct that
maintains a list of integers and the average of the items in the
collection</span></p>
<p>The struct is marked <code>pub</code> so that other code can use it, but the fields within
the struct remain private. This is important in this case because we want to
ensure that whenever a value is added or removed from the list, the average is
also updated. We do this by implementing <code>add</code>, <code>remove</code>, and <code>average</code> methods
on the struct, as shown in Listing 17-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct AveragedCollection {
#     list: Vec&lt;i32&gt;,
#     average: f64,
# }
impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-2: Implementations of the public methods
<code>add</code>, <code>remove</code>, and <code>average</code> on <code>AveragedCollection</code></span></p>
<p>The public methods <code>add</code>, <code>remove</code>, and <code>average</code> are the only ways to modify
an instance of <code>AveragedCollection</code>. When an item is added to <code>list</code> using the
<code>add</code> method or removed using the <code>remove</code> method, the implementations of each
call the private <code>update_average</code> method that handles updating the <code>average</code>
field as well.</p>
<p>We leave the <code>list</code> and <code>average</code> fields private so there is no way for
external code to add or remove items to the <code>list</code> field directly; otherwise,
the <code>average</code> field might become out of sync when the <code>list</code> changes. The
<code>average</code> method returns the value in the <code>average</code> field, allowing external
code to read the <code>average</code> but not modify it.</p>
<p>Because we’ve encapsulated the implementation details of the struct
<code>AveragedCollection</code>, we can easily change aspects, such as the data structure,
in the future. For instance, we could use a <code>HashSet</code> instead of a <code>Vec</code> for
the <code>list</code> field. As long as the signatures of the <code>add</code>, <code>remove</code>, and
<code>average</code> public methods stay the same, code using <code>AveragedCollection</code>
wouldn’t need to change. If we made <code>list</code> public instead, this wouldn’t
necessarily be the case: <code>HashSet</code> and <code>Vec</code> have different methods for adding
and removing items, so the external code would likely have to change if it were
modifying <code>list</code> directly.</p>
<p>If encapsulation is a required aspect for a language to be considered object
oriented, then Rust meets that requirement. The option to use <code>pub</code> or not for
different parts of code enables encapsulation of implementation details.</p>
<a class="header" href="#inheritance-as-a-type-system-and-as-code-sharing" id="inheritance-as-a-type-system-and-as-code-sharing"><h3>Inheritance as a Type System and as Code Sharing</h3></a>
<p><em>Inheritance</em> is a mechanism whereby an object can inherit from another
object’s definition, thus gaining the parent object’s data and behavior without
you having to define them again.</p>
<p>If a language must have inheritance to be an object-oriented language, then
Rust is not one. There is no way to define a struct that inherits the parent
struct’s fields and method implementations. However, if you’re used to having
inheritance in your programming toolbox, you can use other solutions in Rust,
depending on your reason for reaching for inheritance in the first place.</p>
<p>You choose inheritance for two main reasons. One is for reuse of code: you can
implement particular behavior for one type, and inheritance enables you to
reuse that implementation for a different type. You can share Rust code using
default trait method implementations instead, which you saw in Listing 10-14
when we added a default implementation of the <code>summarize</code> method on the
<code>Summary</code> trait. Any type implementing the <code>Summary</code> trait would have the
<code>summarize</code> method available on it without any further code. This is similar to
a parent class having an implementation of a method and an inheriting child
class also having the implementation of the method. We can also override the
default implementation of the <code>summarize</code> method when we implement the
<code>Summary</code> trait, which is similar to a child class overriding the
implementation of a method inherited from a parent class.</p>
<p>The other reason to use inheritance relates to the type system: to enable a
child type to be used in the same places as the parent type. This is also
called <em>polymorphism</em>, which means that you can substitute multiple objects for
each other at runtime if they share certain characteristics.</p>
<blockquote>
<a class="header" href="#polymorphism" id="polymorphism"><h3>Polymorphism</h3></a>
<p>To many people, polymorphism is synonymous with inheritance. But it’s
actually a more general concept that refers to code that can work with data
of multiple types. For inheritance, those types are generally subclasses.</p>
<p>Rust instead uses generics to abstract over different possible types and
trait bounds to impose constraints on what those types must provide. This is
sometimes called <em>bounded parametric polymorphism</em>.</p>
</blockquote>
<p>Inheritance has recently fallen out of favor as a programming design solution
in many programming languages because it’s often at risk of sharing more code
than necessary. Subclasses shouldn’t always share all characteristics of their
parent class but will do so with inheritance. This can make a program’s design
less flexible. It also introduces the possibility of calling methods on
subclasses that don’t make sense or that cause errors because the methods don’t
apply to the subclass. In addition, some languages will only allow a subclass
to inherit from one class, further restricting the flexibility of a program’s
design.</p>
<p>For these reasons, Rust takes a different approach, using trait objects instead
of inheritance. Let’s look at how trait objects enable polymorphism in Rust.</p>
<a class="header" href="#using-trait-objects-that-allow-for-values-of-different-types" id="using-trait-objects-that-allow-for-values-of-different-types"><h2>Using Trait Objects that Allow for Values of Different Types</h2></a>
<p>In Chapter 8, we mentioned that one limitation of vectors is that they can
store elements of only one type. We created a workaround in Listing 8-10 where
we defined a <code>SpreadsheetCell</code> enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code is compiled.</p>
<p>However, sometimes we want our library user to be able to extend the set of
types that are valid in a particular situation. To show how we might achieve
this, we’ll create an example graphical user interface (GUI) tool that iterates
through a list of items, calling a <code>draw</code> method on each one to draw it to the
screen—a common technique for GUI tools. We’ll create a library crate called
<code>gui</code> that contains the structure of a GUI library. This crate might include
some types for people to use, such as <code>Button</code> or <code>TextField</code>. In addition,
<code>gui</code> users will want to create their own types that can be drawn: for
instance, one programmer might add an <code>Image</code> and another might add a
<code>SelectBox</code>.</p>
<p>We won’t implement a fully fledged GUI library for this example but will show
how the pieces would fit together. At the time of writing the library, we can’t
know and define all the types other programmers might want to create. But we do
know that <code>gui</code> needs to keep track of many values of different types, and it
needs to call a <code>draw</code> method on each of these differently typed values. It
doesn’t need to know exactly what will happen when we call the <code>draw</code> method,
just that the value will have that method available for us to call.</p>
<p>To do this in a language with inheritance, we might define a class named
<code>Component</code> that has a method named <code>draw</code> on it. The other classes, such as
<code>Button</code>, <code>Image</code>, and <code>SelectBox</code>, would inherit from <code>Component</code> and thus
inherit the <code>draw</code> method. They could each override the <code>draw</code> method to define
their custom behavior, but the framework could treat all of the types as if
they were <code>Component</code> instances and call <code>draw</code> on them. But because Rust
doesn’t have inheritance, we need another way to structure the <code>gui</code> library to
allow users to extend it with new types.</p>
<a class="header" href="#defining-a-trait-for-common-behavior" id="defining-a-trait-for-common-behavior"><h3>Defining a Trait for Common Behavior</h3></a>
<p>To implement the behavior we want <code>gui</code> to have, we’ll define a trait named
<code>Draw</code> that will have one method named <code>draw</code>. Then we can define a vector that
takes a <em>trait object</em>. A trait object points to an instance of a type that
implements the trait we specify. We create a trait object by specifying some
sort of pointer, such as a <code>&amp;</code> reference or a <code>Box&lt;T&gt;</code> smart pointer, and then
specifying the relevant trait, and add a <code>dyn</code> keyword. (We’ll talk about the
reason trait objects must use a pointer in Chapter 19 in the section
“Dynamically Sized Types &amp; Sized”.) We can use trait objects in place of a
generic or concrete type. Wherever we use a trait object, Rust’s type system
will ensure at compile time that any value used in that context will
implement the trait object’s trait. Consequently, we don’t need to know all
the possible types at compile time.</p>
<p>We’ve mentioned that in Rust, we refrain from calling structs and enums
“objects” to distinguish them from other languages’ objects. In a struct or
enum, the data in the struct fields and the behavior in <code>impl</code> blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. However, trait objects <em>are</em> more like
objects in other languages in the sense that they combine data and behavior.
But trait objects differ from traditional objects in that we can’t add data to
a trait object. Trait objects aren’t as generally useful as objects in other
languages: their specific purpose is to allow abstraction across common
behavior.</p>
<p>Listing 17-3 shows how to define a trait named <code>Draw</code> with one method named
<code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Draw {
    fn draw(&amp;self);
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-3: Definition of the <code>Draw</code> trait</span></p>
<p>This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named
<code>Screen</code> that holds a vector named <code>components</code>. This vector is of type
<code>Box&lt;dyn Draw&gt;</code>, which is a trait object; it’s a stand-in for any type inside
a <code>Box</code> that implements the <code>Draw</code> trait.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-4: Definition of the <code>Screen</code> struct with a
<code>components</code> field holding a vector of trait objects that implement the <code>Draw</code>
trait</span></p>
<p>On the <code>Screen</code> struct, we’ll define a method named <code>run</code> that will call the
<code>draw</code> method on each of its <code>components</code>, as shown in Listing 17-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
# pub struct Screen {
#     pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
# }
#
impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-5: A <code>run</code> method on <code>Screen</code> that calls the
<code>draw</code> method on each component</span></p>
<p>This works differently than defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can only be substituted
with one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the <code>Screen</code> struct using a generic type and a trait bound
as in Listing 17-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-6: An alternate implementation of the <code>Screen</code>
struct and its <code>run</code> method using generics and trait bounds</span></p>
<p>This restricts us to a <code>Screen</code> instance that has a list of components all of
type <code>Button</code> or all of type <code>TextField</code>. If you’ll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.</p>
<p>On the other hand, with the method using trait objects, one <code>Screen</code> instance
can hold a <code>Vec</code> that contains a <code>Box&lt;Button&gt;</code> as well as a <code>Box&lt;TextField&gt;</code>.
Let’s look at how this works, and then we’ll talk about the runtime performance
implications.</p>
<a class="header" href="#implementing-the-trait" id="implementing-the-trait"><h3>Implementing the Trait</h3></a>
<p>Now we’ll add some types that implement the <code>Draw</code> trait. We’ll provide the
<code>Button</code> type. Again, actually implementing a GUI library is beyond the scope
of this book, so the <code>draw</code> method won’t have any useful implementation in its
body. To imagine what the implementation might look like, a <code>Button</code> struct
might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in Listing 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-7: A <code>Button</code> struct that implements the
<code>Draw</code> trait</span></p>
<p>The <code>width</code>, <code>height</code>, and <code>label</code> fields on <code>Button</code> will differ from the
fields on other components, such as a <code>TextField</code> type, that might have those
fields plus a <code>placeholder</code> field instead. Each of the types we want to draw on
the screen will implement the <code>Draw</code> trait but will use different code in the
<code>draw</code> method to define how to draw that particular type, as <code>Button</code> has here
(without the actual GUI code, which is beyond the scope of this chapter). The
<code>Button</code> type, for instance, might have an additional <code>impl</code> block containing
methods related to what happens when a user clicks the button. These kinds of
methods won’t apply to types like <code>TextField</code>.</p>
<p>If someone using our library decides to implement a <code>SelectBox</code> struct that has
<code>width</code>, <code>height</code>, and <code>options</code> fields, they implement the <code>Draw</code> trait on the
<code>SelectBox</code> type as well, as shown in Listing 17-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
</code></pre>
<p><span class="caption">Listing 17-8: Another crate using <code>gui</code> and implementing
the <code>Draw</code> trait on a <code>SelectBox</code> struct</span></p>
<p>Our library’s user can now write their <code>main</code> function to create a <code>Screen</code>
instance. To the <code>Screen</code> instance, they can add a <code>SelectBox</code> and a <code>Button</code>
by putting each in a <code>Box&lt;T&gt;</code> to become a trait object. They can then call the
<code>run</code> method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the
components. Listing 17-9 shows this implementation:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span></p>
<p>When we wrote the library, we didn’t know that someone might add the
<code>SelectBox</code> type, but our <code>Screen</code> implementation was able to operate on the
new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> type, which
means it implements the <code>draw</code> method.</p>
<p>This concept—of being concerned only with the messages a value responds to
rather than the value’s concrete type—is similar to the concept <em>duck typing</em>
in dynamically typed languages: if it walks like a duck and quacks like a duck,
then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code> in Listing
17-5, <code>run</code> doesn’t need to know what the concrete type of each component is.
It doesn’t check whether a component is an instance of a <code>Button</code> or a
<code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By specifying
<code>Box&lt;dyn Draw&gt;</code> as the type of the values in the <code>components</code> vector, we’ve
defined <code>Screen</code> to need values that we can call the <code>draw</code> method on.</p>
<p>The advantage of using trait objects and Rust’s type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn’t implement a method but we call it anyway. Rust won’t compile
our code if the values don’t implement the traits that the trait objects need.</p>
<p>For example, Listing 17-10 shows what happens if we try to create a <code>Screen</code>
with a <code>String</code> as a component:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-10: Attempting to use a type that doesn’t
implement the trait object’s trait</span></p>
<p>We’ll get this error because <code>String</code> doesn’t implement the <code>Draw</code> trait:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --&gt; src/main.rs:7:13
   |
 7 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`
</code></pre>
<p>This error lets us know that either we’re passing something to <code>Screen</code> we
didn’t mean to pass and we should pass a different type or we should implement
<code>Draw</code> on <code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</p>
<a class="header" href="#trait-objects-perform-dynamic-dispatch" id="trait-objects-perform-dynamic-dispatch"><h3>Trait Objects Perform Dynamic Dispatch</h3></a>
<p>Recall in the “Performance of Code Using Generics” section in Chapter 10 our
discussion on the monomorphization process performed by the compiler when we
use trait bounds on generics: the compiler generates nongeneric implementations
of functions and methods for each concrete type that we use in place of a
generic type parameter. The code that results from monomorphization is doing
<em>static dispatch</em>, which is when the compiler knows what method you’re calling
at compile time. This is opposed to <em>dynamic dispatch</em>, which is when the
compiler can’t tell at compile time which method you’re calling. In dynamic
dispatch cases, the compiler emits code that at runtime will figure out which
method to call.</p>
<p>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t
know all the types that might be used with the code that is using trait
objects, so it doesn’t know which method implemented on which type to call.
Instead, at runtime, Rust uses the pointers inside the trait object to know
which method to call. There is a runtime cost when this lookup happens that
doesn’t occur with static dispatch. Dynamic dispatch also prevents the compiler
from choosing to inline a method’s code, which in turn prevents some
optimizations. However, we did get extra flexibility in the code that we wrote
in Listing 17-5 and were able to support in Listing 17-9, so it’s a trade-off
to consider.</p>
<a class="header" href="#object-safety-is-required-for-trait-objects" id="object-safety-is-required-for-trait-objects"><h3>Object Safety Is Required for Trait Objects</h3></a>
<p>You can only make <em>object-safe</em> traits into trait objects. Some complex rules
govern all the properties that make a trait object safe, but in practice, only
two rules are relevant. A trait is object safe if all the methods defined in
the trait have the following properties:</p>
<ul>
<li>The return type isn’t <code>Self</code>.</li>
<li>There are no generic type parameters.</li>
</ul>
<p>The <code>Self</code> keyword is an alias for the type we’re implementing the traits or
methods on. Trait objects must be object safe because once you’ve used a trait
object, Rust no longer knows the concrete type that’s implementing that trait.
If a trait method returns the concrete <code>Self</code> type, but a trait object forgets
the exact type that <code>Self</code> is, there is no way the method can use the original
concrete type. The same is true of generic type parameters that are filled in
with concrete type parameters when the trait is used: the concrete types become
part of the type that implements the trait. When the type is forgotten through
the use of a trait object, there is no way to know what types to fill in the
generic type parameters with.</p>
<p>An example of a trait whose methods are not object safe is the standard
library’s <code>Clone</code> trait. The signature for the <code>clone</code> method in the <code>Clone</code>
trait looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
#}</code></pre></pre>
<p>The <code>String</code> type implements the <code>Clone</code> trait, and when we call the <code>clone</code>
method on an instance of <code>String</code> we get back an instance of <code>String</code>.
Similarly, if we call <code>clone</code> on an instance of <code>Vec</code>, we get back an instance
of <code>Vec</code>. The signature of <code>clone</code> needs to know what type will stand in for
<code>Self</code>, because that’s the return type.</p>
<p>The compiler will indicate when you’re trying to do something that violates the
rules of object safety in regard to trait objects. For example, let’s say we
tried to implement the <code>Screen</code> struct in Listing 17-4 to hold types that
implement the <code>Clone</code> trait instead of the <code>Draw</code> trait, like this:</p>
<pre><code class="language-rust ignore does_not_compile">pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
}
</code></pre>
<p>We would get this error:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>This error means you can’t use this trait as a trait object in this way. If
you’re interested in more details on object safety, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>.</p>
<a class="header" href="#implementing-an-object-oriented-design-pattern" id="implementing-an-object-oriented-design-pattern"><h2>Implementing an Object-Oriented Design Pattern</h2></a>
<p>The <em>state pattern</em> is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, which is represented by a set
of <em>state objects</em>, and the value’s behavior changes based on the internal
state. The state objects share functionality: in Rust, of course, we use
structs and traits rather than objects and inheritance. Each state object is
responsible for its own behavior and for governing when it should change into
another state. The value that holds a state object knows nothing about the
different behavior of the states or when to transition between states.</p>
<p>Using the state pattern means when the business requirements of the program
change, we won’t need to change the code of the value holding the state or the
code that uses the value. We’ll only need to update the code inside one of the
state objects to change its rules or perhaps add more state objects. Let’s look
at an example of the state design pattern and how to use it in Rust.</p>
<p>We’ll implement a blog post workflow in an incremental way. The blog’s final
functionality will look like this:</p>
<ol>
<li>A blog post starts as an empty draft.</li>
<li>When the draft is done, a review of the post is requested.</li>
<li>When the post is approved, it gets published.</li>
<li>Only published blog posts return content to print, so unapproved posts can’t
accidentally be published.</li>
</ol>
<p>Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we’ve requested a review, the post
should remain an unpublished draft.</p>
<p>Listing 17-11 shows this workflow in code form: this is an example usage of the
API we’ll implement in a library crate named <code>blog</code>. This won’t compile yet
because we haven’t implemented the <code>blog</code> crate yet.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our <code>blog</code> crate to have</span></p>
<p>We want to allow the user to create a new draft blog post with <code>Post::new</code>.
Then we want to allow text to be added to the blog post while it’s in the draft
state. If we try to get the post’s content immediately, before approval,
nothing should happen because the post is still a draft. We’ve added
<code>assert_eq!</code> in the code for demonstration purposes. An excellent unit test for
this would be to assert that a draft blog post returns an empty string from the
<code>content</code> method, but we’re not going to write tests for this example.</p>
<p>Next, we want to enable a request for a review of the post, and we want
<code>content</code> to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when <code>content</code> is called.</p>
<p>Notice that the only type we’re interacting with from the crate is the <code>Post</code>
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in—draft, waiting for review, or published. Changing from one state to another
will be managed internally within the <code>Post</code> type. The states change in
response to the methods called by our library’s users on the <code>Post</code> instance,
but they don’t have to manage the state changes directly. Also, users can’t
make a mistake with the states, like publishing a post before it’s reviewed.</p>
<a class="header" href="#defining-post-and-creating-a-new-instance-in-the-draft-state" id="defining-post-and-creating-a-new-instance-in-the-draft-state"><h3>Defining <code>Post</code> and Creating a New Instance in the Draft State</h3></a>
<p>Let’s get started on the implementation of the library! We know we need a
public <code>Post</code> struct that holds some content, so we’ll start with the
definition of the struct and an associated public <code>new</code> function to create an
instance of <code>Post</code>, as shown in Listing 17-12. We’ll also make a private
<code>State</code> trait. Then <code>Post</code> will hold a trait object of <code>Box&lt;dyn State&gt;</code>
inside an <code>Option&lt;T&gt;</code> in a private field named <code>state</code>. You’ll see why the
<code>Option&lt;T&gt;</code> is necessary in a bit.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
#}</code></pre></pre>
<p><span class="caption">Listing 17-12: Definition of a <code>Post</code> struct and a <code>new</code>
function that creates a new <code>Post</code> instance, a <code>State</code> trait, and a <code>Draft</code>
struct</span></p>
<p>The <code>State</code> trait defines the behavior shared by different post states, and the
<code>Draft</code>, <code>PendingReview</code>, and <code>Published</code> states will all implement the <code>State</code>
trait. For now, the trait doesn’t have any methods, and we’ll start by defining
just the <code>Draft</code> state because that is the state we want a post to start in.</p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value that
holds a <code>Box</code>. This <code>Box</code> points to a new instance of the <code>Draft</code> struct. This
ensures whenever we create a new instance of <code>Post</code>, it will start out as a
draft. Because the <code>state</code> field of <code>Post</code> is private, there is no way to
create a <code>Post</code> in any other state! In the <code>Post::new</code> function, we set the
<code>content</code> field to a new, empty <code>String</code>.</p>
<a class="header" href="#storing-the-text-of-the-post-content" id="storing-the-text-of-the-post-content"><h3>Storing the Text of the Post Content</h3></a>
<p>Listing 17-11 showed that we want to be able to call a method named
<code>add_text</code> and pass it a <code>&amp;str</code> that is then added to the text content of the
blog post. We implement this as a method rather than exposing the <code>content</code>
field as <code>pub</code>. This means we can implement a method later that will control
how the <code>content</code> field’s data is read. The <code>add_text</code> method is pretty
straightforward, so let’s add the implementation in Listing 17-13 to the <code>impl Post</code> block:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-13: Implementing the <code>add_text</code> method to add
text to a post’s <code>content</code></span></p>
<p>The <code>add_text</code> method takes a mutable reference to <code>self</code>, because we’re
changing the <code>Post</code> instance that we’re calling <code>add_text</code> on. We then call
<code>push_str</code> on the <code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to
the saved <code>content</code>. This behavior doesn’t depend on the state the post is in,
so it’s not part of the state pattern. The <code>add_text</code> method doesn’t interact
with the <code>state</code> field at all, but it is part of the behavior we want to
support.</p>
<a class="header" href="#ensuring-the-content-of-a-draft-post-is-empty" id="ensuring-the-content-of-a-draft-post-is-empty"><h3>Ensuring the Content of a Draft Post Is Empty</h3></a>
<p>Even after we’ve called <code>add_text</code> and added some content to our post, we still
want the <code>content</code> method to return an empty string slice because the post is
still in the draft state, as shown on line 8 of Listing 17-11. For now, let’s
implement the <code>content</code> method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We’ll change this later
once we implement the ability to change a post’s state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-14: Adding a placeholder implementation for
the <code>content</code> method on <code>Post</code> that always returns an empty string slice</span></p>
<p>With this added <code>content</code> method, everything in Listing 17-11 up to line 8
works as intended.</p>
<a class="header" href="#requesting-a-review-of-the-post-changes-its-state" id="requesting-a-review-of-the-post-changes-its-state"><h3>Requesting a Review of the Post Changes Its State</h3></a>
<p>Next, we need to add functionality to request a review of a post, which should
change its state from <code>Draft</code> to <code>PendingReview</code>. Listing 17-15 shows this code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;dyn State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-15: Implementing <code>request_review</code> methods on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We give <code>Post</code> a public method named <code>request_review</code> that will take a mutable
reference to <code>self</code>. Then we call an internal <code>request_review</code> method on the
current state of <code>Post</code>, and this second <code>request_review</code> method consumes the
current state and returns a new state.</p>
<p>We’ve added the <code>request_review</code> method to the <code>State</code> trait; all types that
implement the trait will now need to implement the <code>request_review</code> method.
Note that rather than having <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first
parameter of the method, we have <code>self: Box&lt;Self&gt;</code>. This syntax means the
method is only valid when called on a <code>Box</code> holding the type. This syntax takes
ownership of <code>Box&lt;Self&gt;</code>, invalidating the old state so the state value of the
<code>Post</code> can transform into a new state.</p>
<p>To consume the old state, the <code>request_review</code> method needs to take ownership
of the state value. This is where the <code>Option</code> in the <code>state</code> field of <code>Post</code>
comes in: we call the <code>take</code> method to take the <code>Some</code> value out of the <code>state</code>
field and leave a <code>None</code> in its place, because Rust doesn’t let us have
unpopulated fields in structs. This lets us move the <code>state</code> value out of
<code>Post</code> rather than borrowing it. Then we’ll set the post’s <code>state</code> value to the
result of this operation.</p>
<p>We need to set <code>state</code> to <code>None</code> temporarily rather than setting it directly
with code like <code>self.state = self.state.request_review();</code> to get ownership of
the <code>state</code> value. This ensures <code>Post</code> can’t use the old <code>state</code> value after
we’ve transformed it into a new state.</p>
<p>The <code>request_review</code> method on <code>Draft</code> needs to return a new, boxed instance of
a new <code>PendingReview</code> struct, which represents the state when a post is waiting
for a review. The <code>PendingReview</code> struct also implements the <code>request_review</code>
method but doesn’t do any transformations. Rather, it returns itself, because
when we request a review on a post already in the <code>PendingReview</code> state, it
should stay in the <code>PendingReview</code> state.</p>
<p>Now we can start seeing the advantages of the state pattern: the
<code>request_review</code> method on <code>Post</code> is the same no matter its <code>state</code> value. Each
state is responsible for its own rules.</p>
<p>We’ll leave the <code>content</code> method on <code>Post</code> as is, returning an empty string
slice. We can now have a <code>Post</code> in the <code>PendingReview</code> state as well as in the
<code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code> state.
Listing 17-11 now works up to line 11!</p>
<a class="header" href="#adding-the-approve-method-that-changes-the-behavior-of-content" id="adding-the-approve-method-that-changes-the-behavior-of-content"><h3>Adding the <code>approve</code> Method that Changes the Behavior of <code>content</code></h3></a>
<p>The <code>approve</code> method will be similar to the <code>request_review</code> method: it will
set <code>state</code> to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;dyn State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
#         Box::new(PendingReview {})
#     }
#
    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
#         self
#     }
#
    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-16: Implementing the <code>approve</code> method on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We add the <code>approve</code> method to the <code>State</code> trait and add a new struct that
implements <code>State</code>, the <code>Published</code> state.</p>
<p>Similar to <code>request_review</code>, if we call the <code>approve</code> method on a <code>Draft</code>, it
will have no effect because it will return <code>self</code>. When we call <code>approve</code> on
<code>PendingReview</code>, it returns a new, boxed instance of the <code>Published</code> struct.
The <code>Published</code> struct implements the <code>State</code> trait, and for both the
<code>request_review</code> method and the <code>approve</code> method, it returns itself, because
the post should stay in the <code>Published</code> state in those cases.</p>
<p>Now we need to update the <code>content</code> method on <code>Post</code>: if the state is
<code>Published</code>, we want to return the value in the post’s <code>content</code> field;
otherwise, we want to return an empty string slice, as shown in Listing 17-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait State {
#     fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
# }
# pub struct Post {
#     state: Option&lt;Box&lt;dyn State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-17: Updating the <code>content</code> method on <code>Post</code> to
delegate to a <code>content</code> method on <code>State</code></span></p>
<p>Because the goal is to keep all these rules inside the structs that implement
<code>State</code>, we call a <code>content</code> method on the value in <code>state</code> and pass the post
instance (that is, <code>self</code>) as an argument. Then we return the value that is
returned from using the <code>content</code> method on the <code>state</code> value.</p>
<p>We call the <code>as_ref</code> method on the <code>Option</code> because we want a reference to the
value inside the <code>Option</code> rather than ownership of the value. Because <code>state</code>
is an <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, when we call <code>as_ref</code>, an <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> is
returned. If we didn’t call <code>as_ref</code>, we would get an error because we can’t
move <code>state</code> out of the borrowed <code>&amp;self</code> of the function parameter.</p>
<p>We then call the <code>unwrap</code> method, which we know will never panic, because we
know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code>
value when those methods are done. This is one of the cases we talked about in
the “Cases When You Have More Information Than the Compiler” section of Chapter
9 when we know that a <code>None</code> value is never possible, even though the compiler
isn’t able to understand that.</p>
<p>At this point, when we call <code>content</code> on the <code>&amp;Box&lt;dyn State&gt;</code>, deref coercion will
take effect on the <code>&amp;</code> and the <code>Box</code> so the <code>content</code> method will ultimately be
called on the type that implements the <code>State</code> trait. That means we need to add
<code>content</code> to the <code>State</code> trait definition, and that is where we’ll put the
logic for what content to return depending on which state we have, as shown in
Listing 17-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String
# }
trait State {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-18: Adding the <code>content</code> method to the <code>State</code>
trait</span></p>
<p>We add a default implementation for the <code>content</code> method that returns an empty
string slice. That means we don’t need to implement <code>content</code> on the <code>Draft</code>
and <code>PendingReview</code> structs. The <code>Published</code> struct will override the <code>content</code>
method and return the value in <code>post.content</code>.</p>
<p>Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. We’re taking a reference to a <code>post</code> as an argument and returning a
reference to part of that <code>post</code>, so the lifetime of the returned reference is
related to the lifetime of the <code>post</code> argument.</p>
<p>And we’re done—all of Listing 17-11 now works! We’ve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout <code>Post</code>.</p>
<a class="header" href="#trade-offs-of-the-state-pattern" id="trade-offs-of-the-state-pattern"><h3>Trade-offs of the State Pattern</h3></a>
<p>We’ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on <code>Post</code> know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the <code>State</code>
trait on the <code>Published</code> struct.</p>
<p>If we were to create an alternative implementation that didn’t use the state
pattern, we might instead use <code>match</code> expressions in the methods on <code>Post</code> or
even in the <code>main</code> code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those <code>match</code> expressions
would need another arm.</p>
<p>With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don’t
need <code>match</code> expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.</p>
<p>The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:</p>
<ul>
<li>Add a <code>reject</code> method that changes the post’s state from <code>PendingReview</code> back
to <code>Draft</code>.</li>
<li>Require two calls to <code>approve</code> before the state can be changed to <code>Published</code>.</li>
<li>Allow users to add text content only when a post is in the <code>Draft</code> state.
Hint: have the state object responsible for what might change about the
content but not responsible for modifying the <code>Post</code>.</li>
</ul>
<p>One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between <code>PendingReview</code> and <code>Published</code>, such as <code>Scheduled</code>,
we would have to change the code in <code>PendingReview</code> to transition to
<code>Scheduled</code> instead. It would be less work if <code>PendingReview</code> didn’t need to
change with the addition of a new state, but that would mean switching to
another design pattern.</p>
<p>Another downside is that we’ve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
<code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code>;
however, this would violate object safety, because the trait doesn’t know what
the concrete <code>self</code> will be exactly. We want to be able to use <code>State</code> as a
trait object, so we need its methods to be object safe.</p>
<p>Other duplication includes the similar implementations of the <code>request_review</code>
and <code>approve</code> methods on <code>Post</code>. Both methods delegate to the implementation of
the same method on the value in the <code>state</code> field of <code>Option</code> and set the new
value of the <code>state</code> field to the result. If we had a lot of methods on <code>Post</code>
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see the “Macros” section in Chapter 19).</p>
<p>By implementing the state pattern exactly as it’s defined for object-oriented
languages, we’re not taking as full advantage of Rust’s strengths as we could.
Let’s look at some changes we can make to the <code>blog</code> crate that can make
invalid states and transitions into compile time errors.</p>
<a class="header" href="#encoding-states-and-behavior-as-types" id="encoding-states-and-behavior-as-types"><h4>Encoding States and Behavior as Types</h4></a>
<p>We’ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we’ll encode the states into different
types. Consequently, Rust’s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.</p>
<p>Let’s consider the first part of <code>main</code> in Listing 17-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"># use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<p>We still enable the creation of new posts in the draft state using <code>Post::new</code>
and the ability to add text to the post’s content. But instead of having a
<code>content</code> method on a draft post that returns an empty string, we’ll make it so
draft posts don’t have the <code>content</code> method at all. That way, if we try to get
a draft post’s content, we’ll get a compiler error telling us the method
doesn’t exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code won’t even compile.
Listing 17-19 shows the definition of a <code>Post</code> struct and a <code>DraftPost</code> struct,
as well as methods on each:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-19: A <code>Post</code> with a <code>content</code> method and a
<code>DraftPost</code> without a <code>content</code> method</span></p>
<p>Both the <code>Post</code> and <code>DraftPost</code> structs have a private <code>content</code> field that
stores the blog post text. The structs no longer have the <code>state</code> field because
we’re moving the encoding of the state to the types of the structs. The <code>Post</code>
struct will represent a published post, and it has a <code>content</code> method that
returns the <code>content</code>.</p>
<p>We still have a <code>Post::new</code> function, but instead of returning an instance of
<code>Post</code>, it returns an instance of <code>DraftPost</code>. Because <code>content</code> is private
and there aren’t any functions that return <code>Post</code>, it’s not possible to create
an instance of <code>Post</code> right now.</p>
<p>The <code>DraftPost</code> struct has an <code>add_text</code> method, so we can add text to
<code>content</code> as before, but note that <code>DraftPost</code> does not have a <code>content</code> method
defined! So now the program ensures all posts start as draft posts, and draft
posts don’t have their content available for display. Any attempt to get around
these constraints will result in a compiler error.</p>
<a class="header" href="#implementing-transitions-as-transformations-into-different-types" id="implementing-transitions-as-transformations-into-different-types"><h4>Implementing Transitions as Transformations into Different Types</h4></a>
<p>So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Let’s implement
these constraints by adding another struct, <code>PendingReviewPost</code>, defining the
<code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code>, and
defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code>, as
shown in Listing 17-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
# pub struct DraftPost {
#     content: String,
# }
#
impl DraftPost {
    // --snip--

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-20: A <code>PendingReviewPost</code> that gets created by
calling <code>request_review</code> on <code>DraftPost</code> and an <code>approve</code> method that turns a
<code>PendingReviewPost</code> into a published <code>Post</code></span></p>
<p>The <code>request_review</code> and <code>approve</code> methods take ownership of <code>self</code>, thus
consuming the <code>DraftPost</code> and <code>PendingReviewPost</code> instances and transforming
them into a <code>PendingReviewPost</code> and a published <code>Post</code>, respectively. This way,
we won’t have any lingering <code>DraftPost</code> instances after we’ve called
<code>request_review</code> on them, and so forth. The <code>PendingReviewPost</code> struct doesn’t
have a <code>content</code> method defined on it, so attempting to read its content
results in a compiler error, as with <code>DraftPost</code>. Because the only way to get a
published <code>Post</code> instance that does have a <code>content</code> method defined is to call
the <code>approve</code> method on a <code>PendingReviewPost</code>, and the only way to get a
<code>PendingReviewPost</code> is to call the <code>request_review</code> method on a <code>DraftPost</code>,
we’ve now encoded the blog post workflow into the type system.</p>
<p>But we also have to make some small changes to <code>main</code>. The <code>request_review</code> and
<code>approve</code> methods return new instances rather than modifying the struct they’re
called on, so we need to add more <code>let post =</code> shadowing assignments to save
the returned instances. We also can’t have the assertions about the draft and
pending review post’s contents be empty strings, nor do we need them: we can’t
compile code that tries to use the content of posts in those states any longer.
The updated code in <code>main</code> is shown in Listing 17-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listing 17-21: Modifications to <code>main</code> to use the new
implementation of the blog post workflow</span></p>
<p>The changes we needed to make to <code>main</code> to reassign <code>post</code> mean that this
implementation doesn’t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the <code>Post</code> implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.</p>
<p>Try the tasks suggested for additional requirements that we mentioned at the
start of this section on the <code>blog</code> crate as it is after Listing 17-20 to see
what you think about the design of this version of the code. Note that some of
the tasks might be completed already in this design.</p>
<p>We’ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rust’s features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns won’t always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages don’t have.</p>
<a class="header" href="#summary-4" id="summary-4"><h2>Summary</h2></a>
<p>No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your code’s
maintainability. Rust also has other features, like ownership, that
object-oriented languages don’t have. An object-oriented pattern won’t always
be the best way to take advantage of Rust’s strengths, but is an available
option.</p>
<p>Next, we’ll look at patterns, which are another of Rust’s features that enable
lots of flexibility. We’ve looked at them briefly throughout the book but
haven’t seen their full capability yet. Let’s go!</p>
<a class="header" href="#patterns-and-matching" id="patterns-and-matching"><h1>Patterns and Matching</h1></a>
<p>Patterns are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with <code>match</code>
expressions and other constructs gives you more control over a program’s
control flow. A pattern consists of some combination of the following:</p>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<p>These components describe the shape of the data we’re working with, which we
then match against values to determine whether our program has the correct data
to continue running a particular piece of code.</p>
<p>To use a pattern, we compare it to some value. If the pattern matches the
value, we use the value parts in our code. Recall the <code>match</code> expressions in
Chapter 6 that used patterns, such as the coin-sorting machine example. If the
value fits the shape of the pattern, we can use the named pieces. If it
doesn’t, the code associated with the pattern won’t run.</p>
<p>This chapter is a reference on all things related to patterns. We’ll cover the
valid places to use patterns, the difference between refutable and irrefutable
patterns, and the different kinds of pattern syntax that you might see. By the
end of the chapter, you’ll know how to use patterns to express many concepts in
a clear way.</p>
<a class="header" href="#all-the-places-patterns-can-be-used" id="all-the-places-patterns-can-be-used"><h2>All the Places Patterns Can Be Used</h2></a>
<p>Patterns pop up in a number of places in Rust, and you’ve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.</p>
<a class="header" href="#match-arms" id="match-arms"><h3><code>match</code> Arms</h3></a>
<p>As discussed in Chapter 6, we use patterns in the arms of <code>match</code> expressions.
Formally, <code>match</code> expressions are defined as the keyword <code>match</code>, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that arm’s pattern, like this:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>One requirement for <code>match</code> expressions is that they need to be <em>exhaustive</em> in
the sense that all possibilities for the value in the <code>match</code> expression must
be accounted for. One way to ensure you’ve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.</p>
<p>A particular pattern <code>_</code> will match anything, but it never binds to a variable,
so it’s often used in the last match arm. The <code>_</code> pattern can be useful when
you want to ignore any value not specified, for example. We’ll cover the <code>_</code>
pattern in more detail in the “Ignoring Values in a Pattern” section later in
this chapter.</p>
<a class="header" href="#conditional-if-let-expressions" id="conditional-if-let-expressions"><h3>Conditional <code>if let</code> Expressions</h3></a>
<p>In Chapter 6 we discussed how to use <code>if let</code> expressions mainly as a shorter
way to write the equivalent of a <code>match</code> that only matches one case.
Optionally, <code>if let</code> can have a corresponding <code>else</code> containing code to run if
the pattern in the <code>if let</code> doesn’t match.</p>
<p>Listing 18-1 shows that it’s also possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code> expressions. Doing so gives us more flexibility than a
<code>match</code> expression in which we can express only one value to compare with the
patterns. Also, the conditions in a series of <code>if let</code>, <code>else if</code>, <code>else if let</code> arms aren’t required to relate to each other.</p>
<p>The code in Listing 18-1 shows a series of checks for several conditions that
decide what the background color should be. For this example, we’ve created
variables with hardcoded values that a real program might receive from user
input.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-1: Mixing <code>if let</code>, <code>else if</code>, <code>else if let</code>,
and <code>else</code></span></p>
<p>If the user specifies a favorite color, that color is the background color. If
today is Tuesday, the background color is green. If the user specifies
their age as a string and we can parse it as a number successfully, the color
is either purple or orange depending on the value of the number. If none of
these conditions apply, the background color is blue.</p>
<p>This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print <code>Using purple as the background color</code>.</p>
<p>You can see that <code>if let</code> can also introduce shadowed variables in the same way
that <code>match</code> arms can: the line <code>if let Ok(age) = age</code> introduces a new
shadowed <code>age</code> variable that contains the value inside the <code>Ok</code> variant. This
means we need to place the <code>if age &gt; 30</code> condition within that block: we can’t
combine these two conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. The
shadowed <code>age</code> we want to compare to 30 isn’t valid until the new scope starts
with the curly bracket.</p>
<p>The downside of using <code>if let</code> expressions is that the compiler doesn’t check
exhaustiveness, whereas with <code>match</code> expressions it does. If we omitted the
last <code>else</code> block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.</p>
<a class="header" href="#while-let-conditional-loops" id="while-let-conditional-loops"><h3><code>while let</code> Conditional Loops</h3></a>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a
<code>while</code> loop to run for as long as a pattern continues to match. The example in
Listing 18-2 shows a <code>while let</code> loop that uses a vector as a stack and prints
the values in the vector in the opposite order in which they were pushed.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-2: Using a <code>while let</code> loop to print values
for as long as <code>stack.pop()</code> returns <code>Some</code></span></p>
<p>This example prints 3, 2, and then 1. The <code>pop</code> method takes the last element
out of the vector and returns <code>Some(value)</code>. If the vector is empty, <code>pop</code>
returns <code>None</code>. The <code>while</code> loop continues running the code in its block as
long as <code>pop</code> returns <code>Some</code>. When <code>pop</code> returns <code>None</code>, the loop stops. We can
use <code>while let</code> to pop every element off our stack.</p>
<a class="header" href="#for-loops" id="for-loops"><h3><code>for</code> Loops</h3></a>
<p>In Chapter 3, we mentioned that the <code>for</code> loop is the most common loop
construction in Rust code, but we haven’t yet discussed the pattern that <code>for</code>
takes. In a <code>for</code> loop, the pattern is the value that directly follows the
keyword <code>for</code>, so in <code>for x in y</code> the <code>x</code> is the pattern.</p>
<p>Listing 18-3 demonstrates how to use a pattern in a <code>for</code> loop to destructure,
or break apart, a tuple as part of the <code>for</code> loop.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-3: Using a pattern in a <code>for</code> loop to
destructure a tuple</span></p>
<p>The code in Listing 18-3 will print the following:</p>
<pre><code class="language-text">a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>We use the <code>enumerate</code> method to adapt an iterator to produce a value and that
value’s index in the iterator, placed into a tuple. The first call to
<code>enumerate</code> produces the tuple <code>(0, 'a')</code>. When this value is matched to the
pattern <code>(index, value)</code>, <code>index</code> will be <code>0</code> and <code>value</code> will be <code>'a'</code>,
printing the first line of the output.</p>
<a class="header" href="#let-statements" id="let-statements"><h3><code>let</code> Statements</h3></a>
<p>Prior to this chapter, we had only explicitly discussed using patterns with
<code>match</code> and <code>if let</code>, but in fact, we’ve used patterns in other places as well,
including in <code>let</code> statements. For example, consider this straightforward
variable assignment with <code>let</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>Throughout this book, we’ve used <code>let</code> like this hundreds of times, and
although you might not have realized it, you were using patterns! More
formally, a <code>let</code> statement looks like this:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In statements like <code>let x = 5;</code> with a variable name in the <code>PATTERN</code> slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
<code>let x = 5;</code> example, <code>x</code> is a pattern that means “bind what matches here to
the variable <code>x</code>.” Because the name <code>x</code> is the whole pattern, this pattern
effectively means “bind everything to the variable <code>x</code>, whatever the value is.”</p>
<p>To see the pattern matching aspect of <code>let</code> more clearly, consider Listing
18-4, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (x, y, z) = (1, 2, 3);
#}</code></pre></pre>
<p><span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span></p>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code>
to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern, so Rust
binds <code>1</code> to <code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple
pattern as nesting three individual variable patterns inside it.</p>
<p>If the number of elements in the pattern doesn’t match the number of elements
in the tuple, the overall type won’t match and we’ll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which won’t work.</p>
<pre><code class="language-rust ignore does_not_compile">let (x, y) = (1, 2, 3);
</code></pre>
<p><span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables don’t match the number of elements in the tuple</span></p>
<p>Attempting to compile this code results in this type error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected type `({integer}, {integer}, {integer})`
             found type `(_, _)`
</code></pre>
<p>If we wanted to ignore one or more of the values in the tuple, we could use <code>_</code>
or <code>..</code>, as you’ll see in the “Ignoring Values in a Pattern” section. If the
problem is that we have too many variables in the pattern, the solution is to
make the types match by removing variables so the number of variables equals
the number of elements in the tuple.</p>
<a class="header" href="#function-parameters" id="function-parameters"><h3>Function Parameters</h3></a>
<p>Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named <code>foo</code> that takes one parameter named <code>x</code> of type
<code>i32</code>, should by now look familiar.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) {
    // code goes here
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span></p>
<p>The <code>x</code> part is a pattern! As we did with <code>let</code>, we could match a tuple in a
function’s arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span></p>
<p>This code prints <code>Current location: (3, 5)</code>. The values <code>&amp;(3, 5)</code> match the
pattern <code>&amp;(x, y)</code>, so <code>x</code> is the value <code>3</code> and <code>y</code> is the value <code>5</code>.</p>
<p>We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.</p>
<p>At this point, you’ve seen several ways of using patterns, but patterns don’t
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. We’ll discuss
these two concepts next.</p>
<a class="header" href="#refutability-whether-a-pattern-might-fail-to-match" id="refutability-whether-a-pattern-might-fail-to-match"><h2>Refutability: Whether a Pattern Might Fail to Match</h2></a>
<p>Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are <em>irrefutable</em>. An example would be <code>x</code> in the
statement <code>let x = 5;</code> because <code>x</code> matches anything and therefore cannot fail
to match. Patterns that can fail to match for some possible value are
<em>refutable</em>. An example would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code> because if the value in the <code>a_value</code> variable is <code>None</code> rather than
<code>Some</code>, the <code>Some(x)</code> pattern will not match.</p>
<p>Function parameters, <code>let</code> statements, and <code>for</code> loops can only accept
irrefutable patterns, because the program cannot do anything meaningful when
values don’t match. The <code>if let</code> and <code>while let</code> expressions only accept
refutable patterns, because by definition they’re intended to handle possible
failure: the functionality of a conditional is in its ability to perform
differently depending on success or failure.</p>
<p>In general, you shouldn’t have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message. In
those cases, you’ll need to change either the pattern or the construct you’re
using the pattern with, depending on the intended behavior of the code.</p>
<p>Let’s look at an example of what happens when we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a
<code>let</code> statement, but for the pattern we’ve specified <code>Some(x)</code>, a refutable
pattern. As you might expect, this code will not compile.</p>
<pre><code class="language-rust ignore does_not_compile">let Some(x) = some_option_value;
</code></pre>
<p><span class="caption">Listing 18-8: Attempting to use a refutable pattern with
<code>let</code></span></p>
<p>If <code>some_option_value</code> was a <code>None</code> value, it would fail to match the pattern
<code>Some(x)</code>, meaning the pattern is refutable. However, the <code>let</code> statement can
only accept an irrefutable pattern because there is nothing valid the code can
do with a <code>None</code> value. At compile time, Rust will complain that we’ve tried to
use a refutable pattern where an irrefutable pattern is required:</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt;
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<p>Because we didn’t cover (and couldn’t cover!) every valid value with the
pattern <code>Some(x)</code>, Rust rightfully produces a compiler error.</p>
<p>To fix the problem where we have a refutable pattern where an irrefutable
pattern is needed, we can change the code that uses the pattern: instead of
using <code>let</code>, we can use <code>if let</code>. Then if the pattern doesn’t match, the code
will just skip the code in the curly brackets, giving it a way to continue
validly. Listing 18-9 shows how to fix the code in Listing 18-8.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_option_value: Option&lt;i32&gt; = None;
if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-9: Using <code>if let</code> and a block with refutable
patterns instead of <code>let</code></span></p>
<p>We’ve given the code an out! This code is perfectly valid, although it means we
cannot use an irrefutable pattern without receiving an error. If we give <code>if let</code> a pattern that will always match, such as <code>x</code>, as shown in Listing 18-10,
it will not compile.</p>
<pre><code class="language-rust ignore does_not_compile">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<p><span class="caption">Listing 18-10: Attempting to use an irrefutable pattern
with <code>if let</code></span></p>
<p>Rust complains that it doesn’t make sense to use <code>if let</code> with an irrefutable
pattern:</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<p>For this reason, match arms must use refutable patterns, except for the last
arm, which should match any remaining values with an irrefutable pattern. Rust
allows us to use an irrefutable pattern in a <code>match</code> with only one arm, but
this syntax isn’t particularly useful and could be replaced with a simpler
<code>let</code> statement.</p>
<p>Now that you know where to use patterns and the difference between refutable
and irrefutable patterns, let’s cover all the syntax we can use to create
patterns.</p>
<a class="header" href="#pattern-syntax" id="pattern-syntax"><h2>Pattern Syntax</h2></a>
<p>Throughout the book, you’ve seen examples of many kinds of patterns. In this
section, we gather all the syntax valid in patterns and discuss why you might
want to use each one.</p>
<a class="header" href="#matching-literals" id="matching-literals"><h3>Matching Literals</h3></a>
<p>As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>This code prints <code>one</code> because the value in <code>x</code> is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.</p>
<a class="header" href="#matching-named-variables" id="matching-named-variables"><h3>Matching Named Variables</h3></a>
<p>Named variables are irrefutable patterns that match any value, and we’ve used
them many times in the book. However, there is a complication when you use
named variables in <code>match</code> expressions. Because <code>match</code> starts a new scope,
variables declared as part of a pattern inside the <code>match</code> expression will
shadow those with the same name outside the <code>match</code> construct, as is the case
with all variables. In Listing 18-11, we declare a variable named <code>x</code> with the
value <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code>. We then create a
<code>match</code> expression on the value <code>x</code>. Look at the patterns in the match arms and
<code>println!</code> at the end, and try to figure out what the code will print before
running this code or reading further.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-11: A <code>match</code> expression with an arm that
introduces a shadowed variable <code>y</code></span></p>
<p>Let’s walk through what happens when the <code>match</code> expression runs. The pattern
in the first match arm doesn’t match the defined value of <code>x</code>, so the code
continues.</p>
<p>The pattern in the second match arm introduces a new variable named <code>y</code> that
will match any value inside a <code>Some</code> value. Because we’re in a new scope inside
the <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at
the beginning with the value 10. This new <code>y</code> binding will match any value
inside a <code>Some</code>, which is what we have in <code>x</code>. Therefore, this new <code>y</code> binds to
the inner value of the <code>Some</code> in <code>x</code>. That value is <code>5</code>, so the expression for
that arm executes and prints <code>Matched, y = 5</code>.</p>
<p>If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, the patterns in the first
two arms wouldn’t have matched, so the value would have matched to the
underscore. We didn’t introduce the <code>x</code> variable in the pattern of the
underscore arm, so the <code>x</code> in the expression is still the outer <code>x</code> that hasn’t
been shadowed. In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>
<p>When the <code>match</code> expression is done, its scope ends, and so does the scope of
the inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>
<p>To create a <code>match</code> expression that compares the values of the outer <code>x</code> and
<code>y</code>, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We’ll talk about match guards later in the “Extra
Conditionals with Match Guards” section.</p>
<a class="header" href="#multiple-patterns" id="multiple-patterns"><h3>Multiple Patterns</h3></a>
<p>In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax,
which means <em>or</em>. For example, the following code matches the value of <code>x</code>
against the match arms, the first of which has an <em>or</em> option, meaning if the
value of <code>x</code> matches either of the values in that arm, that arm’s code will
run:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>This code prints <code>one or two</code>.</p>
<a class="header" href="#matching-ranges-of-values-with-" id="matching-ranges-of-values-with-"><h3>Matching Ranges of Values with <code>...</code></h3></a>
<p>The <code>...</code> syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the range, that
arm will execute:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient than using the <code>|</code> operator to express the same idea; instead of <code>1 ... 5</code>, we would have to specify <code>1 | 2 | 3 | 4 | 5</code> if we used <code>|</code>. Specifying
a range is much shorter, especially if we want to match, say, any number
between 1 and 1,000!</p>
<p>Ranges are only allowed with numeric values or <code>char</code> values, because the
compiler checks that the range isn’t empty at compile time. The only types for
which Rust can tell if a range is empty or not are <code>char</code> and numeric values.</p>
<p>Here is an example using ranges of <code>char</code> values:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 'c';

match x {
    'a' ... 'j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>Rust can tell that <code>c</code> is within the first pattern’s range and prints <code>early ASCII letter</code>.</p>
<a class="header" href="#destructuring-to-break-apart-values" id="destructuring-to-break-apart-values"><h3>Destructuring to Break Apart Values</h3></a>
<p>We can also use patterns to destructure structs, enums, tuples, and references
to use different parts of these values. Let’s walk through each value.</p>
<a class="header" href="#destructuring-structs" id="destructuring-structs"><h4>Destructuring Structs</h4></a>
<p>Listing 18-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can
break apart using a pattern with a <code>let</code> statement.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Listing 18-12: Destructuring a struct’s fields into
separate variables</span></p>
<p>This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code>
and <code>y</code> fields of the <code>p</code> variable. This example shows that the names of the
variables in the pattern don’t have to match the field names of the struct. But
it’s common to want the variable names to match the field names to make it
easier to remember which variables came from which fields.</p>
<p>Because having variable names match the fields is common and because writing
<code>let Point { x: x, y: y } = p;</code> contains a lot of duplication, there is a
shorthand for patterns that match struct fields: you only need to list the name
of the struct field, and the variables created from the pattern will have the
same names. Listing 18-13 shows code that behaves in the same way as the code
in Listing 18-12, but the variables created in the <code>let</code> pattern are <code>x</code> and
<code>y</code> instead of <code>a</code> and <code>b</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span></p>
<p>This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> fields
of the <code>p</code> variable. The outcome is that the variables <code>x</code> and <code>y</code> contain the
values from the <code>p</code> struct.</p>
<p>We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.</p>
<p>Listing 18-14 shows a <code>match</code> expression that separates <code>Point</code> values into
three cases: points that lie directly on the <code>x</code> axis (which is true when <code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or neither.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct Point {
#     x: i32,
#     y: i32,
# }
#
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span></p>
<p>The first arm will match any point that lies on the <code>x</code> axis by specifying that
the <code>y</code> field matches if its value matches the literal <code>0</code>. The pattern still
creates an <code>x</code> variable that we can use in the code for this arm.</p>
<p>Similarly, the second arm matches any point on the <code>y</code> axis by specifying that
the <code>x</code> field matches if its value is <code>0</code> and creates a variable <code>y</code> for the
value of the <code>y</code> field. The third arm doesn’t specify any literals, so it
matches any other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code>
containing a 0, so this code will print <code>On the y axis at 7</code>.</p>
<a class="header" href="#destructuring-enums" id="destructuring-enums"><h4>Destructuring Enums</h4></a>
<p>We’ve destructured enums earlier in this book, for example, when we
destructured <code>Option&lt;i32&gt;</code> in Listing 6-5 in Chapter 6. One detail we haven’t
mentioned explicitly is that the pattern to destructure an enum should
correspond to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the <code>Message</code> enum from Listing 6-2 and write
a <code>match</code> with patterns that will destructure each inner value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        },
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span></p>
<p>This code will print <code>Change the color to red 0, green 160, and blue 255</code>. Try
changing the value of <code>msg</code> to see the code from the other arms run.</p>
<p>For enum variants without any data, like <code>Message::Quit</code>, we can’t destructure
the value any further. We can only match on the literal <code>Message::Quit</code> value,
and no variables are in that pattern.</p>
<p>For struct-like enum variants, such as <code>Message::Move</code>, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.</p>
<p>For tuple-like enum variants, like <code>Message::Write</code> that holds a tuple with one
element and <code>Message::ChangeColor</code> that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we’re
matching.</p>
<a class="header" href="#destructuring-nested-structs--enums" id="destructuring-nested-structs--enums"><h4>Destructuring Nested Structs &amp; Enums</h4></a>
<p>Up until now, all of our examples have been matching structures that were one
level deep. Matching can work on nested structures too!</p>
<p>We can refactor the example above to support both RGB and HSV colors:</p>
<pre><pre class="playpen"><code class="language-rust">enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32)
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )     
        },
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(
                &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
                h,
                s,
                v
            )
        }
        _ =&gt; ()
    }
}
</code></pre></pre>
<a class="header" href="#destructuring-references" id="destructuring-references"><h4>Destructuring References</h4></a>
<p>When the value we’re matching to our pattern contains a reference, we need to
destructure the reference from the value, which we can do by specifying a <code>&amp;</code>
in the pattern. Doing so lets us get a variable holding the value that the
reference points to rather than getting a variable that holds the reference.
This technique is especially useful in closures where we have iterators that
iterate over references, but we want to use the values in the closure rather
than the references.</p>
<p>The example in Listing 18-16 iterates over references to <code>Point</code> instances in a
vector, destructuring the reference and the struct so we can perform
calculations on the <code>x</code> and <code>y</code> values easily.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let points = vec![
    Point { x: 0, y: 0 },
    Point { x: 1, y: 5 },
    Point { x: 10, y: -3 },
];

let sum_of_squares: i32 = points
    .iter()
    .map(|&amp;Point { x, y }| x * x + y * y)
    .sum();
#}</code></pre></pre>
<p><span class="caption">Listing 18-16: Destructuring a reference to a struct into
the struct field values</span></p>
<p>This code gives us the variable <code>sum_of_squares</code> holding the value 135, which
is the result of squaring the <code>x</code> value and the <code>y</code> value, adding those
together, and then adding the result for each <code>Point</code> in the <code>points</code> vector to
get one number.</p>
<p>If we had not included the <code>&amp;</code> in <code>&amp;Point { x, y }</code>, we’d get a type mismatch
error, because <code>iter</code> would then iterate over references to the items in the
vector rather than the actual values. The error would look like this:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt;
   |
14 |         .map(|Point { x, y }| x * x + y * y)
   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`
   |
   = note: expected type `&amp;Point`
              found type `Point`
</code></pre>
<p>This error indicates that Rust was expecting our closure to match <code>&amp;Point</code>, but
we tried to match directly to a <code>Point</code> value, not a reference to a <code>Point</code>.</p>
<a class="header" href="#destructuring-structs-and-tuples" id="destructuring-structs-and-tuples"><h4>Destructuring Structs and Tuples</h4></a>
<p>We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
#}</code></pre></pre>
<p>This code lets us break complex types into their component parts so we can use
the values we’re interested in separately.</p>
<p>Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.</p>
<a class="header" href="#ignoring-values-in-a-pattern" id="ignoring-values-in-a-pattern"><h3>Ignoring Values in a Pattern</h3></a>
<p>You’ve seen that it’s sometimes useful to ignore values in a pattern, such as
in the last arm of a <code>match</code>, to get a catchall that doesn’t actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the <code>_</code>
pattern (which you’ve seen), using the <code>_</code> pattern within another pattern,
using a name that starts with an underscore, or using <code>..</code> to ignore remaining
parts of a value. Let’s explore how and why to use each of these patterns.</p>
<a class="header" href="#ignoring-an-entire-value-with-_" id="ignoring-an-entire-value-with-_"><h4>Ignoring an Entire Value with <code>_</code></h4></a>
<p>We’ve used the underscore (<code>_</code>) as a wildcard pattern that will match any value
but not bind to the value. Although the underscore <code>_</code> pattern is especially
useful as the last arm in a <code>match</code> expression, we can use it in any pattern,
including function parameters, as shown in Listing 18-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">Listing 18-17: Using <code>_</code> in a function signature</span></p>
<p>This code will completely ignore the value passed as the first argument, <code>3</code>,
and will print <code>This code only uses the y parameter: 4</code>.</p>
<p>In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn’t include the unused parameter. Ignoring
a function parameter can be especially useful in some cases, for example, when
implementing a trait when you need a certain type signature but the function
body in your implementation doesn’t need one of the parameters. The compiler
will then not warn about unused function parameters, as it would if you used a
name instead.</p>
<a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_" id="ignoring-parts-of-a-value-with-a-nested-_"><h4>Ignoring Parts of a Value with a Nested <code>_</code></h4></a>
<p>We can also use <code>_</code> inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a setting’s value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and can give the setting a value if it is
currently unset.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
#}</code></pre></pre>
<p><span class="caption">Listing 18-18: Using an underscore within patterns that
match <code>Some</code> variants when we don’t need to use the value inside the
<code>Some</code></span></p>
<p>This code will print <code>Can't overwrite an existing customized value</code> and then
<code>setting is Some(5)</code>. In the first match arm, we don’t need to match on or use
the values inside either <code>Some</code> variant, but we do need to test for the case
when <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant. In that
case, we print why we’re not changing <code>setting_value</code>, and it doesn’t get
changed.</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are
<code>None</code>) expressed by the <code>_</code> pattern in the second arm, we want to allow
<code>new_setting_value</code> to become <code>setting_value</code>.</p>
<p>We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span></p>
<p>This code will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be
ignored.</p>
<a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_" id="ignoring-an-unused-variable-by-starting-its-name-with-_"><h4>Ignoring an Unused Variable by Starting Its Name with <code>_</code></h4></a>
<p>If you create a variable but don’t use it anywhere, Rust will usually issue a
warning because that could be a bug. But sometimes it’s useful to create a
variable you won’t use yet, such as when you’re prototyping or just starting a
project. In this situation, you can tell Rust not to warn you about the unused
variable by starting the name of the variable with an underscore. In Listing
18-20, we create two unused variables, but when we run this code, we should
only get a warning about one of them.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span></p>
<p>Here we get a warning about not using the variable <code>y</code>, but we don’t get a
warning about not using the variable preceded by the underscore.</p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name
that starts with an underscore. The syntax <code>_x</code> still binds the value to the
variable, whereas <code>_</code> doesn’t bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.</p>
<pre><code class="language-rust ignore does_not_compile">let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<p><span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span></p>
<p>We’ll receive an error because the <code>s</code> value will still be moved into <code>_s</code>,
which prevents us from using <code>s</code> again. However, using the underscore by itself
doesn’t ever bind to the value. Listing 18-22 will compile without any errors
because <code>s</code> doesn’t get moved into <code>_</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
#}</code></pre></pre>
<p><span class="caption">Listing 18-22: Using an underscore does not bind the
value</span></p>
<p>This code works just fine because we never bind <code>s</code> to anything; it isn’t moved.</p>
<a class="header" href="#ignoring-remaining-parts-of-a-value-with-" id="ignoring-remaining-parts-of-a-value-with-"><h4>Ignoring Remaining Parts of a Value with <code>..</code></h4></a>
<p>With values that have many parts, we can use the <code>..</code> syntax to use only a few
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The <code>..</code> pattern ignores any parts of a value that we haven’t
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
<code>Point</code> struct that holds a coordinate in three-dimensional space. In the
<code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore
the values in the <code>y</code> and <code>z</code> fields.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-23: Ignoring all fields of a <code>Point</code> except
for <code>x</code> by using <code>..</code></span></p>
<p>We list the <code>x</code> value and then just include the <code>..</code> pattern. This is quicker
than having to list <code>y: _</code> and <code>z: _</code>, particularly when we’re working with
structs that have lots of fields in situations where only one or two fields are
relevant.</p>
<p>The syntax <code>..</code> will expand to as many values as it needs to be. Listing 18-24
shows how to use <code>..</code> with a tuple.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span></p>
<p>In this code, the first and last value are matched with <code>first</code> and <code>last</code>. The
<code>..</code> will match and ignore everything in the middle.</p>
<p>However, using <code>..</code> must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using <code>..</code> ambiguously, so it will not
compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">Listing 18-25: An attempt to use <code>..</code> in an ambiguous
way</span></p>
<p>When we compile this example, we get this error:</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<p>It’s impossible for Rust to determine how many values in the tuple to ignore
before matching a value with <code>second</code> and then how many further values to
ignore thereafter. This code could mean that we want to ignore <code>2</code>, bind
<code>second</code> to <code>4</code>, and then ignore <code>8</code>, <code>16</code>, and <code>32</code>; or that we want to ignore
<code>2</code> and <code>4</code>, bind <code>second</code> to <code>8</code>, and then ignore <code>16</code> and <code>32</code>; and so forth.
The variable name <code>second</code> doesn’t mean anything special to Rust, so we get a
compiler error because using <code>..</code> in two places like this is ambiguous.</p>
<a class="header" href="#extra-conditionals-with-match-guards" id="extra-conditionals-with-match-guards"><h3>Extra Conditionals with Match Guards</h3></a>
<p>A <em>match guard</em> is an additional <code>if</code> condition specified after the pattern in
a <code>match</code> arm that must also match, along with the pattern matching, for that
arm to be chosen. Match guards are useful for expressing more complex ideas
than a pattern alone allows.</p>
<p>The condition can use variables created in the pattern. Listing 18-26 shows a
<code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match
guard of <code>if x &lt; 5</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-26: Adding a match guard to a pattern</span></p>
<p>This example will print <code>less than five: 4</code>. When <code>num</code> is compared to the
pattern in the first arm, it matches, because <code>Some(4)</code> matches <code>Some(x)</code>. Then
the match guard checks whether the value in <code>x</code> is less than <code>5</code>, and because
it is, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(10)</code> instead, the match guard in the first arm would
have been false because 10 is not less than 5. Rust would then go to the second
arm, which would match because the second arm doesn’t have a match guard and
therefore matches any <code>Some</code> variant.</p>
<p>There is no way to express the <code>if x &lt; 5</code> condition within a pattern, so the
match guard gives us the ability to express this logic.</p>
<p>In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that a new variable was created inside the
pattern in the <code>match</code> expression instead of using the variable outside the
<code>match</code>. That new variable meant we couldn’t test against the value of the
outer variable. Listing 18-30 shows how we can use a match guard to fix this
problem.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-27: Using a match guard to test for equality
with an outer variable</span></p>
<p>This code will now print <code>Default case, x = Some(5)</code>. The pattern in the second
match arm doesn’t introduce a new variable <code>y</code> that would shadow the outer <code>y</code>,
meaning we can use the outer <code>y</code> in the match guard. Instead of specifying the
pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify
<code>Some(n)</code>. This creates a new variable <code>n</code> that doesn’t shadow anything because
there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>The match guard <code>if n == y</code> is not a pattern and therefore doesn’t introduce
new variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new shadowed <code>y</code>, and
we can look for a value that has the same value as the outer <code>y</code> by comparing
<code>n</code> to <code>y</code>.</p>
<p>You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-31 shows the precedence of combining a match guard with a pattern that uses
<code>|</code>. The important part of this example is that the <code>if y</code> match guard applies
to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only applies to
<code>6</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-18: Combining multiple patterns with a match
guard</span></p>
<p>The match condition states that the arm only matches if the value of <code>x</code> is
equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the
pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code>
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints <code>no</code>. The reason is that the <code>if</code>
condition applies to the whole pattern <code>4 | 5 | 6</code>, not only to the last value
<code>6</code>. In other words, the precedence of a match guard in relation to a pattern
behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
<code>|</code> operator, the arm would have matched and the program would have printed
<code>yes</code>.</p>
<a class="header" href="#a-bindings" id="a-bindings"><h3><code>@</code> Bindings</h3></a>
<p>The <em>at</em> operator (<code>@</code>) lets us create a variable that holds a value at the
same time we’re testing that value to see whether it matches a pattern. Listing
18-32 shows an example where we want to test that a <code>Message::Hello</code> <code>id</code> field
is within the range <code>3...7</code>. But we also want to bind the value to the variable
<code>id_variable</code> so we can use it in the code associated with the arm. We could
name this variable <code>id</code>, the same as the field, but for this example we’ll use
a different name.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3...7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10...12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-19: Using <code>@</code> to bind to a value in a pattern
while also testing it</span></p>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id_variable @</code> before the range <code>3...7</code>, we’re capturing whatever value matched the range
while also testing that the value matched the range pattern.</p>
<p>In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12, but
the code that goes with that pattern doesn’t know which it is. The pattern code
isn’t able to use the value from the <code>id</code> field, because we haven’t saved the
<code>id</code> value in a variable.</p>
<p>In the last arm, where we’ve specified a variable without a range, we do have
the value available to use in the arm’s code in a variable named <code>id</code>. The
reason is that we’ve used the struct field shorthand syntax. But we haven’t
applied any test to the value in the <code>id</code> field in this arm, as we did with the
first two arms: any value would match this pattern.</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<a class="header" href="#legacy-patterns-ref-and-ref-mut" id="legacy-patterns-ref-and-ref-mut"><h3>Legacy patterns: <code>ref</code> and <code>ref mut</code></h3></a>
<p>In older versions of Rust, <code>match</code> would assume that you want to move what is
matched. But sometimes, that’s not what you wanted. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let robot_name = &amp;Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p>Here, <code>robot_name</code> is a <code>&amp;Option&lt;String&gt;</code>. Rust would then complain that
<code>Some(name)</code> doesn’t match up with <code>&amp;Option&lt;T&gt;</code>, so you’d have to write this:</p>
<pre><code class="language-rust ignore">let robot_name = &amp;Some(String::from(&quot;Bors&quot;));

match robot_name {
    &amp;Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
</code></pre>
<p>Next, Rust would complain that <code>name</code> is trying to move the <code>String</code> out of
the option, but because it’s a reference to an option, it’s borrowed, and so
can’t be moved out of. This is where the <code>ref</code> keyword comes into play:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let robot_name = &amp;Some(String::from(&quot;Bors&quot;));

match robot_name {
    &amp;Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p>The <code>ref</code> keyword is like the opposite of <code>&amp;</code> in patterns; this says “please
bind <code>ref</code> to be a <code>&amp;String</code>, don’t try to move it out. In other words, the
<code>&amp;</code> in <code>&amp;Some</code> is matching against a reference, but <code>ref</code> <em>creates</em> a
reference. <code>ref mut</code> is like <code>ref</code>, but for mutable references.</p>
<p>Anyway, today’s Rust doesn’t work like this. If you try to <code>match</code> on
something borrowed, then all of the bindings you create will attempt to
borrow as well. This means that the original code works as you’d expect.</p>
<p>Because Rust is backwards compatible, we couldn’t remove <code>ref</code> and <code>ref mut</code>,
and they’re sometimes useful in obscure situations, where you want to
partially borrow part of a struct as mutable and another part as immutable.
But you may see them in older Rust code, so knowing what they do is still
useful.</p>
<a class="header" href="#summary-5" id="summary-5"><h2>Summary</h2></a>
<p>Rust’s patterns are very useful in that they help distinguish between different
kinds of data. When used in <code>match</code> expressions, Rust ensures your patterns
cover every possible value, or your program won’t compile. Patterns in <code>let</code>
statements and function parameters make those constructs more useful, enabling
the destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.</p>
<p>Next, for the penultimate chapter of the book, we’ll look at some advanced
aspects of a variety of Rust’s features.</p>
<a class="header" href="#advanced-features" id="advanced-features"><h1>Advanced Features</h1></a>
<p>By now, you’ve learned the most commonly used parts of the Rust programming
language. Before we do one more project in Chapter 20, we’ll look at a few
aspects of the language you might run into every once in a while. You can use
this chapter as a reference for when you encounter any unknowns when using
Rust. The features you’ll learn to use in this chapter are useful in very
specific situations. Although you might not reach for them often, we want to
make sure you have a grasp of all the features Rust has to offer.</p>
<p>In this chapter, we’ll cover:</p>
<ul>
<li>Unsafe Rust: how to opt out of some of Rust’s guarantees and take
responsibility for manually upholding those guarantees</li>
<li>Advanced lifetimes: syntax for complex lifetime situations</li>
<li>Advanced traits: associated types, default type parameters, fully qualified
syntax, supertraits, and the newtype pattern in relation to traits</li>
<li>Advanced types: more about the newtype pattern, type aliases, the never type,
and dynamically sized types</li>
<li>Advanced functions and closures: function pointers and returning closures</li>
<li>Macros: ways to define code that defines more code at compile time</li>
</ul>
<p>It’s a panoply of Rust features with something for everyone! Let’s dive in!</p>
<a class="header" href="#unsafe-rust" id="unsafe-rust"><h2>Unsafe Rust</h2></a>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called <em>unsafe Rust</em>
and works just like regular Rust, but gives us extra superpowers.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs rather than accept some
invalid programs. Although the code might be okay, as far as Rust is able to
tell, it’s not! In these cases, you can use unsafe code to tell the compiler,
“Trust me, I know what I’m doing.” The downside is that you use it at your own
risk: if you use unsafe code incorrectly, problems due to memory unsafety, such
as null pointer dereferencing, can occur.</p>
<p>Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.</p>
<a class="header" href="#unsafe-superpowers" id="unsafe-superpowers"><h3>Unsafe Superpowers</h3></a>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block
that holds the unsafe code. You can take four actions in unsafe Rust, called
<em>unsafe superpowers</em>, that you can’t in safe Rust. Those superpowers include
the ability to:</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
</ul>
<p>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker
or disable any other of Rust’s safety checks: if you use a reference in unsafe
code, it will still be checked. The <code>unsafe</code> keyword only gives you access to
these four features that are then not checked by the compiler for memory
safety. You’ll still get some degree of safety inside of an unsafe block.</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an <code>unsafe</code> block will
access memory in a valid way.</p>
<p>People are fallible, and mistakes will happen, but by requiring these four
unsafe operations to be inside blocks annotated with <code>unsafe</code> you’ll know that
any errors related to memory safety must be within an <code>unsafe</code> block. Keep
<code>unsafe</code> blocks small; you’ll be thankful later when you investigate memory
bugs.</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code>
from leaking out into all the places that you or your users might want to use
the functionality implemented with <code>unsafe</code> code, because using a safe
abstraction is safe.</p>
<p>Let’s look at each of the four unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.</p>
<a class="header" href="#dereferencing-a-raw-pointer" id="dereferencing-a-raw-pointer"><h3>Dereferencing a Raw Pointer</h3></a>
<p>In Chapter 4, in the “Dangling References” section, we mentioned that the
compiler ensures references are always valid. Unsafe Rust has two new types
called <em>raw pointers</em> that are similar to references. As with references, raw
pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the dereference operator; it’s part of the
type name. In the context of raw pointers, <em>immutable</em> means that the pointer
can’t be directly assigned to after being dereferenced.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.</p>
<p>Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
#}</code></pre></pre>
<p><span class="caption">Listing 19-1: Creating raw pointers from references</span></p>
<p>Notice that we don’t include the <code>unsafe</code> keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.</p>
<p>We’ve created raw pointers by using <code>as</code> to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can’t make that assumption about just any raw
pointer.</p>
<p>Next, we’ll create a raw pointer whose validity we can’t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let address = 0x012345usize;
let r = address as *const i32;
#}</code></pre></pre>
<p><span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span></p>
<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em>
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-3: Dereferencing raw pointers within an
<code>unsafe</code> block</span></p>
<p>Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.</p>
<p>Note also that in Listing 19-1 and 19-3, we created <code>*const i32</code> and <code>*mut i32</code>
raw pointers that both pointed to the same memory location, where <code>num</code> is
stored. If we instead tried to create an immutable and a mutable reference to
<code>num</code>, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section,
“Calling an Unsafe Function or Method.” Another case is when building up safe
abstractions that the borrow checker doesn’t understand. We’ll introduce unsafe
functions and then look at an example of a safe abstraction that uses unsafe
code.</p>
<a class="header" href="#calling-an-unsafe-function-or-method" id="calling-an-unsafe-function-or-method"><h3>Calling an Unsafe Function or Method</h3></a>
<p>The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra <code>unsafe</code> before the rest of the definition. The
<code>unsafe</code> keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust can’t guarantee we’ve
met these requirements. By calling an unsafe function within an <code>unsafe</code> block,
we’re saying that we’ve read this function’s documentation and take
responsibility for upholding the function’s contracts.</p>
<p>Here is an unsafe function named <code>dangerous</code> that doesn’t do anything in its
body:</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
# #![allow(unused_variables)]
#fn main() {
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
#}</code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we
try to call <code>dangerous</code> without the <code>unsafe</code> block, we’ll get an error:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>By inserting the <code>unsafe</code> block around our call to <code>dangerous</code>, we’re asserting
to Rust that we’ve read the function’s documentation, we understand how to use
it properly, and we’ve verified that we’re fulfilling the contract of the
function.</p>
<p>Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other
unsafe operations within an unsafe function, we don’t need to add another
<code>unsafe</code> block.</p>
<a class="header" href="#creating-a-safe-abstraction-over-unsafe-code" id="creating-a-safe-abstraction-over-unsafe-code"><h4>Creating a Safe Abstraction over Unsafe Code</h4></a>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study a function from the standard
library, <code>split_at_mut</code>, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use <code>split_at_mut</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
#}</code></pre></pre>
<p><span class="caption">Listing 19-4: Using the safe <code>split_at_mut</code>
function</span></p>
<p>We can’t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won’t compile. For simplicity, we’ll
implement <code>split_at_mut</code> as a function rather than a method and only for slices
of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">Listing 19-5: An attempted implementation of
<code>split_at_mut</code> using only safe Rust</span></p>
<p>This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the index to split the slice at, the function will panic
before it attempts to use that index.</p>
<p>Then we return two mutable slices in a tuple: one from the start of the
original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the
slice.</p>
<p>When we try to compile the code in Listing 19-5, we’ll get an error.</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-6: Using unsafe code in the implementation of
the <code>split_at_mut</code> function</span></p>
<p>Recall from “The Slice Type” section in Chapter 4 that slices are a pointer to
some data and the length of the slice. We use the <code>len</code> method to get the
length of a slice and the <code>as_mut_ptr</code> method to access the raw pointer of a
slice. In this case, because we have a mutable slice to <code>i32</code> values,
<code>as_mut_ptr</code> returns a raw pointer with the type <code>*mut i32</code>, which we’ve stored
in the variable <code>ptr</code>.</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to
the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>offset</code>
method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at
<code>mid</code>, and we create a slice using that pointer and the remaining number of
items after <code>mid</code> as the length.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The <code>offset</code> method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to
<code>slice::from_raw_parts_mut</code> and <code>offset</code> so we could call them. By looking at
the code and by adding the assertion that <code>mid</code> must be less than or equal to
<code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of <code>unsafe</code>.</p>
<p>Note that we don’t need to mark the resulting <code>split_at_mut</code> function as
<code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
<code>unsafe</code> code in a safe way, because it creates only valid pointers from the
data this function has access to.</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let slice : &amp;[i32] = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
#}</code></pre></pre>
<p><span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span></p>
<p>We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>slice</code> as though it’s a valid slice results in undefined behavior. If we would
not have taken care to align <code>address</code> to 4 (the alignment of <code>i32</code>), then even
just calling <code>slice::from_raw_parts_mut</code> would already be undefined behavior --
slices must always be aligned, even if they are not used (and even if they are
empty).</p>
<a class="header" href="#using-extern-functions-to-call-external-code" id="using-extern-functions-to-call-external-code"><h4>Using <code>extern</code> Functions to Call External Code</h4></a>
<p>Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, <code>extern</code>, that facilitates the creation
and use of a <em>Foreign Function Interface (FFI)</em>. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.</p>
<p>Listing 19-8 demonstrates how to set up an integration with the <code>abs</code> function
from the C standard library. Functions declared within <code>extern</code> blocks are
always unsafe to call from Rust code. The reason is that other languages don’t
enforce Rust’s rules and guarantees, and Rust can’t check them, so
responsibility falls on the programmer to ensure safety.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-8: Declaring and calling an <code>extern</code> function
defined in another language</span></p>
<p>Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of external
functions from another language we want to call. The <code>&quot;C&quot;</code> part defines which
<em>application binary interface (ABI)</em> the external function uses: the ABI
defines how to call the function at the assembly level. The <code>&quot;C&quot;</code> ABI is the
most common and follows the C programming language’s ABI.</p>
<blockquote>
<a class="header" href="#calling-rust-functions-from-other-languages" id="calling-rust-functions-from-other-languages"><h4>Calling Rust Functions from Other Languages</h4></a>
<p>We can also use <code>extern</code> to create an interface that allows other languages
to call Rust functions. Instead of an <code>extern</code> block, we add the <code>extern</code>
keyword and specify the ABI to use just before the <code>fn</code> keyword. We also need
to add a <code>#[no_mangle]</code> annotation to tell the Rust compiler not to mangle
the name of this function. <em>Mangling</em> is when a compiler changes the name
we’ve given a function to a different name that contains more information for
other parts of the compilation process to consume but is less human readable.
Every programming language compiler mangles names slightly differently, so
for a Rust function to be nameable by other languages, we must disable the
Rust compiler’s name mangling.</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from
C code, after it’s compiled to a shared library and linked from C:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
#}</code></pre></pre>
<p>This usage of <code>extern</code> does not require <code>unsafe</code>.</p>
</blockquote>
<a class="header" href="#accessing-or-modifying-a-mutable-static-variable" id="accessing-or-modifying-a-mutable-static-variable"><h3>Accessing or Modifying a Mutable Static Variable</h3></a>
<p>Until now, we’ve not talked about <em>global variables</em>, which Rust does support
but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.</p>
<p>In Rust, global variables are called <em>static</em> variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Listing 19-9: Defining and using an immutable static
variable</span></p>
<p>Static variables are similar to constants, which we discussed in the
“Differences Between Variables and Constants” section in Chapter 3. The names
of static variables are in <code>SCREAMING_SNAKE_CASE</code> by convention, and we <em>must</em>
annotate the variable’s type, which is <code>&amp;'static str</code> in this example. Static
variables can only store references with the <code>'static</code> lifetime, which means
the Rust compiler can figure out the lifetime; we don’t need to annotate it
explicitly. Accessing an immutable static variable is safe.</p>
<p>Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever they’re used.</p>
<p>Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
<em>unsafe</em>. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust unsafe">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span></p>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any
code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. This
code compiles and prints <code>COUNTER: 3</code> as we would expect because it’s single
threaded. Having multiple threads access <code>COUNTER</code> would likely result in data
races.</p>
<p>With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.</p>
<a class="header" href="#implementing-an-unsafe-trait" id="implementing-an-unsafe-trait"><h3>Implementing an Unsafe Trait</h3></a>
<p>The final action that works only with <code>unsafe</code> is implementing an unsafe trait.
A trait is unsafe when at least one of its methods has some invariant that the
compiler can’t verify. We can declare that a trait is <code>unsafe</code> by adding the
<code>unsafe</code> keyword before <code>trait</code> and marking the implementation of the trait as
<code>unsafe</code> too, as shown in Listing 19-11.</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
# #![allow(unused_variables)]
#fn main() {
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span></p>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.</p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits we discussed in the
“Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits” section in Chapter
16: the compiler implements these traits automatically if our types are
composed entirely of <code>Send</code> and <code>Sync</code> types. If we implement a type that
contains a type that is not <code>Send</code> or <code>Sync</code>, such as raw pointers, and we want
to mark that type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust can’t verify
that our type upholds the guarantees that it can be safely sent across threads
or accessed from multiple threads; therefore, we need to do those checks
manually and indicate as such with <code>unsafe</code>.</p>
<a class="header" href="#when-to-use-unsafe-code" id="when-to-use-unsafe-code"><h3>When to Use Unsafe Code</h3></a>
<p>Using <code>unsafe</code> to take one of the four actions (superpowers) just discussed
isn’t wrong or even frowned upon. But it is trickier to get <code>unsafe</code> code
correct because the compiler can’t help uphold memory safety. When you have a
reason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code>
annotation makes it easier to track down the source of problems if they occur.</p>
<a class="header" href="#advanced-lifetimes" id="advanced-lifetimes"><h2>Advanced Lifetimes</h2></a>
<p>In Chapter 10 in the “Validating References with Lifetimes” section, you
learned how to annotate references with lifetime parameters to tell Rust how
lifetimes of different references relate. You saw how every reference has a
lifetime, but most of the time, Rust will let you elide lifetimes. Now we’ll
look at three advanced features of lifetimes that we haven’t covered yet:</p>
<ul>
<li>Lifetime subtyping: ensures that one lifetime outlives another lifetime</li>
<li>Lifetime bounds: specifies a lifetime for a reference to a generic type</li>
<li>Inference of trait object lifetimes: allows the compiler to infer trait
object lifetimes and when they need to be specified</li>
<li>The anonymous lifetime: making elision more obvious</li>
</ul>
<a class="header" href="#ensuring-one-lifetime-outlives-another-with-lifetime-subtyping" id="ensuring-one-lifetime-outlives-another-with-lifetime-subtyping"><h3>Ensuring One Lifetime Outlives Another with Lifetime Subtyping</h3></a>
<p><em>Lifetime subtyping</em> specifies that one lifetime should outlive another
lifetime. To explore lifetime subtyping, imagine we want to write a parser.
We’ll use a structure called <code>Context</code> that holds a reference to the string
we’re parsing. We’ll write a parser that will parse this string and return
success or failure. The parser will need to borrow the <code>Context</code> to do the
parsing. Listing 19-12 implements this parser code, except the code doesn’t
have the required lifetime annotations, so it won’t compile.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
</code></pre>
<p><span class="caption">Listing 19-12: Defining a parser without lifetime
annotations</span></p>
<p>Compiling the code results in errors because Rust expects lifetime parameters
on the string slice in <code>Context</code> and the reference to a <code>Context</code> in <code>Parser</code>.</p>
<p>For simplicity’s sake, the <code>parse</code> function returns <code>Result&lt;(), &amp;str&gt;</code>. That
is, the function will do nothing on success and, on failure, will return the
part of the string slice that didn’t parse correctly. A real implementation
would provide more error information and would return a structured data type
when parsing succeeds. We won’t be discussing those details because they aren’t
relevant to the lifetimes part of this example.</p>
<p>To keep this code simple, we won’t write any parsing logic. However, it’s very
likely that somewhere in the parsing logic we would handle invalid input by
returning an error that references the part of the input that is invalid; this
reference is what makes the code example interesting in regard to lifetimes.
Let’s pretend that the logic of our parser is that the input is invalid after
the first byte. Note that this code might panic if the first byte is not on a
valid character boundary; again, we’re simplifying the example to focus on the
lifetimes involved.</p>
<p>To get this code to compile, we need to fill in the lifetime parameters for the
string slice in <code>Context</code> and the reference to the <code>Context</code> in <code>Parser</code>. The
most straightforward way to do this is to use the same lifetime name
everywhere, as shown in Listing 19-13. Recall from the “Lifetime Annotations in
Struct Definitions” section in Chapter 10 that each of <code>struct Context&lt;'a&gt;</code>,
<code>struct Parser&lt;'a&gt;</code>, and <code>impl&lt;'a&gt;</code> is declaring a new lifetime parameter.
While their names happen to all be the same, the three lifetime parameters
declared in this example aren’t related.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-13: Annotating all references in <code>Context</code> and
<code>Parser</code> with lifetime parameters</span></p>
<p>This code compiles just fine. It tells Rust that a <code>Parser</code> holds a reference
to a <code>Context</code> with lifetime <code>'a</code> and that <code>Context</code> holds a string slice that
also lives as long as the reference to the <code>Context</code> in <code>Parser</code>. Rust’s
compiler error message stated that lifetime parameters were required for these
references, and we’ve now added lifetime parameters.</p>
<p>Next, in Listing 19-14, we’ll add a function that takes an instance of
<code>Context</code>, uses a <code>Parser</code> to parse that context, and returns what <code>parse</code>
returns. This code doesn’t quite work.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-14: An attempt to add a <code>parse_context</code>
function that takes a <code>Context</code> and uses a <code>Parser</code></span></p>
<p>We get two verbose errors when we try to compile the code with the addition of
the <code>parse_context</code> function:</p>
<pre><code class="language-text">error[E0597]: borrowed value does not live long enough
  --&gt; src/lib.rs:14:5
   |
14 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
15 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^

error[E0597]: `context` does not live long enough
  --&gt; src/lib.rs:14:24
   |
14 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
15 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^
</code></pre>
<p>These errors state that the <code>Parser</code> instance that is created and the <code>context</code>
parameter live only until the end of the <code>parse_context</code> function. But they
both need to live for the entire lifetime of the function.</p>
<p>In other words, <code>Parser</code> and <code>context</code> need to <em>outlive</em> the entire function
and be valid before the function starts as well as after it ends for all the
references in this code to always be valid. The <code>Parser</code> we’re creating and the
<code>context</code> parameter go out of scope at the end of the function, because
<code>parse_context</code> takes ownership of <code>context</code>.</p>
<p>To figure out why these errors occur, let’s look at the definitions in Listing
19-13 again, specifically the references in the signature of the <code>parse</code> method:</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
</code></pre>
<p>Remember the elision rules? If we annotate the lifetimes of the references
rather than eliding, the signature would be as follows:</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {
</code></pre>
<p>That is, the error part of the return value of <code>parse</code> has a lifetime that is
tied to the lifetime of the <code>Parser</code> instance (that of <code>&amp;self</code> in the <code>parse</code>
method signature). That makes sense: the returned string slice references the
string slice in the <code>Context</code> instance held by the <code>Parser</code>, and the definition
of the <code>Parser</code> struct specifies that the lifetime of the reference to
<code>Context</code> and the lifetime of the string slice that <code>Context</code> holds should be
the same.</p>
<p>The problem is that the <code>parse_context</code> function returns the value returned
from <code>parse</code>, so the lifetime of the return value of <code>parse_context</code> is tied to
the lifetime of the <code>Parser</code> as well. But the <code>Parser</code> instance created in the
<code>parse_context</code> function won’t live past the end of the function (it’s
temporary), and <code>context</code> will go out of scope at the end of the function
(<code>parse_context</code> takes ownership of it).</p>
<p>Rust thinks we’re trying to return a reference to a value that goes out of
scope at the end of the function, because we annotated all the lifetimes with
the same lifetime parameter. The annotations told Rust the lifetime of the
string slice that <code>Context</code> holds is the same as that of the lifetime of the
reference to <code>Context</code> that <code>Parser</code> holds.</p>
<p>The <code>parse_context</code> function can’t see that within the <code>parse</code> function, the
string slice returned will outlive <code>Context</code> and <code>Parser</code> and that the
reference <code>parse_context</code> returns refers to the string slice, not to <code>Context</code>
or <code>Parser</code>.</p>
<p>By knowing what the implementation of <code>parse</code> does, we know that the only
reason the return value of <code>parse</code> is tied to the <code>Parser</code> instance is that
it’s referencing the <code>Parser</code> instance’s <code>Context</code>, which is referencing the
string slice. So, it’s really the lifetime of the string slice that
<code>parse_context</code> needs to care about. We need a way to tell Rust that the string
slice in <code>Context</code> and the reference to the <code>Context</code> in <code>Parser</code> have
different lifetimes and that the return value of <code>parse_context</code> is tied to the
lifetime of the string slice in <code>Context</code>.</p>
<p>First, we’ll try giving <code>Parser</code> and <code>Context</code> different lifetime parameters,
as shown in Listing 19-15. We’ll use <code>'s</code> and <code>'c</code> as lifetime parameter names
to clarify which lifetime goes with the string slice in <code>Context</code> and which
goes with the reference to <code>Context</code> in <code>Parser</code>. Note that this solution won’t
completely fix the problem, but it’s a start. We’ll look at why this fix isn’t
sufficient when we try to compile.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-15: Specifying different lifetime parameters
for the references to the string slice and to <code>Context</code></span></p>
<p>We’ve annotated the lifetimes of the references in all the same places that we
annotated them in Listing 19-13. But this time we used different parameters
depending on whether the reference goes with the string slice or with
<code>Context</code>. We’ve also added an annotation to the string slice part of the
return value of <code>parse</code> to indicate that it goes with the lifetime of the
string slice in <code>Context</code>.</p>
<p>When we try to compile now, we get the following error:</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
 --&gt; src/lib.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
</code></pre>
<p>Rust doesn’t know of any relationship between <code>'c</code> and <code>'s</code>. To be valid, the
referenced data in <code>Context</code> with lifetime <code>'s</code> needs to be constrained to
guarantee that it lives longer than the reference with lifetime <code>'c</code>. If <code>'s</code>
is not longer than <code>'c</code>, the reference to <code>Context</code> might not be valid.</p>
<p>Now we get to the point of this section: the Rust feature <em>lifetime
subtyping</em> specifies that one lifetime parameter lives at least as long as
another one. In the angle brackets where we declare lifetime parameters, we can
declare a lifetime <code>'a</code> as usual and declare a lifetime <code>'b</code> that lives at
least as long as <code>'a</code> by declaring <code>'b</code> using the syntax <code>'b: 'a</code>.</p>
<p>In our definition of <code>Parser</code>, to say that <code>'s</code> (the lifetime of the string
slice) is guaranteed to live at least as long as <code>'c</code> (the lifetime of the
reference to <code>Context</code>), we change the lifetime declarations to look like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Context&lt;'a&gt;(&amp;'a str);
#
struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
#}</code></pre></pre>
<p>Now the reference to <code>Context</code> in the <code>Parser</code> and the reference to the string
slice in the <code>Context</code> have different lifetimes; we’ve ensured that the
lifetime of the string slice is longer than the reference to the <code>Context</code>.</p>
<p>That was a very long-winded example, but as we mentioned at the start of this
chapter, Rust’s advanced features are very specific. You won’t often need the
syntax we described in this example, but in such situations, you’ll know how to
refer to something and give it the necessary lifetime.</p>
<a class="header" href="#lifetime-bounds-on-references-to-generic-types" id="lifetime-bounds-on-references-to-generic-types"><h3>Lifetime Bounds on References to Generic Types</h3></a>
<p>In the “Trait Bounds” section in Chapter 10, we discussed using trait bounds on
generic types. We can also add lifetime parameters as constraints on generic
types; these are called <em>lifetime bounds</em>. Lifetime bounds help Rust verify
that references in generic types won’t outlive the data they’re referencing.</p>
<p>As an example, consider a type that is a wrapper over references. Recall the
<code>RefCell&lt;T&gt;</code> type from the “<code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern”
section in Chapter 15: its <code>borrow</code> and <code>borrow_mut</code> methods return the types
<code>Ref</code> and <code>RefMut</code>, respectively. These types are wrappers over references that
keep track of the borrowing rules at runtime. The definition of the <code>Ref</code>
struct is shown in Listing 19-16, without lifetime bounds for now.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Ref&lt;'a, T&gt;(&amp;'a T);
</code></pre>
<p><span class="caption">Listing 19-16: Defining a struct to wrap a reference to a
generic type, without lifetime bounds</span></p>
<p>Without explicitly constraining the lifetime <code>'a</code> in relation to the generic
parameter <code>T</code>, Rust will error because it doesn’t know how long the generic
type <code>T</code> will live:</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<p>Because <code>T</code> can be any type, <code>T</code> could be a reference or a type that holds one
or more references, each of which could have their own lifetimes. Rust can’t be
sure <code>T</code> will live as long as <code>'a</code>.</p>
<p>Fortunately, the error provides helpful advice on how to specify the lifetime
bound in this case:</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points at
</code></pre>
<p>Listing 19-17 shows how to apply this advice by specifying the lifetime bound
when we declare the generic type <code>T</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
#}</code></pre></pre>
<p><span class="caption">Listing 19-17: Adding lifetime bounds on <code>T</code> to specify
that any references in <code>T</code> live at least as long as <code>'a</code></span></p>
<p>This code now compiles because the <code>T: 'a</code> syntax specifies that <code>T</code> can be any
type, but if it contains any references, the references must live at least as
long as <code>'a</code>.</p>
<p>We could solve this problem in a different way, as shown in the definition of a
<code>StaticRef</code> struct in Listing 19-18, by adding the <code>'static</code> lifetime bound on
<code>T</code>. This means if <code>T</code> contains any references, they must have the <code>'static</code>
lifetime.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StaticRef&lt;T: 'static&gt;(&amp;'static T);
#}</code></pre></pre>
<p><span class="caption">Listing 19-18: Adding a <code>'static</code> lifetime bound to <code>T</code>
to constrain <code>T</code> to types that have only <code>'static</code> references or no
references</span></p>
<p>Because <code>'static</code> means the reference must live as long as the entire program,
a type that contains no references meets the criteria of all references living
as long as the entire program (because there are no references). For the borrow
checker concerned about references living long enough, there is no real
distinction between a type that has no references and a type that has
references that live forever: both are the same for determining whether or not
a reference has a shorter lifetime than what it refers to.</p>
<a class="header" href="#inference-of-trait-object-lifetimes" id="inference-of-trait-object-lifetimes"><h3>Inference of Trait Object Lifetimes</h3></a>
<p>In Chapter 17 in the “Using Trait Objects that Allow for Values of Different
Types” section, we discussed trait objects, consisting of a trait behind a
reference, that allow us to use dynamic dispatch. We haven’t yet discussed what
happens if the type implementing the trait in the trait object has a lifetime
of its own. Consider Listing 19-19 where we have a trait <code>Red</code> and a struct
<code>Ball</code>. The <code>Ball</code> struct holds a reference (and thus has a lifetime parameter)
and also implements trait <code>Red</code>. We want to use an instance of <code>Ball</code> as the
trait object <code>Box&lt;dyn Red&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Red { }

struct Ball&lt;'a&gt; {
    diameter: &amp;'a i32,
}

impl&lt;'a&gt; Red for Ball&lt;'a&gt; { }

fn main() {
    let num = 5;

    let obj = Box::new(Ball { diameter: &amp;num }) as Box&lt;dyn Red&gt;;
}
</code></pre></pre>
<p><span class="caption">Listing 19-19: Using a type that has a lifetime parameter
with a trait object</span></p>
<p>This code compiles without any errors, even though we haven’t explicitly
annotated the lifetimes involved in <code>obj</code>. This code works because there are
rules for working with lifetimes and trait objects:</p>
<ul>
<li>The default lifetime of a trait object is <code>'static</code>.</li>
<li>With <code>&amp;'a Trait</code> or <code>&amp;'a mut Trait</code>, the default lifetime of the trait object
is <code>'a</code>.</li>
<li>With a single <code>T: 'a</code> clause, the default lifetime of the trait object is
<code>'a</code>.</li>
<li>With multiple clauses like <code>T: 'a</code>, there is no default lifetime; we must be
explicit.</li>
</ul>
<p>When we must be explicit, we can add a lifetime bound on a trait object like
<code>Box&lt;dyn Red&gt;</code> using the syntax <code>Box&lt;dyn Red + 'static&gt;</code> or <code>Box&lt;dyn Red + 'a&gt;</code>, depending on whether the reference lives for the entire program or not.
As with the other bounds, the syntax adding a lifetime bound means that any
implementor of the <code>Red</code> trait that has references inside the type must have
the same lifetime specified in the trait object bounds as those references.</p>
<a class="header" href="#the-anonymous-lifetime" id="the-anonymous-lifetime"><h3>The anonymous lifetime</h3></a>
<p>Let’s say that we have a struct that’s a wrapper around a string slice, like
this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StrWrap&lt;'a&gt;(&amp;'a str);
#}</code></pre></pre>
<p>We can write a function that returns one of these like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct StrWrap&lt;'a&gt;(&amp;'a str);
fn foo&lt;'a&gt;(string: &amp;'a str) -&gt; StrWrap&lt;'a&gt; {
    StrWrap(string)
}
#}</code></pre></pre>
<p>But that’s a lot of <code>'a</code>s! To cut down on some of this noise, we can use the
anonymous lifetime, <code>'_</code>, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct StrWrap&lt;'a&gt;(&amp;'a str);
fn foo(string: &amp;str) -&gt; StrWrap&lt;'_&gt; {
    StrWrap(string)
}
#}</code></pre></pre>
<p>The <code>'_</code> says “use the elidied lifetime here.” This means that we can still see
that <code>StrWrap</code> contains a reference, but we don’t need all of the lifetime
annotations to make sense of it.</p>
<p>It works in <code>impl</code> headers too; for example:</p>
<pre><code class="language-rust ignore">// verbose
impl&lt;'a&gt; fmt::Debug for StrWrap&lt;'a&gt; {

// elided
impl fmt::Debug for StrWrap&lt;'_&gt; {

</code></pre>
<p>Next, let’s look at some other advanced features that manage traits.</p>
<a class="header" href="#advanced-traits" id="advanced-traits"><h2>Advanced Traits</h2></a>
<p>We first covered traits in the “Traits: Defining Shared Behavior” section of
Chapter 10, but as with lifetimes, we didn’t discuss the more advanced details.
Now that you know more about Rust, we can get into the nitty-gritty.</p>
<a class="header" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types" id="specifying-placeholder-types-in-trait-definitions-with-associated-types"><h3>Specifying Placeholder Types in Trait Definitions with Associated Types</h3></a>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used in this type’s
place for the particular implementation. That way, we can define a trait that
uses some types without needing to know exactly what those types are until the
trait is implemented.</p>
<p>We’ve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they’re used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.</p>
<p>One example of a trait with an associated type is the <code>Iterator</code> trait that the
standard library provides. The associated type is named <code>Item</code> and stands in
for the type of the values the type implementing the <code>Iterator</code> trait is
iterating over. In “The <code>Iterator</code> Trait and the <code>next</code> Method” section of
Chapter 13, we mentioned that the definition of the <code>Iterator</code> trait is as
shown in Listing 19-20.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-20: The definition of the <code>Iterator</code> trait
that has an associated type <code>Item</code></span></p>
<p>The type <code>Item</code> is a placeholder type, and the <code>next</code> method’s definition shows
that it will return values of type <code>Option&lt;Self::Item&gt;</code>. Implementors of the
<code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code>
method will return an <code>Option</code> containing a value of that concrete type.</p>
<p>Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. So why use associated types?</p>
<p>Let’s examine the difference between the two concepts with an example from
Chapter 13 that implements the <code>Iterator</code> trait on the <code>Counter</code> struct. In
Listing 13-21, we specified that the <code>Item</code> type was <code>u32</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
</code></pre>
<p>This syntax seems comparable to that of generics. So why not just define the
<code>Iterator</code> trait with generics, as shown in Listing 19-21?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-21: A hypothetical definition of the
<code>Iterator</code> trait using generics</span></p>
<p>The difference is that when using generics, as in Listing 19-21, we must
annotate the types in each implementation; because we can also implement
<code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple
implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
<code>next</code> method on <code>Counter</code>, we would have to provide type annotations to
indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>With associated types, we don’t need to annotate types because we can’t
implement a trait on a type multiple times. In Listing 19-20 with the
definition that uses associated types, we can only choose what the type of
<code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code>.
We don’t have to specify that we want an iterator of <code>u32</code> values everywhere
that we call <code>next</code> on <code>Counter</code>.</p>
<a class="header" href="#default-generic-type-parameters-and-operator-overloading" id="default-generic-type-parameters-and-operator-overloading"><h3>Default Generic Type Parameters and Operator Overloading</h3></a>
<p>When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. The syntax for specifying a
default type for a generic type is <code>&lt;PlaceholderType=ConcreteType&gt;</code> when
declaring the generic type.</p>
<p>A great example of a situation where this technique is useful is with operator
overloading. <em>Operator overloading</em> is customizing the behavior of an operator
(such as <code>+</code>) in particular situations.</p>
<p>Rust doesn’t allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in <code>std::ops</code> by implementing the traits associated with the operator. For
example, in Listing 19-22 we overload the <code>+</code> operator to add two <code>Point</code>
instances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code>
struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p><span class="caption">Listing 19-22: Implementing the <code>Add</code> trait to overload
the <code>+</code> operator for <code>Point</code> instances</span></p>
<p>The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code>
values of two <code>Point</code> instances to create a new <code>Point</code>. The <code>Add</code> trait has an
associated type named <code>Output</code> that determines the type returned from the <code>add</code>
method.</p>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its
definition:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
#}</code></pre></pre>
<p>This code should look generally familiar: a trait with one method and an
associated type. The new part is <code>RHS=Self</code>: this syntax is called <em>default
type parameters</em>. The <code>RHS</code> generic type parameter (short for “right hand
side”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don’t
specify a concrete type for <code>RHS</code> when we implement the <code>Add</code> trait, the type
of <code>RHS</code> will default to <code>Self</code>, which will be the type we’re implementing
<code>Add</code> on.</p>
<p>When we implemented <code>Add</code> for <code>Point</code>, we used the default for <code>RHS</code> because we
wanted to add two <code>Point</code> instances. Let’s look at an example of implementing
the <code>Add</code> trait where we want to customize the <code>RHS</code> type rather than using the
default.</p>
<p>We have two structs, <code>Millimeters</code> and <code>Meters</code>, holding values in different
units. We want to add values in millimeters to values in meters and have the
implementation of <code>Add</code> do the conversion correctly. We can implement <code>Add</code> for
<code>Millimeters</code> with <code>Meters</code> as the <code>RHS</code>, as shown in Listing 19-23.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-23: Implementing the <code>Add</code> trait on
<code>Millimeters</code> to add <code>Millimeters</code> to <code>Meters</code></span></p>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to set the
value of the <code>RHS</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>You’ll use default type parameters in two main ways:</p>
<ul>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won’t need</li>
</ul>
<p>The standard library’s <code>Add</code> trait is an example of the second purpose:
usually, you’ll add two like types, but the <code>Add</code> trait provides the ability to
customize beyond that. Using a default type parameter in the <code>Add</code> trait
definition means you don’t have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn’t needed, making
it easier to use the trait.</p>
<p>The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.</p>
<a class="header" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name" id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"><h3>Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</h3></a>
<p>Nothing in Rust prevents a trait from having a method with the same name as
another trait’s method, nor does Rust prevent you from implementing both traits
on one type. It’s also possible to implement a method directly on the type with
the same name as methods from traits.</p>
<p>When calling methods with the same name, you’ll need to tell Rust which one you
want to use. Consider the code in Listing 19-24 where we’ve defined two traits,
<code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then implement
both traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented
on it. Each <code>fly</code> method does something different.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-24: Two traits are defined to have a <code>fly</code>
method and are implemented on the <code>Human</code> type, and a <code>fly</code> method is
implemented on <code>Human</code> directly</span></p>
<p>When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-25.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Pilot {
#     fn fly(&amp;self);
# }
#
# trait Wizard {
#     fn fly(&amp;self);
# }
#
# struct Human;
#
# impl Pilot for Human {
#     fn fly(&amp;self) {
#         println!(&quot;This is your captain speaking.&quot;);
#     }
# }
#
# impl Wizard for Human {
#     fn fly(&amp;self) {
#         println!(&quot;Up!&quot;);
#     }
# }
#
# impl Human {
#     fn fly(&amp;self) {
#         println!(&quot;*waving arms furiously*&quot;);
#     }
# }
#
fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listing 19-25: Calling <code>fly</code> on an instance of
<code>Human</code></span></p>
<p>Running this code will print <code>*waving arms furiously*</code>, showing that Rust
called the <code>fly</code> method implemented on <code>Human</code> directly.</p>
<p>To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait,
we need to use more explicit syntax to specify which <code>fly</code> method we mean.
Listing 19-26 demonstrates this syntax.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Pilot {
#     fn fly(&amp;self);
# }
#
# trait Wizard {
#     fn fly(&amp;self);
# }
#
# struct Human;
#
# impl Pilot for Human {
#     fn fly(&amp;self) {
#         println!(&quot;This is your captain speaking.&quot;);
#     }
# }
#
# impl Wizard for Human {
#     fn fly(&amp;self) {
#         println!(&quot;Up!&quot;);
#     }
# }
#
# impl Human {
#     fn fly(&amp;self) {
#         println!(&quot;*waving arms furiously*&quot;);
#     }
# }
#
fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listing 19-26: Specifying which trait’s <code>fly</code> method we
want to call</span></p>
<p>Specifying the trait name before the method name clarifies to Rust which
implementation of <code>fly</code> we want to call. We could also write
<code>Human::fly(&amp;person)</code>, which is equivalent to the <code>person.fly()</code> that we used
in Listing 19-26, but this is a bit longer to write if we don’t need to
disambiguate.</p>
<p>Running this code prints the following:</p>
<pre><code class="language-text">This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that
both implement one <em>trait</em>, Rust could figure out which implementation of a
trait to use based on the type of <code>self</code>.</p>
<p>However, associated functions that are part of traits don’t have a <code>self</code>
parameter. When two types in the same scope implement that trait, Rust can’t
figure out which type you mean unless you use <em>fully qualified syntax</em>. For
example, the <code>Animal</code> trait in Listing 19-27 has the associated function
<code>baby_name</code>, the implementation of <code>Animal</code> for the struct <code>Dog</code>, and the
associated function <code>baby_name</code> defined on <code>Dog</code> directly.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listing 19-27: A trait with an associated function and a
type with an associated function of the same name that also implements the
trait</span></p>
<p>This code is for an animal shelter that wants to name all puppies Spot, which
is implemented in the <code>baby_name</code> associated function that is defined on <code>Dog</code>.
The <code>Dog</code> type also implements the trait <code>Animal</code>, which describes
characteristics that all animals have. Baby dogs are called puppies, and that
is expressed in the implementation of the <code>Animal</code> trait on <code>Dog</code> in the
<code>baby_name</code> function associated with the <code>Animal</code> trait.</p>
<p>In <code>main</code>, we call the <code>Dog::baby_name</code> function, which calls the associated
function defined on <code>Dog</code> directly. This code prints the following:</p>
<pre><code class="language-text">A baby dog is called a Spot
</code></pre>
<p>This output isn’t what we wanted. We want to call the <code>baby_name</code> function that
is part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints
<code>A baby dog is called a puppy</code>. The technique of specifying the trait name that
we used in Listing 19-26 doesn’t help here; if we change <code>main</code> to the code in
Listing 19-28, we’ll get a compilation error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">Listing 19-28: Attempting to call the <code>baby_name</code>
function from the <code>Animal</code> trait, but Rust doesn’t know which implementation to
use</span></p>
<p>Because <code>Animal::baby_name</code> is an associated function rather than a method, and
thus doesn’t have a <code>self</code> parameter, Rust can’t figure out which
implementation of <code>Animal::baby_name</code> we want. We’ll get this compiler error:</p>
<pre><code class="language-text">error[E0283]: type annotations required: cannot resolve `_: Animal`
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by `Animal::baby_name`
</code></pre>
<p>To disambiguate and tell Rust that we want to use the implementation of
<code>Animal</code> for <code>Dog</code>, we need to use fully qualified syntax. Listing 19-29
demonstrates how to use fully qualified syntax.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Animal {
#     fn baby_name() -&gt; String;
# }
#
# struct Dog;
#
# impl Dog {
#     fn baby_name() -&gt; String {
#         String::from(&quot;Spot&quot;)
#     }
# }
#
# impl Animal for Dog {
#     fn baby_name() -&gt; String {
#         String::from(&quot;puppy&quot;)
#     }
# }
#
fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listing 19-29: Using fully qualified syntax to specify
that we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as
implemented on <code>Dog</code></span></p>
<p>We’re providing Rust with a type annotation within the angle brackets, which
indicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as
implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an
<code>Animal</code> for this function call. This code will now print what we want:</p>
<pre><code class="language-text">A baby dog is called a puppy
</code></pre>
<p>In general, fully qualified syntax is defined as follows:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>For associated functions, there would not be a <code>receiver</code>: there would only be
the list of other arguments. You could use fully qualified syntax everywhere
that you call functions or methods. However, you’re allowed to omit any part of
this syntax that Rust can figure out from other information in the program. You
only need to use this more verbose syntax in cases where there are multiple
implementations that use the same name and Rust needs help to identify which
implementation you want to call.</p>
<a class="header" href="#using-supertraits-to-require-one-traits-functionality-within-another-trait" id="using-supertraits-to-require-one-traits-functionality-within-another-trait"><h3>Using Supertraits to Require One Trait’s Functionality Within Another Trait</h3></a>
<p>Sometimes, you might need one trait to use another trait’s functionality. In
this case, you need to rely on the dependent traits also being implemented.
The trait you rely on is a <em>supertrait</em> of the trait you’re implementing.</p>
<p>For example, let’s say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print a value framed in asterisks. That is,
given a <code>Point</code> struct that implements <code>Display</code> to result in <code>(x, y)</code>, when we
call <code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for
<code>y</code>, it should print the following:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of <code>outline_print</code>, we want to use the <code>Display</code> trait’s
functionality. Therefore, we need to specify that the <code>OutlinePrint</code> trait will
work only for types that also implement <code>Display</code> and provide the functionality
that <code>OutlinePrint</code> needs. We can do that in the trait definition by specifying
<code>OutlinePrint: Display</code>. This technique is similar to adding a trait bound to
the trait. Listing 19-30 shows an implementation of the <code>OutlinePrint</code> trait.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-30: Implementing the <code>OutlinePrint</code> trait that
requires the functionality from <code>Display</code></span></p>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use the <code>to_string</code> function that is automatically implemented for any type
that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a
colon and specifying the <code>Display</code> trait after the trait name, we’d get an
error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in
the current scope.</p>
<p>Let’s see what happens when we try to implement <code>OutlinePrint</code> on a type that
doesn’t implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait OutlinePrint {}
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
#}</code></pre></pre>
<p>We get an error saying that <code>Display</code> is required but not implemented:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
</code></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
#}</code></pre></pre>
<p>Then implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile
successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display
it within an outline of asterisks.</p>
<a class="header" href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types" id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"><h3>Using the Newtype Pattern to Implement External Traits on External Types</h3></a>
<p>In Chapter 10 in the “Implementing a Trait on a Type” section, we mentioned the
orphan rule that states we’re allowed to implement a trait on a type as long as
either the trait or the type are local to our crate. It’s possible to get
around this restriction using the <em>newtype pattern</em>, which involves creating a
new type in a tuple struct. (We covered tuple structs in the “Using Tuple
Structs without Named Fields to Create Different Types” section of Chapter 5.)
The tuple struct will have one field and be a thin wrapper around the type we
want to implement a trait for. Then the wrapper type is local to our crate, and
we can implement the trait on the wrapper. <em>Newtype</em> is a term that originates
from the Haskell programming language. There is no runtime performance penalty
for using this pattern, and the wrapper type is elided at compile time.</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the
orphan rule prevents us from doing directly because the <code>Display</code> trait and the
<code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct
that holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on
<code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 19-31.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">Listing 19-31: Creating a <code>Wrapper</code> type around
<code>Vec&lt;String&gt;</code> to implement <code>Display</code></span></p>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>,
because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the
tuple. Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it
doesn’t have the methods of the value it’s holding. We would have to implement
all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods
delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a
<code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,
implementing the <code>Deref</code> trait (discussed in Chapter 15 in the “Treating Smart
Pointers like Regular References with the <code>Deref</code> Trait” section) on the
<code>Wrapper</code> to return the inner type would be a solution. If we don’t want the
<code>Wrapper</code> type to have all the methods of the inner type—for example, to
restrict the <code>Wrapper</code> type’s behavior—we would have to implement just the
methods we do want manually.</p>
<p>Now you know how the newtype pattern is used in relation to traits; it’s also a
useful pattern even when traits are not involved. Let’s switch focus and look
at some advanced ways to interact with Rust’s type system.</p>
<a class="header" href="#advanced-types" id="advanced-types"><h2>Advanced Types</h2></a>
<p>The Rust type system has some features that we’ve mentioned in this book but
haven’t yet discussed. We’ll start by discussing newtypes in general as we
examine why newtypes are useful as types. Then we’ll move on to type aliases, a
feature similar to newtypes but with slightly different semantics. We’ll also
discuss the <code>!</code> type and dynamically sized types.</p>
<blockquote>
<p>Note: The next section assumes you’ve read the earlier section “The Newtype
Pattern to Implement External Traits on External Types.”</p>
</blockquote>
<a class="header" href="#using-the-newtype-pattern-for-type-safety-and-abstraction" id="using-the-newtype-pattern-for-type-safety-and-abstraction"><h3>Using the Newtype Pattern for Type Safety and Abstraction</h3></a>
<p>The newtype pattern is useful for tasks beyond those we’ve discussed so far,
including statically enforcing that values are never confused and indicating
the units of a value. You saw an example of using newtypes to indicate units in
Listing 19-23: recall that the <code>Millimeters</code> and <code>Meters</code> structs wrapped <code>u32</code>
values in a newtype. If we wrote a function with a parameter of type
<code>Millimeters</code>, we couldn’t compile a program that accidentally tried to call
that function with a value of type <code>Meters</code> or a plain <code>u32</code>.</p>
<p>Another use of the newtype pattern is in abstracting away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type if we used the new type directly to restrict
the available functionality, for example.</p>
<p>Newtypes can also hide internal implementation. For example, we could provide a
<code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person’s ID
associated with their name. Code using <code>People</code> would only interact with the
public API we provide, such as a method to add a name string to the <code>People</code>
collection; that code wouldn’t need to know that we assign an <code>i32</code> ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the “Encapsulation that
Hides Implementation Details” section of Chapter 17.</p>
<a class="header" href="#creating-type-synonyms-with-type-aliases" id="creating-type-synonyms-with-type-aliases"><h3>Creating Type Synonyms with Type Aliases</h3></a>
<p>Along with the newtype pattern, Rust provides the ability to declare a <em>type
alias</em> to give an existing type another name. For this we use the <code>type</code>
keyword. For example, we can create the alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;
#}</code></pre></pre>
<p>Now, the alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code>
and <code>Meters</code> types we created in Listing 19-23, <code>Kilometers</code> is not a separate,
new type. Values that have the type <code>Kilometers</code> will be treated the same as
values of type <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
#}</code></pre></pre>
<p>Because <code>Kilometers</code> and <code>i32</code> are the same type, we can add values of both
types and we can pass <code>Kilometers</code> values to functions that take <code>i32</code>
parameters. However, using this method, we don’t get the type checking benefits
that we get from the newtype pattern discussed earlier.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-32.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
    // --snip--
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-32: Using a long type in many places</span></p>
<p>A type alias makes this code more manageable by reducing the repetition. In
Listing 19-33, we’ve introduced an alias named <code>Thunk</code> for the verbose type and
can replace all uses of the type with the shorter alias <code>Thunk</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-33: Introducing a type alias <code>Thunk</code> to reduce
repetition</span></p>
<p>This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (<em>thunk</em> is a word for code
to be evaluated at a later time, so it’s an appropriate name for a closure that
gets stored).</p>
<p>Type aliases are also commonly used with the <code>Result&lt;T, E&gt;</code> type for reducing
repetition. Consider the <code>std::io</code> module in the standard library. I/O
operations often return a <code>Result&lt;T, E&gt;</code> to handle situations when operations
fail to work. This library has a <code>std::io::Error</code> struct that represents all
possible I/O errors. Many of the functions in <code>std::io</code> will be returning
<code>Result&lt;T, E&gt;</code> where the <code>E</code> is <code>std::io::Error</code>, such as these functions in
the <code>Write</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
#}</code></pre></pre>
<p>The <code>Result&lt;..., Error&gt;</code> is repeated a lot. As such, <code>std::io</code> has this type of
alias declaration:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<p>Because this declaration is in the <code>std::io</code> module, we can use the fully
qualified alias <code>std::io::Result&lt;T&gt;</code>—that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code>
filled in as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up
looking like this:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>The type alias helps in two ways: it makes code easier to write <em>and</em> it gives
us a consistent interface across all of <code>std::io</code>. Because it’s an alias, it’s
just another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on
<code>Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<a class="header" href="#the-never-type-that-never-returns" id="the-never-type-that-never-returns"><h3>The Never Type that Never Returns</h3></a>
<p>Rust has a special type named <code>!</code> that’s known in type theory lingo as the
<em>empty type</em> because it has no values. We prefer to call it the <em>never type</em>
because it stands in the place of the return type when a function will never
return. Here is an example:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // --snip--
}
</code></pre>
<p>This code is read as “the function <code>bar</code> returns never.” Functions that return
never are called <em>diverging functions</em>. We can’t create values of the type <code>!</code>
so <code>bar</code> can never possibly return.</p>
<p>But what use is a type you can never create values for? Recall the code from
Listing 2-5; we’ve reproduced part of it here in Listing 19-34.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let guess = &quot;3&quot;;
# loop {
let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
# break;
# }
#}</code></pre></pre>
<p><span class="caption">Listing 19-34: A <code>match</code> with an arm that ends in
<code>continue</code></span></p>
<p>At the time, we skipped over some details in this code. In Chapter 6 in “The
<code>match</code> Control Flow Operator” section, we discussed that <code>match</code> arms must all
return the same type. So, for example, the following code doesn’t work:</p>
<pre><code class="language-rust ignore does_not_compile">let guess = match guess.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>The type of <code>guess</code> in this code would have to be an integer <em>and</em> a string,
and Rust requires that <code>guess</code> have only one type. So what does <code>continue</code>
return? How were we allowed to return a <code>u32</code> from one arm and have another arm
that ends with <code>continue</code> in Listing 19-34?</p>
<p>As you might have guessed, <code>continue</code> has a <code>!</code> value. That is, when Rust
computes the type of <code>guess</code>, it looks at both match arms, the former with a
value of <code>u32</code> and the latter with a <code>!</code> value. Because <code>!</code> can never have a
value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>The formal way of describing this behavior is that expressions of type <code>!</code> can
be coerced into any other type. We’re allowed to end this <code>match</code> arm with
<code>continue</code> because <code>continue</code> doesn’t return a value; instead, it moves control
back to the top of the loop, so in the <code>Err</code> case, we never assign a value to
<code>guess</code>.</p>
<p>The never type is useful with the <code>panic!</code> macro as well. Remember the <code>unwrap</code>
function that we call on <code>Option&lt;T&gt;</code> values to produce a value or panic? Here
is its definition:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>In this code, the same thing happens as in the <code>match</code> in Listing 19-34: Rust
sees that <code>val</code> has the type <code>T</code> and <code>panic!</code> has the type <code>!</code>, so the result
of the overall <code>match</code> expression is <code>T</code>. This code works because <code>panic!</code>
doesn’t produce a value; it ends the program. In the <code>None</code> case, we won’t be
returning a value from <code>unwrap</code>, so this code is valid.</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<p>Here, the loop never ends, so <code>!</code> is the value of the expression. However, this
wouldn’t be true if we included a <code>break</code>, because the loop would terminate
when it got to the <code>break</code>.</p>
<a class="header" href="#dynamically-sized-types-and-the-sized-trait" id="dynamically-sized-types-and-the-sized-trait"><h3>Dynamically Sized Types and the <code>Sized</code> Trait</h3></a>
<p>Due to Rust’s need to know certain details, such as how much space to allocate
for a value of a particular type, there is a corner of its type system that can
be confusing: the concept of <em>dynamically sized types</em>. Sometimes referred to
as <em>DSTs</em> or <em>unsized types</em>, these types let us write code using values whose
size we can know only at runtime.</p>
<p>Let’s dig into the details of a dynamically sized type called <code>str</code>, which
we’ve been using throughout the book. That’s right, not <code>&amp;str</code>, but <code>str</code> on
its own, is a DST. We can’t know how long the string is until runtime, meaning
we can’t create a variable of type <code>str</code>, nor can we take an argument of type
<code>str</code>. Consider the following code, which does not work:</p>
<pre><code class="language-rust ignore does_not_compile">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<p>Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two <code>str</code> values would need to take up the
same amount of space. But they have different lengths: <code>s1</code> needs 12 bytes of
storage and <code>s2</code> needs 15. This is why it’s not possible to create a variable
holding a dynamically sized type.</p>
<p>So what do we do? In this case, you already know the answer: we make the types
of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code>. Recall that in the “String
Slices” section of Chapter 4, we said the slice data structure stores the
starting position and the length of the slice.</p>
<p>So although a <code>&amp;T</code> is a single value that stores the memory address of where
the <code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its
length. As such, we can know the size of a <code>&amp;str</code> value at compile time: it’s
twice the length of a <code>usize</code>. That is, we always know the size of a <code>&amp;str</code>, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.</p>
<p>We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or
<code>Rc&lt;str&gt;</code>. In fact, you’ve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the “Using Trait Objects that
Allow for Values of Different Types” section, we mentioned that to use traits
as trait objects, we must put them behind a pointer, such as <code>&amp;dyn Trait</code> or
<code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> would work too).</p>
<p>To work with DSTs, Rust has a particular trait called the <code>Sized</code> trait to
determine whether or not a type’s size is known at compile time. This trait is
automatically implemented for everything whose size is known at compile time.
In addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function.
That is, a generic function definition like this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>is actually treated as though we had written this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p>A trait bound on <code>?Sized</code> is the opposite of a trait bound on <code>Sized</code>: we would
read this as “<code>T</code> may or may not be <code>Sized</code>.” This syntax is only available for
<code>Sized</code>, not any other traits.</p>
<p>Also note that we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>.
Because the type might not be <code>Sized</code>, we need to use it behind some kind of
pointer. In this case, we’ve chosen a reference.</p>
<p>Next, we’ll talk about functions and closures!</p>
<a class="header" href="#advanced-functions-and-closures" id="advanced-functions-and-closures"><h2>Advanced Functions and Closures</h2></a>
<p>Finally, we’ll explore some advanced features related to functions and
closures, which include function pointers and returning closures.</p>
<a class="header" href="#function-pointers" id="function-pointers"><h3>Function Pointers</h3></a>
<p>We’ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you’ve already defined rather than defining a new closure. Doing this
with function pointers will allow you to use functions as arguments to other
functions. Functions coerce to the type <code>fn</code> (with a lowercase f), not to be
confused with the <code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function
pointer</em>. The syntax for specifying that a parameter is a function pointer is
similar to that of closures, as shown in Listing 19-35.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">Listing 19-35: Using the <code>fn</code> type to accept a function
pointer as an argument</span></p>
<p>This code prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in
<code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an
<code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass
the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the
parameter type directly rather than declaring a generic type parameter with one
of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>), so you can always pass a function pointer as an argument for a
function that expects a closure. It’s best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.</p>
<p>An example of where you would want to only accept <code>fn</code> and not closures is when
interfacing with external code that doesn’t have closures: C functions can
accept functions as arguments, but C doesn’t have closures.</p>
<p>As an example of where you could use either a closure defined inline or a named
function, let’s look at a use of <code>map</code>. To use the <code>map</code> function to turn a
vector of numbers into a vector of strings, we could use a closure, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
#}</code></pre></pre>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure,
like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
#}</code></pre></pre>
<p>Note that we must use the fully qualified syntax that we talked about earlier
in the “Advanced Traits” section because there are multiple functions available
named <code>to_string</code>. Here, we’re using the <code>to_string</code> function defined in the
<code>ToString</code> trait, which the standard library has implemented for any type that
implements <code>Display</code>.</p>
<p>Another useful pattern exploits an implementation detail of tuple structs and
tuple-struct enum variants. These items use <code>()</code> as initialiser syntax, which
looks like a function call, and they’re actually implemented as functions
returning an instance constructed from their arguments. They can also be called
as a function pointer implementing the closure traits, and so can be used
similarly to the above:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Status {
    Value(u32),
    Stop,
}

let list_of_statuses: Vec&lt;Status&gt; =
    (0u32..20)
    .map(Status::Value)
    .collect();
#}</code></pre></pre>
<p>Some people prefer this style, and some people prefer to use closures. They end
up compiling to the same code, so use whichever style is clearer to you.</p>
<a class="header" href="#returning-closures" id="returning-closures"><h3>Returning Closures</h3></a>
<p>Closures are represented by traits, which means you can’t return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. But you can’t do that with closures because they don’t have a
concrete type that is returnable; you’re not allowed to use the function
pointer <code>fn</code> as a return type, for example.</p>
<p>The following code tries to return a closure directly, but it won’t compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>The compiler error is as follows:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + 'static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -&gt; i32 + 'static`
  = note: the return type of a function must have a statically known size
</code></pre>
<p>The error references the <code>Sized</code> trait again! Rust doesn’t know how much space
it will need to store the closure. We saw a solution to this problem earlier.
We can use a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
#}</code></pre></pre>
<p>This code will compile just fine. For more about trait objects, refer to the
“Using Trait Objects That Allow for Values of Different Types” section in
Chapter 17.</p>
<p>Next, let’s look at macros!</p>
<a class="header" href="#macros" id="macros"><h2>Macros</h2></a>
<p>We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully
explored what a macro is and how it works. <em>Macros</em> refers to a family of
features in Rust:</p>
<ul>
<li><em>Declarative</em> macros with <code>macro_rules!</code></li>
<li><em>Procedural</em> macros, which come in three kinds:
<ul>
<li>Custom <code>#[derive]</code> macros</li>
<li>Attribute-like macros</li>
<li>Function-like macros</li>
</ul>
</li>
</ul>
<p>We’ll talk about each of these in turn, but first, why do we even need macros
when we already have functions?</p>
<a class="header" href="#the-difference-between-macros-and-functions" id="the-difference-between-macros-and-functions"><h3>The Difference Between Macros and Functions</h3></a>
<p>Fundamentally, macros are a way of writing code that writes other code, which
is known as <em>metaprogramming</em>. In Appendix C, we discuss the <code>derive</code>
attribute, which generates an implementation of various traits for you. We’ve
also used the <code>println!</code> and <code>vec!</code> macros throughout the book. All of these
macros <em>expand</em> to produce more code than the code you’ve written manually.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don’t have.</p>
<p>A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call <code>println!(&quot;hello&quot;)</code> with one argument or
<code>println!(&quot;hello {}&quot;, name)</code> with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can’t, because it gets
called at runtime and a trait needs to be implemented at compile time.</p>
<p>The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.</p>
<p>There is one last important difference between macros and functions: you must
define or bring macros into scope <em>before</em> you call them in a file, whereas you
can define functions anywhere and call them anywhere.</p>
<a class="header" href="#declarative-macros-with-macro_rules-for-general-metaprogramming" id="declarative-macros-with-macro_rules-for-general-metaprogramming"><h3>Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</h3></a>
<p>The most widely used form of macros in Rust are <em>declarative macros</em>. These are
also sometimes referred to as “macros by example”, “<code>macro_rules!</code> macros”, or
just plain “macros”. At their core, declarative macros allow you to write
something similar to a Rust <code>match</code> expression. As discussed in Chapter 6,
<code>match</code> expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that have
code associated with them; in this situation, the value is the literal Rust
source code passed to the macro, the patterns are compared with the structure
of that source code, and the code associated with each pattern is the code that
replaces the code passed to the macro. This all happens during compilation.</p>
<p>To define a macro, you use the <code>macro_rules!</code> construct. Let’s explore how to
use <code>macro_rules!</code> by looking at how the <code>vec!</code> macro is defined. Chapter 8
covered how we can use the <code>vec!</code> macro to create a new vector with particular
values. For example, the following macro creates a new vector with three
integers inside:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;u32&gt; = vec![1, 2, 3];
#}</code></pre></pre>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector
of five string slices. We wouldn’t be able to use a function to do the same
because we wouldn’t know the number or type of values up front.</p>
<p>Let’s look at a slightly simplified definition of the <code>vec!</code> macro in Listing
19-36.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-36: A simplified version of the <code>vec!</code> macro
definition</span></p>
<blockquote>
<p>Note: The actual definition of the <code>vec!</code> macro in the standard library
includes code to preallocate the correct amount of memory up front. That code
is an optimization that we don’t include here to make the example simpler.</p>
</blockquote>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made
available whenever the crate in which we’re defining the macro is brought into
scope. Without this annotation, the macro can’t be brought into scope.</p>
<p>We then start the macro definition with <code>macro_rules!</code> and the name of the
macro we’re defining <em>without</em> the exclamation mark. The name, in this case
<code>vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>
<p>The structure in the <code>vec!</code> body is similar to the structure of a <code>match</code>
expression. Here we have one arm with the pattern <code>( $( $x:expr ),* )</code>,
followed by <code>=&gt;</code> and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other will be an error. More complex macros will have more than one arm.</p>
<p>Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Let’s walk through what the pieces of the pattern
in Listing D-1 mean; for the full macro pattern syntax, see <a href="../reference/macros.html">the reference</a>.</p>
<p>First, a set of parentheses encompasses the whole pattern. Next comes a dollar
sign (<code>$</code>) followed by a set of parentheses, which captures values that match
the pattern within the parentheses for use in the replacement code. Within
<code>$()</code> is <code>$x:expr</code>, which matches any Rust expression and gives the expression
the name <code>$x</code>.</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character
could optionally appear after the code that matches the code captured in <code>$()</code>.
The <code>*</code> following the comma specifies that the pattern matches zero or more of
whatever precedes the <code>*</code>.</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three
times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>Now let’s look at the pattern in the body of the code associated with this arm:
the <code>temp_vec.push()</code> code within the <code>$()*</code> part is generated for each part
that matches <code>$()</code> in the pattern, zero or more times depending on how many
times the pattern matches. The <code>$x</code> is replaced with each expression matched.
When we call this macro with <code>vec![1, 2, 3];</code>, the code generated that replaces
this macro call will be the following:</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<p>We’ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.</p>
<p>There are some strange corners with <code>macro_rules!</code>. In the future, there
will be a second kind of declarative macro with the <code>macro</code> keyword that
will work in a similar fashion but fix some of these edge cases. After that
is done, <code>macro_rules!</code> will be effectively deprecated. With this
in mind, as well as the fact that most Rust programmers will <em>use</em> macros
more than <em>write</em> macros, we won’t discuss <code>macro_rules!</code> any further. To
learn more about how to write macros, consult the online documentation or
other resources, such as <a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros”</a>.</p>
<a class="header" href="#procedural-macros-for-generating-code-from-attributes" id="procedural-macros-for-generating-code-from-attributes"><h3>Procedural Macros for Generating Code from Attributes</h3></a>
<p>The second form of macros is called <em>procedural macros</em> because they’re more
like functions (which are a type of procedure). Procedural macros accept some
Rust code as an input, operate on that code, and produce some Rust code as an
output rather than matching against patterns and replacing the code with other
code as declarative macros do.</p>
<p>There are three kinds of procedural macros, but they all work in a similar
fashion. First, the definitions must reside in their own crate with a special
crate type. This is for complex technical reasons that we hope to eliminate in
the future.</p>
<p>Second, using any of these kinds of macros takes on a form like the code shown
in Listing 19-37, where <code>some_attribute</code> is a placeholder for using a specific
macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<p><span class="caption">Listing 19-37: An example of using a procedural
macro</span></p>
<p>Procedural macros consist of a function, which is how they get their name:
“procedure” is a synonym for “function.” Why not call them “functional macros”?
Well, one of the types is “function-like,” and that would get confusing.
Anyway, the function defining a procedural macro takes a <code>TokenStream</code> as an
input and produces a <code>TokenStream</code> as an output. This is the core of the macro:
the source code that the macro is operating on makes up the input
<code>TokenStream</code>, and the code the macro produces is the output <code>TokenStream</code>.
Finally, the function has an attribute on it; this attribute says which kind of
procedural macro we’re creating. We can have multiple kinds of procedural
macros in the same crate.</p>
<p>Given that the kinds of macros are so similar, we’ll start with a custom derive
macro. Then we’ll explain the small differences that make the other forms
different.</p>
<a class="header" href="#how-to-write-a-custom-derive-macro" id="how-to-write-a-custom-derive-macro"><h3>How to Write a Custom <code>derive</code> Macro</h3></a>
<p>Let’s create a crate named <code>hello_macro</code> that defines a trait named
<code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than
making our crate users implement the <code>HelloMacro</code> trait for each of their
types, we’ll provide a procedural macro so users can annotate their type with
<code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code>
function. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has
been defined. In other words, we’ll write a crate that enables another
programmer to write code like Listing 19-38 using our crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">Listing 19-38: The code a user of our crate will be able
to write when using our procedural macro</span></p>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we’re done. The
first step is to make a new library crate, like this:</p>
<pre><code class="language-text">$ cargo new hello_macro --lib
</code></pre>
<p>Next, we’ll define the <code>HelloMacro</code> trait and its associated function:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait HelloMacro {
    fn hello_macro();
}
#}</code></pre></pre>
<p>We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>However, they would need to write the implementation block for each type they
wanted to use with <code>hello_macro</code>; we want to spare them from having to do this
work.</p>
<p>Additionally, we can’t yet provide a default implementation for the
<code>hello_macro</code> function that will print the name of the type the trait is
implemented on: Rust doesn’t have reflection capabilities, so it can’t look up
the type’s name at runtime. We need a macro to generate code at compile time.</p>
<p>The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named <code>foo</code>, a custom derive procedural macro crate is
called <code>foo_derive</code>. Let’s start a new crate called <code>hello_macro_derive</code> inside
our <code>hello_macro</code> project:</p>
<pre><code class="language-text">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Our two crates are tightly related, so we create the procedural macro crate
within the directory of our <code>hello_macro</code> crate. If we change the trait
definition in <code>hello_macro</code>, we’ll have to change the implementation of the
procedural macro in <code>hello_macro_derive</code> as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
<code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and reexport the
procedural macro code. But the way we’ve structured the project makes it
possible for programmers to use <code>hello_macro</code> even if they don’t want the
<code>derive</code> functionality.</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate.
We’ll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you’ll see
in a moment, so we need to add them as dependencies. Add the following to the
<em>Cargo.toml</em> file for <code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.14.4&quot;
quote = &quot;0.6.3&quot;
</code></pre>
<p>To start defining the procedural macro, place the code in Listing 19-39 into
your <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code
won’t compile until we add a definition for the <code>impl_hello_macro</code> function.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<!--
This usage of `extern crate` is required for the moment with the 1.31 code
that's currently rustc 1.31.0-beta.4 (04da282bb 2018-11-01), see:
<ul>
<li>https://github.com/rust-lang/rust/issues/54418</li>
<li>https://github.com/rust-lang/rust/pull/54658</li>
<li>https://github.com/rust-lang/rust/issues/55599
--&gt;</li>
</ul>
<pre><code class="language-rust ignore">extern crate proc_macro;

use crate::proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}
</code></pre>
<p><span class="caption">Listing 19-39: Code that most procedural macro crates
will need to have for processing Rust code</span></p>
<p>Notice the way we’ve split the functions in Listing 19-39; this will be the
same for almost every procedural macro crate you see or create, because it
makes writing a procedural macro more convenient. What you choose to do in the
place where the <code>impl_hello_macro</code> function is called will be different
depending on your procedural macro’s purpose.</p>
<p>We’ve introduced three new crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, and <a href="https://crates.io/crates/quote"><code>quote</code></a>. The
<code>proc_macro</code> crate comes with Rust, so we didn’t need to add that to the
dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler’s API to
be able to read and manipulate Rust code from our code. The <code>syn</code> crate
parses Rust code from a string into a data structure that we can perform
operations on. The <code>quote</code> crate takes <code>syn</code> data structures and turns them
back into Rust code. These crates make it much simpler to parse any sort of
Rust code we might want to handle: writing a full parser for Rust code is no
simple task.</p>
<p>The <code>hello_macro_derive</code> function will get called when a user of our library
specifies <code>#[derive(HelloMacro)]</code> on a type. The reason is that we’ve annotated
the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and specified
the name, <code>HelloMacro</code>, which matches our trait name; that’s the convention
most procedural macros follow.</p>
<p>This function first converts the <code>input</code> from a <code>TokenStream</code> to a data
structure that we can then interpret and perform operations on. This is where
<code>syn</code> comes into play. The <code>parse</code> function in <code>syn</code> takes a <code>TokenStream</code> and
returns a <code>DeriveInput</code> struct representing the parsed Rust code. Listing 19-40
shows the relevant parts of the <code>DeriveInput</code> struct we get from parsing the
string <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<p><span class="caption">Listing 19-40: The <code>DeriveInput</code> instance we get when
parsing the code that has the macro’s attribute in Listing 19-38</span></p>
<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct
with the <code>ident</code> (identifier, meaning the name) of <code>Pancakes</code>. There are more
fields on this struct for describing all sorts of Rust code; check the <a href="https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html"><code>syn</code>
documentation for <code>DeriveInput</code></a> for more information.</p>
<p>At this point, we haven’t defined the <code>impl_hello_macro</code> function, which is
where we’ll build the new Rust code we want to include. But before we do, note
that its output is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is added to
the code that our crate users write, so when they compile their crate, they’ll
get extra functionality that we provide.</p>
<p>You might have noticed that we’re calling <code>unwrap</code> to panic if the call to the
<code>syn::parse</code> function fails here. Panicking on errors is necessary in
procedural macro code because <code>proc_macro_derive</code> functions must return
<code>TokenStream</code> rather than <code>Result</code> to conform to the procedural macro API.
We’ve chosen to simplify this example by using <code>unwrap</code>; in production code,
you should provide more specific error messages about what went wrong by using
<code>panic!</code> or <code>expect</code>.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code>
into a <code>DeriveInput</code> instance, let’s generate the code that implements the
<code>HelloMacro</code> trait on the annotated type as shown in Listing 19-41.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre>
<p><span class="caption">Listing 19-41: Implementing the <code>HelloMacro</code> trait using
the parsed Rust code</span></p>
<p>We get an <code>Ident</code> struct instance containing the name (identifier) of the
annotated type using <code>ast.ident</code>. The struct in Listing 19-40 shows that the
<code>ident</code> we get when the <code>impl_hello_macro</code> function is run on the code in
Listing 19-38 will have the <code>ident</code> field with a value of <code>&quot;Pancakes&quot;</code>. Thus,
the <code>name</code> variable in Listing 19-41 will contain an <code>Ident</code> struct instance
that, when printed, will be the string <code>&quot;Pancakes&quot;</code>, the name of the struct in
Listing 19-38.</p>
<p>The <code>quote!</code> macro lets us write the Rust code that we want to return. The
direct result of the <code>quote!</code> macro’s execution isn’t what’s expected by the
compiler and needs to be converted to a <code>TokenStream</code>. We do this by calling
the <code>into</code> method, which consumes this intermediate representation and returns
a value of the required <code>TokenStream</code> type.</p>
<p>The <code>quote!</code> macro also provides some very cool templating mechanics; we can
write <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable
named <code>name</code>. You can even do some repetition similar to the way regular macros
work. Check out <a href="https://docs.rs/quote">the <code>quote</code> crate’s docs</a> for a thorough
introduction.</p>
<p>We want our procedural macro to generate an implementation of our <code>HelloMacro</code>
trait for the type the user annotated, which we can get by using <code>#name</code>. The
trait implementation has one function, <code>hello_macro</code>, whose body contains the
functionality we want to provide: printing <code>Hello, Macro! My name is</code> and then
the name of the annotated type.</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust
expression, such as <code>1 + 2</code>, and at compile time turns the expression into a
string literal, such as <code>&quot;1 + 2&quot;</code>. This is different than <code>format!</code> or
<code>println!</code>, which evaluate the expression and then turn the result into a
<code>String</code>. There is a possibility that the <code>#name</code> input might be an expression
to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also saves an
allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code>
and <code>hello_macro_derive</code>. Let’s hook up these crates to the code in Listing
19-38 to see the procedural macro in action! Create a new binary project in
your <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add
<code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code>
crate’s <em>Cargo.toml</em>. If you’re publishing your versions of <code>hello_macro</code> and
<code>hello_macro_derive</code> to <em>https://crates.io/</em>, they would be regular
dependencies; if not, you can specify them as <code>path</code> dependencies as follows:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Put the code from Listing 19-38 into <em>src/main.rs</em>, and run <code>cargo run</code>: it
should print <code>Hello, Macro! My name is Pancakes!</code> The implementation of the
<code>HelloMacro</code> trait from the procedural macro was included without the
<code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the
trait implementation.</p>
<p>Next, let’s explore how the other kinds of procedural macros differ from custom
derive macros.</p>
<a class="header" href="#attribute-like-macros" id="attribute-like-macros"><h3>Attribute-like macros</h3></a>
<p>Attribute-like macros are similar to custom derive macros, but instead of
generating code for the <code>derive</code> attribute, they allow you to create new
attributes. They’re also more flexible; <code>derive</code> only works for structs and
enums; attributes can go on other items as well, like functions. As an example
of using an attribute-like macro, you might have an attribute named <code>route</code>
that annotates functions when using a web application framework:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<p>This <code>#[route]</code> attribute would be defined by the framework itself as a
procedural macro. The macro definition function’s signature would look like
this:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Here, we have two parameters of type <code>TokenStream</code>; the first is for the
contents of the attribute itself, that is, the <code>GET, &quot;/&quot;</code> part. The second is
the body of the item the attribute is attached to, in this case, <code>fn index() {}</code> and the rest of the function’s body.</p>
<p>Other than that, attribute-like macros work the same way as custom derive
macros: create a crate with the <code>proc-macro</code> crate type and implement a
function that generates the code you want!</p>
<a class="header" href="#function-like-macros" id="function-like-macros"><h3>Function-like macros</h3></a>
<p>Finally, function-like macros define macros that look like function calls. For
example, an <code>sql!</code> macro that might be called like so:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<p>This macro would parse the SQL statement inside of it and check that it’s
syntactically correct. This macro would be defined like this:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>This is similar to the custom derive macro’s signature: we get in the tokens
that are inside of the parentheses, and return the code we wanted to generate.</p>
<a class="header" href="#summary-6" id="summary-6"><h2>Summary</h2></a>
<p>Whew! Now you have some features of Rust in your toolbox that you won’t use
often, but you’ll know they’re available in very particular circumstances.
We’ve introduced several complex topics so that when you encounter them in
error message suggestions or in other peoples’ code, you’ll be able to
recognize these concepts and syntax. Use this chapter as a reference to guide
you to solutions.</p>
<p>Next, we’ll put everything we’ve discussed throughout the book into practice
and do one more project!</p>
<a class="header" href="#final-project-building-a-multithreaded-web-server" id="final-project-building-a-multithreaded-web-server"><h1>Final Project: Building a Multithreaded Web Server</h1></a>
<p>It’s been a long journey, but we’ve reached the end of the book. In this
chapter, we’ll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.</p>
<p>For our final project, we’ll make a web server that says “hello” and looks like
Figure 20-1 in a web browser.</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">Figure 20-1: Our final shared project</span></p>
<p>Here is the plan to build the web server:</p>
<ol>
<li>Learn a bit about TCP and HTTP.</li>
<li>Listen for TCP connections on a socket.</li>
<li>Parse a small number of HTTP requests.</li>
<li>Create a proper HTTP response.</li>
<li>Improve the throughput of our server with a thread pool.</li>
</ol>
<p>But before we get started, we should mention one detail: the method we’ll use
won’t be the best way to build a web server with Rust. A number of
production-ready crates are available on <em>https://crates.io/</em> that provide more
complete web server and thread pool implementations than we’ll build.</p>
<p>However, our intention in this chapter is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we can choose the
level of abstraction we want to work with and can go to a lower level than is
possible or practical in other languages. We’ll write the basic HTTP server and
thread pool manually so you can learn the general ideas and techniques behind
the crates you might use in the future.</p>
<a class="header" href="#building-a-single-threaded-web-server" id="building-a-single-threaded-web-server"><h2>Building a Single-Threaded Web Server</h2></a>
<p>We’ll start by getting a single-threaded web server working. Before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.</p>
<p>The two main protocols involved in web servers are the <em>Hypertext Transfer
Protocol</em> <em>(HTTP)</em> and the <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both
protocols are <em>request-response</em> protocols, meaning a <em>client</em> initiates
requests and a <em>server</em> listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.</p>
<p>TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’ll work with the
raw bytes of TCP and HTTP requests and responses.</p>
<a class="header" href="#listening-to-the-tcp-connection" id="listening-to-the-tcp-connection"><h3>Listening to the TCP Connection</h3></a>
<p>Our web server needs to listen to a TCP connection, so that’s the first part
we’ll work on. The standard library offers a <code>std::net</code> module that lets us do
this. Let’s make a new project in the usual fashion:</p>
<pre><code class="language-text">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 20-1 in <em>src/main.rs</em> to start. This code will
listen at the address <code>127.0.0.1:7878</code> for incoming TCP streams. When it gets
an incoming stream, it will print <code>Connection established!</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span></p>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address
<code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn’t
represent the authors’ computer specifically), and <code>7878</code> is the port. We’ve
chosen this port for two reasons: HTTP is normally accepted on this port, and
7878 is <em>rust</em> typed on a telephone.</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it
will return a new <code>TcpListener</code> instance. The reason the function is called
<code>bind</code> is that in networking, connecting to a port to listen to is known as
“binding to a port.”</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1024), so if
we tried to connect to port 80 without being an administrator, binding wouldn’t
work. As another example, binding wouldn’t work if we ran two instances of our
program and so had two programs listening to the same port. Because we’re
writing a basic server just for learning purposes, we won’t worry about
handling these kinds of errors; instead, we use <code>unwrap</code> to stop the program if
errors happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, <code>TcpStream</code> will read from itself to see what
the client sent and then allow us to write our response to the stream. Overall,
this <code>for</code> loop will process each connection in turn and produce a series of
streams for us to handle.</p>
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate
our program if the stream has any errors; if there aren’t any errors, the
program prints a message. We’ll add more functionality for the success case in
the next listing. The reason we might receive errors from the <code>incoming</code> method
when a client connects to the server is that we’re not actually iterating over
connections. Instead, we’re iterating over <em>connection attempts</em>. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.</p>
<p>Let’s try running this code! Invoke <code>cargo run</code> in the terminal and then load
<em>127.0.0.1:7878</em> in a web browser. The browser should show an error message
like “Connection reset,” because the server isn’t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes, you’ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the <em>favicon.ico</em> icon that appears in the
browser tab.</p>
<p>It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When <code>stream</code> goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the <code>drop</code> implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that we’ve successfully gotten a handle to a TCP connection!</p>
<p>Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when you’re done running a particular version of the code. Then restart <code>cargo run</code> after you’ve made each set of code changes to make sure you’re running the
newest code.</p>
<a class="header" href="#reading-the-request" id="reading-the-request"><h3>Reading the Request</h3></a>
<p>Let’s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new <code>handle_connection</code> function, we’ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpStream;
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">Listing 20-2: Reading from the <code>TcpStream</code> and printing
the data</span></p>
<p>We bring <code>std::io::prelude</code> into scope to get access to certain traits that let
us read from and write to the stream. In the <code>for</code> loop in the <code>main</code> function,
instead of printing a message that says we made a connection, we now call the
new <code>handle_connection</code> function and pass the <code>stream</code> to it.</p>
<p>In the <code>handle_connection</code> function, we’ve made the <code>stream</code> parameter mutable.
The reason is that the <code>TcpStream</code> instance keeps track of what data it returns
to us internally. It might read more data than we asked for and save that data
for the next time we ask for data. It therefore needs to be <code>mut</code> because its
internal state might change; usually, we think of “reading” as not needing
mutation, but in this case we need the <code>mut</code> keyword.</p>
<p>Next, we need to actually read from the stream. We do this in two steps: first,
we declare a <code>buffer</code> on the stack to hold the data that is read in. We’ve made
the buffer 512 bytes in size, which is big enough to hold the data of a basic
request and sufficient for our purposes in this chapter. If we wanted to handle
requests of an arbitrary size, buffer management would need to be more
complicated; we’ll keep it simple for now. We pass the buffer to <code>stream.read</code>,
which will read bytes from the <code>TcpStream</code> and put them in the buffer.</p>
<p>Second, we convert the bytes in the buffer to a string and print that string.
The <code>String::from_utf8_lossy</code> function takes a <code>&amp;[u8]</code> and produces a <code>String</code>
from it. The “lossy” part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with <code>�</code>, the <code>U+FFFD REPLACEMENT CHARACTER</code>. You might see replacement
characters for characters in the buffer that aren’t filled by request data.</p>
<p>Let’s try this code! Start the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but our
program’s output in the terminal will now look similar to this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>Depending on your browser, you might get slightly different output. Now that
we’re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after <code>Request: GET</code>. If the
repeated connections are all requesting <em>/</em>, we know the browser is trying to
fetch <em>/</em> repeatedly because it’s not getting a response from our program.</p>
<p>Let’s break down this request data to understand what the browser is asking of
our program.</p>
<a class="header" href="#a-closer-look-at-an-http-request" id="a-closer-look-at-an-http-request"><h3>A Closer Look at an HTTP Request</h3></a>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the
client is requesting. The first part of the request line indicates the <em>method</em>
being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making
this request. Our client used a <code>GET</code> request.</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>Uniform Resource
Identifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite,
the same as a <em>Uniform Resource Locator</em> <em>(URL)</em>. The difference between URIs
and URLs isn’t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.</p>
<p>The last part is the HTTP version the client uses, and then the request line
ends in a <em>CRLF sequence</em>. (CRLF stands for <em>carriage return</em> and <em>line feed</em>,
which are terms from the typewriter days!) The CRLF sequence can also be
written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>Looking at the request line data we received from running our program so far,
we see that <code>GET</code> is the method, <em>/</em> is the request URI, and <code>HTTP/1.1</code> is the
version.</p>
<p>After the request line, the remaining lines starting from <code>Host:</code> onward are
headers. <code>GET</code> requests have no body.</p>
<p>Try making a request from a different browser or asking for a different
address, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>
<p>Now that we know what the browser is asking for, let’s send back some data!</p>
<a class="header" href="#writing-a-response" id="writing-a-response"><h3>Writing a Response</h3></a>
<p>Now we’ll implement sending data in response to a client request. Responses
have the following format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.</p>
<p>Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request! From the <code>handle_connection</code> function, remove the
<code>println!</code> that was printing the request data and replace it with the code in
Listing 20-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span></p>
<p>The first new line defines the <code>response</code> variable that holds the success
message’s data. Then we call <code>as_bytes</code> on our <code>response</code> to convert the string
data to bytes. The <code>write</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends those
bytes directly down the connection.</p>
<p>Because the <code>write</code> operation could fail, we use <code>unwrap</code> on any error result
as before. Again, in a real application you would add error handling here.
Finally, <code>flush</code> will wait and prevent the program from continuing until all
the bytes are written to the connection; <code>TcpStream</code> contains an internal
buffer to minimize calls to the underlying operating system.</p>
<p>With these changes, let’s run our code and make a request. We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should
get a blank page instead of an error. You’ve just hand-coded an HTTP request
and response!</p>
<a class="header" href="#returning-real-html" id="returning-real-html"><h3>Returning Real HTML</h3></a>
<p>Let’s implement the functionality for returning more than a blank page. Create
a new file, <em>hello.html</em>, in the root of your project directory, not in the
<em>src</em> directory. You can input any HTML you want; Listing 20-4 shows one
possibility.</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-4: A sample HTML file to return in a
response</span></p>
<p>This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we’ll modify <code>handle_connection</code> as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
use std::fs;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-5: Sending the contents of <em>hello.html</em> as the
body of the response</span></p>
<p>We’ve added a line at the top to bring the standard library’s <code>File</code> into
scope. The code for opening a file and reading the contents should look
familiar; we used it in Chapter 12 when we read the contents of a file for our
I/O project in Listing 12-4.</p>
<p>Next, we use <code>format!</code> to add the file’s contents as the body of the success
response.</p>
<p>Run this code with <code>cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you
should see your HTML rendered!</p>
<p>Currently, we’re ignoring the request data in <code>buffer</code> and just sending back
the contents of the HTML file unconditionally. That means if you try requesting
<em>127.0.0.1:7878/something-else</em> in your browser, you’ll still get back this
same HTML response. Our server is very limited and is not what most web servers
do. We want to customize our responses depending on the request and only send
back the HTML file for a well-formed request to <em>/</em>.</p>
<a class="header" href="#validating-the-request-and-selectively-responding" id="validating-the-request-and-selectively-responding"><h3>Validating the Request and Selectively Responding</h3></a>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting <em>/</em> before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify <code>handle_connection</code>,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for <em>/</em> looks like and adds <code>if</code> and
<code>else</code> blocks to treat requests differently.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-6: Matching the request and handling requests
to <em>/</em> differently than other requests</span></p>
<p>First, we hardcode the data corresponding to the <em>/</em> request into the <code>get</code>
variable. Because we’re reading raw bytes into the buffer, we transform <code>get</code>
into a byte string by adding the <code>b&quot;&quot;</code> byte string syntax at the start of the
content data. Then we check whether <code>buffer</code> starts with the bytes in <code>get</code>. If
it does, it means we’ve received a well-formed request to <em>/</em>, which is the
success case we’ll handle in the <code>if</code> block that returns the contents of our
HTML file.</p>
<p>If <code>buffer</code> does <em>not</em> start with the bytes in <code>get</code>, it means we’ve received
some other request. We’ll add code to the <code>else</code> block in a moment to respond
to all other requests.</p>
<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in
<em>hello.html</em>. If you make any other request, such as
<em>127.0.0.1:7878/something-else</em>, you’ll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.</p>
<p>Now let’s add the code in Listing 20-7 to the <code>else</code> block to return a response
with the status code 404, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating the response to the end user.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs;
# fn handle_connection(mut stream: TcpStream) {
# if true {
// --snip--

} else {
    let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
# }
#}</code></pre></pre>
<p><span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than <em>/</em> was requested</span></p>
<p>Here, our response has a status line with status code 404 and the reason
phrase <code>NOT FOUND</code>. We’re still not returning headers, and the body of the
response will be the HTML in the file <em>404.html</em>. You’ll need to create a
<em>404.html</em> file next to <em>hello.html</em> for the error page; again feel free to use
any HTML you want or use the example HTML in Listing 20-8.</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span></p>
<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em>
should return the contents of <em>hello.html</em>, and any other request, like
<em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>
<a class="header" href="#a-touch-of-refactoring" id="a-touch-of-refactoring"><h3>A Touch of Refactoring</h3></a>
<p>At the moment the <code>if</code> and <code>else</code> blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make the code more
concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large <code>if</code> and <code>else</code> blocks.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
#
#     let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    // --snip--

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-9: Refactoring the <code>if</code> and <code>else</code> blocks to
contain only the code that differs between the two cases</span></p>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code>
statement, as discussed in Chapter 18.</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and
uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.</p>
<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let’s examine how that can be a problem by simulating some
slow requests. Then we’ll fix it so our server can handle multiple requests at
once.</p>
<a class="header" href="#turning-our-single-threaded-server-into-a-multithreaded-server" id="turning-our-single-threaded-server-into-a-multithreaded-server"><h2>Turning Our Single-Threaded Server into a Multithreaded Server</h2></a>
<p>Right now, the server will process each request in turn, meaning it won’t
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We’ll need to fix
this, but first, we’ll look at the problem in action.</p>
<a class="header" href="#simulating-a-slow-request-in-the-current-server-implementation" id="simulating-a-slow-request-in-the-current-server-implementation"><h3>Simulating a Slow Request in the Current Server Implementation</h3></a>
<p>We’ll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to <em>/sleep</em> with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
    // --snip--

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-10: Simulating a slow request by recognizing
<em>/sleep</em> and sleeping for 5 seconds</span></p>
<p>This code is a bit messy, but it’s good enough for simulation purposes. We
created a second request <code>sleep</code>, whose data our server recognizes. We added an
<code>else if</code> after the <code>if</code> block to check for the request to <em>/sleep</em>. When that
request is received, the server will sleep for 5 seconds before rendering the
successful HTML page.</p>
<p>You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!</p>
<p>Start the server using <code>cargo run</code>. Then open two browser windows: one for
<em>http://127.0.0.1:7878/</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If
you enter the <em>/</em> URI a few times, as before, you’ll see it respond quickly.
But if you enter <em>/sleep</em> and then load <em>/</em>, you’ll see that <em>/</em> waits until
<code>sleep</code> has slept for its full 5 seconds before loading.</p>
<p>There are multiple ways we could change how our web server works to avoid
having more requests back up behind a slow request; the one we’ll implement is
a thread pool.</p>
<a class="header" href="#improving-throughput-with-a-thread-pool" id="improving-throughput-with-a-thread-pool"><h3>Improving Throughput with a Thread Pool</h3></a>
<p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it’s returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.</p>
<p>We’ll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our server’s resources and grinding
the processing of requests to a halt.</p>
<p>Rather than spawning unlimited threads, we’ll have a fixed number of threads
waiting in the pool. As requests come in, they’ll be sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process
<code>N</code> requests concurrently, where <code>N</code> is the number of threads. If each thread
is responding to a long-running request, subsequent requests can still back up
in the queue, but we’ve increased the number of long-running requests we can
handle before reaching that point.</p>
<p>This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model and the
single-threaded async I/O model. If you’re interested in this topic, you can
read more about other solutions and try to implement them in Rust; with a
low-level language like Rust, all of these options are possible.</p>
<p>Before we begin implementing a thread pool, let’s talk about what using the
pool should look like. When you’re trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it’s
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.</p>
<p>Similar to how we used test-driven development in the project in Chapter 12,
we’ll use compiler-driven development here. We’ll write the code that calls the
functions we want, and then we’ll look at errors from the compiler to determine
what we should change next to get the code to work.</p>
<a class="header" href="#code-structure-if-we-could-spawn-a-thread-for-each-request" id="code-structure-if-we-could-spawn-a-thread-for-each-request"><h4>Code Structure If We Could Spawn a Thread for Each Request</h4></a>
<p>First, let’s explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn’t our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point. Listing 20-11 shows the changes to make to <code>main</code> to spawn a
new thread to handle each stream within the <code>for</code> loop.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">Listing 20-11: Spawning a new thread for each
stream</span></p>
<p>As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
<em>/sleep</em> in your browser, then <em>/</em> in two more browser tabs, you’ll indeed see
that the requests to <em>/</em> don’t have to wait for <em>/sleep</em> to finish. But as we
mentioned, this will eventually overwhelm the system because you’d be making
new threads without any limit.</p>
<a class="header" href="#creating-a-similar-interface-for-a-finite-number-of-threads" id="creating-a-similar-interface-for-a-finite-number-of-threads"><h4>Creating a Similar Interface for a Finite Number of Threads</h4></a>
<p>We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesn’t require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a <code>ThreadPool</code>
struct we want to use instead of <code>thread::spawn</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# struct ThreadPool;
# impl ThreadPool {
#    fn new(size: u32) -&gt; ThreadPool { ThreadPool }
#    fn execute&lt;F&gt;(&amp;self, f: F)
#        where F: FnOnce() + Send + 'static {}
# }
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">Listing 20-12: Our ideal <code>ThreadPool</code> interface</span></p>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number
of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a
similar interface as <code>thread::spawn</code> in that it takes a closure the pool should
run for each stream. We need to implement <code>pool.execute</code> so it takes the
closure and gives it to a thread in the pool to run. This code won’t yet
compile, but we’ll try so the compiler can guide us in how to fix it.</p>
<a class="header" href="#building-the-threadpool-struct-using-compiler-driven-development" id="building-the-threadpool-struct-using-compiler-driven-development"><h4>Building the <code>ThreadPool</code> Struct Using Compiler Driven Development</h4></a>
<p>Make the changes in Listing 20-12 to <em>src/main.rs</em>, and then let’s use the
compiler errors from <code>cargo check</code> to drive our development. Here is the first
error we get:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<p>Great! This error tells us we need a <code>ThreadPool</code> type or module, so we’ll
build one now. Our <code>ThreadPool</code> implementation will be independent of the kind
of work our web server is doing. So, let’s switch the <code>hello</code> crate from a
binary crate to a library crate to hold our <code>ThreadPool</code> implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.</p>
<p>Create a <em>src/lib.rs</em> that contains the following, which is the simplest
definition of a <code>ThreadPool</code> struct that we can have for now:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;
#}</code></pre></pre>
<p>Then create a new directory, <em>src/bin</em>, and move the binary crate rooted in
<em>src/main.rs</em> into <em>src/bin/main.rs</em>. Doing so will make the library crate the
primary crate in the <em>hello</em> directory; we can still run the binary in
<em>src/bin/main.rs</em> using <code>cargo run</code>. After moving the <em>main.rs</em> file, edit it
to bring the library crate in and bring <code>ThreadPool</code> into scope by adding the
following code to the top of <em>src/bin/main.rs</em>:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
</code></pre>
<p>This code still won’t work, but let’s check it again to get the next error that
we need to address:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type
`hello::ThreadPool` in the current scope
 --&gt; src/bin/main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ function or associated item not found in
   `hello::ThreadPool`
</code></pre>
<p>This error indicates that next we need to create an associated function named
<code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter
that can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance.
Let’s implement the simplest <code>new</code> function that will have those
characteristics:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
#}</code></pre></pre>
<p>We chose <code>usize</code> as the type of the <code>size</code> parameter, because we know that a
negative number of threads doesn’t make any sense. We also know we’ll use this
4 as the number of elements in a collection of threads, which is what the
<code>usize</code> type is for, as discussed in the “Integer Types” section of Chapter 3.</p>
<p>Let’s check the code again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<p>Now we get a warning and an error. Ignoring the warning for a moment, the error
occurs because we don’t have an <code>execute</code> method on <code>ThreadPool</code>. Recall from
the “Creating a Similar Interface for a Finite Number of Threads” section that
we decided our thread pool should have an interface similar to <code>thread::spawn</code>.
In addition, we’ll implement the <code>execute</code> function so it takes the closure
it’s given and gives it to an idle thread in the pool to run.</p>
<p>We’ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a
parameter. Recall from the “Storing Closures Using Generic Parameters and the
<code>Fn</code> Traits” section in Chapter 13 that we can take closures as parameters with
three different traits: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>. We need to decide which
kind of closure to use here. We know we’ll end up doing something similar to
the standard library <code>thread::spawn</code> implementation, so we can look at what
bounds the signature of <code>thread::spawn</code> has on its parameter. The documentation
shows us the following:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>The <code>F</code> type parameter is the one we’re concerned with here; the <code>T</code> type
parameter is related to the return value, and we’re not concerned with that. We
can see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code>. This is probably
what we want as well, because we’ll eventually pass the argument we get in
<code>execute</code> to <code>spawn</code>. We can be further confident that <code>FnOnce</code> is the trait we
want to use because the thread for running a request will only execute that
request’s closure one time, which matches the <code>Once</code> in <code>FnOnce</code>.</p>
<p>The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound
<code>'static</code>, which are useful in our situation: we need <code>Send</code> to transfer the
closure from one thread to another and <code>'static</code> because we don’t know how long
the thread will take to execute. Let’s create an <code>execute</code> method on
<code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
#}</code></pre></pre>
<p>We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure
that takes no parameters and doesn’t return a value. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.</p>
<p>Again, this is the simplest implementation of the <code>execute</code> method: it does
nothing, but we’re trying only to make our code compile. Let’s check it again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

warning: unused variable: `f`
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
  |
  = note: to avoid this warning, consider using `_f` instead
</code></pre>
<p>We’re receiving only warnings now, which means it compiles! But note that if
you try <code>cargo run</code> and make a request in the browser, you’ll see the errors in
the browser that we saw at the beginning of the chapter. Our library isn’t
actually calling the closure passed to <code>execute</code> yet!</p>
<blockquote>
<p>Note: A saying you might hear about languages with strict compilers, such as
Haskell and Rust, is “if the code compiles, it works.” But this saying is not
universally true. Our project compiles, but it does absolutely nothing! If we
were building a real, complete project, this would be a good time to start
writing unit tests to check that the code compiles <em>and</em> has the behavior we
want.</p>
</blockquote>
<a class="header" href="#validating-the-number-of-threads-in-new" id="validating-the-number-of-threads-in-new"><h4>Validating the Number of Threads in <code>new</code></h4></a>
<p>We’ll continue to get warnings because we aren’t doing anything with the
parameters to <code>new</code> and <code>execute</code>. Let’s implement the bodies of these
functions with the behavior we want. To start, let’s think about <code>new</code>. Earlier
we chose an unsigned type for the <code>size</code> parameter, because a pool with a
negative number of threads makes no sense. However, a pool with zero threads
also makes no sense, yet zero is a perfectly valid <code>usize</code>. We’ll add code to
check that <code>size</code> is greater than zero before we return a <code>ThreadPool</code> instance
and have the program panic if it receives a zero by using the <code>assert!</code> macro,
as shown in Listing 20-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-13: Implementing <code>ThreadPool::new</code> to panic if
<code>size</code> is zero</span></p>
<p>We’ve added some documentation for our <code>ThreadPool</code> with doc comments. Note
that we followed good documentation practices by adding a section that calls
out the situations in which our function can panic, as discussed in Chapter 14.
Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct to see what
the generated docs for <code>new</code> look like!</p>
<p>Instead of adding the <code>assert!</code> macro as we’ve done here, we could make <code>new</code>
return a <code>Result</code> like we did with <code>Config::new</code> in the I/O project in Listing
12-9. But we’ve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If you’re feeling
ambitious, try to write a version of <code>new</code> with the following signature to
compare both versions:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<a class="header" href="#creating-space-to-store-the-threads" id="creating-space-to-store-the-threads"><h4>Creating Space to Store the Threads</h4></a>
<p>Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the <code>ThreadPool</code> struct
before returning it. But how do we “store” a thread? Let’s take another look at
the <code>thread::spawn</code> signature:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that the
closure returns. Let’s try using <code>JoinHandle</code> too and see what happens. In our
case, the closures we’re passing to the thread pool will handle the connection
and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p>The code in Listing 20-14 will compile but doesn’t create any threads yet.
We’ve changed the definition of <code>ThreadPool</code> to hold a vector of
<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of
<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and
returned a <code>ThreadPool</code> instance containing them.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // --snip--
}
</code></pre>
<p><span class="caption">Listing 20-14: Creating a vector for <code>ThreadPool</code> to hold
the threads</span></p>
<p>We’ve brought <code>std::thread</code> into scope in the library crate, because we’re
using <code>thread::JoinHandle</code> as the type of the items in the vector in
<code>ThreadPool</code>.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can
hold <code>size</code> items. We haven’t used the <code>with_capacity</code> function in this book
yet, which performs the same task as <code>Vec::new</code> but with an important
difference: it preallocates space in the vector. Because we know we need to
store <code>size</code> elements in the vector, doing this allocation up front is slightly
more efficient than using <code>Vec::new</code>, which resizes itself as elements are
inserted.</p>
<p>When you run <code>cargo check</code> again, you’ll get a few more warnings, but it should
succeed.</p>
<a class="header" href="#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread" id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread"><h4>A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</h4></a>
<p>We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of
threads. Here, we’ll look at how we actually create threads. The standard
library provides <code>thread::spawn</code> as a way to create threads, and
<code>thread::spawn</code> expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them <em>wait</em> for code that we’ll send later. The standard library’s
implementation of threads doesn’t include any way to do that; we have to
implement it manually.</p>
<p>We’ll implement this behavior by introducing a new data structure between the
<code>ThreadPool</code> and the threads that will manage this new behavior. We’ll call
this data structure <code>Worker</code>, which is a common term in pooling
implementations. Think of people working in the kitchen at a restaurant: the
workers wait until orders come in from customers, and then they’re responsible
for taking those orders and filling them.</p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool,
we’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single
<code>JoinHandle&lt;()&gt;</code> instance. Then we’ll implement a method on <code>Worker</code> that will
take a closure of code to run and send it to the already running thread for
execution. We’ll also give each worker an <code>id</code> so we can distinguish between
the different workers in the pool when logging or debugging.</p>
<p>Let’s make the following changes to what happens when we create a <code>ThreadPool</code>.
We’ll implement the code that sends the closure to the thread after we have
<code>Worker</code> set up in this way:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a
<code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty
closure.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create
a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>
</ol>
<p>If you’re up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.</p>
<p>Ready? Here is Listing 20-15 with one way to make the preceding modifications.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code>
instances instead of holding threads directly</span></p>
<p>We’ve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code>
because it’s now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code>
instances. We use the counter in the <code>for</code> loop as an argument to
<code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>
<p>External code (like our server in <em>src/bin/main.rs</em>) doesn’t need to know the
implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>,
so we make the <code>Worker</code> struct and its <code>new</code> function private. The
<code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code>
instance that is created by spawning a new thread using an empty closure.</p>
<p>This code will compile and will store the number of <code>Worker</code> instances we
specified as an argument to <code>ThreadPool::new</code>. But we’re <em>still</em> not processing
the closure that we get in <code>execute</code>. Let’s look at how to do that next.</p>
<a class="header" href="#sending-requests-to-threads-via-channels" id="sending-requests-to-threads-via-channels"><h4>Sending Requests to Threads via Channels</h4></a>
<p>Now we’ll tackle the problem that the closures given to <code>thread::spawn</code> do
absolutely nothing. Currently, we get the closure we want to execute in the
<code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we
create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>We want the <code>Worker</code> structs that we just created to fetch code to run from a
queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>
<p>In Chapter 16, you learned about <em>channels</em>—a simple way to communicate between
two threads—that would be perfect for this use case. We’ll use a channel to
function as the queue of jobs, and <code>execute</code> will send a job from the
<code>ThreadPool</code> to the <code>Worker</code> instances, which will send the job to its thread.
Here is the plan:</p>
<ol>
<li>The <code>ThreadPool</code> will create a channel and hold on to the sending side of
the channel.</li>
<li>Each <code>Worker</code> will hold on to the receiving side of the channel.</li>
<li>We’ll create a new <code>Job</code> struct that will hold the closures we want to send
down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute down the sending
side of the channel.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiving side of the channel
and execute the closures of any jobs it receives.</li>
</ol>
<p>Let’s start by creating a channel in <code>ThreadPool::new</code> and holding the sending
side in the <code>ThreadPool</code> instance, as shown in Listing 20-16. The <code>Job</code> struct
doesn’t hold anything for now but will be the type of item we’re sending down
the channel.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}
#
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
# impl Worker {
#     fn new(id: usize) -&gt; Worker {
#         let thread = thread::spawn(|| {});
#
#         Worker {
#             id,
#             thread,
#         }
#     }
# }
#}</code></pre></pre>
<p><span class="caption">Listing 20-16: Modifying <code>ThreadPool</code> to store the
sending end of a channel that sends <code>Job</code> instances</span></p>
<p>In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the
sending end. This will successfully compile, still with warnings.</p>
<p>Let’s try passing a receiving end of the channel into each worker as the thread
pool creates the channel. We know we want to use the receiving end in the
thread that the workers spawn, so we’ll reference the <code>receiver</code> parameter in
the closure. The code in Listing 20-17 won’t quite compile yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-17: Passing the receiving end of the channel
to the workers</span></p>
<p>We’ve made some small and straightforward changes: we pass the receiving end of
the channel into <code>Worker::new</code>, and then we use it inside the closure.</p>
<p>When we try to check this code, we get this error:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This
won’t work, as you’ll recall from Chapter 16: the channel implementation that
Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t
just clone the consuming end of the channel to fix this code. Even if we could,
that is not the technique we would want to use; instead, we want to distribute
the jobs across threads by sharing the single <code>receiver</code> among all the workers.</p>
<p>Additionally, taking a job off the channel queue involves mutating the
<code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>;
otherwise, we might get race conditions (as covered in Chapter 16).</p>
<p>Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple workers own the
receiver, and <code>Mutex</code> will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
// --snip--

# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# struct Job;
#
impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // --snip--
}

# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
#         let thread = thread::spawn(|| {
#            receiver;
#         });
#
#         Worker {
#             id,
#             thread,
#         }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-18: Sharing the receiving end of the channel
among the workers using <code>Arc</code> and <code>Mutex</code></span></p>
<p>In <code>ThreadPool::new</code>, we put the receiving end of the channel in an <code>Arc</code> and a
<code>Mutex</code>. For each new worker, we clone the <code>Arc</code> to bump the reference count so
the workers can share ownership of the receiving end.</p>
<p>With these changes, the code compiles! We’re getting there!</p>
<a class="header" href="#implementing-the-execute-method" id="implementing-the-execute-method"><h4>Implementing the <code>execute</code> Method</h4></a>
<p>Let’s finally implement the <code>execute</code> method on <code>ThreadPool</code>. We’ll also change
<code>Job</code> from a struct to a type alias for a trait object that holds the type of
closure that <code>execute</code> receives. As discussed in the “Creating Type Synonyms
with Type Aliases” section of Chapter 19, type aliases allow us to make long
types shorter. Look at Listing 20-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// --snip--
# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# use std::sync::mpsc;
# struct Worker {}

type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
#}</code></pre></pre>
<p><span class="caption">Listing 20-19: Creating a <code>Job</code> type alias for a <code>Box</code>
that holds each closure and then sending the job down the channel</span></p>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we
send that job down the sending end of the channel. We’re calling <code>unwrap</code> on
<code>send</code> for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can’t stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use <code>unwrap</code> is that we know the failure case won’t happen, but the
compiler doesn’t know that.</p>
<p>But we’re not quite done yet! In the worker, our closure being passed to
<code>thread::spawn</code> still only <em>references</em> the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let’s make the change
shown in Listing 20-20 to <code>Worker::new</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker’s thread</span></p>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we
call <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex
is in a <em>poisoned</em> state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
<code>unwrap</code> to have this thread panic is the correct action to take. Feel free to
change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to
you.</p>
<p>If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the
channel. A final <code>unwrap</code> moves past any errors here as well, which might occur
if the thread holding the sending side of the channel has shut down, similar to
how the <code>send</code> method returns <code>Err</code> if the receiving side shuts down.</p>
<p>The call to <code>recv</code> blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The <code>Mutex&lt;T&gt;</code> ensures that only one
<code>Worker</code> thread at a time is trying to request a job.</p>
<p>Theoretically, this code should compile. Unfortunately, the Rust compiler isn’t
perfect yet, and we get this error:</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<p>This error is fairly cryptic because the problem is fairly cryptic. To call a
<code>FnOnce</code> closure that is stored in a <code>Box&lt;T&gt;</code> (which is what our <code>Job</code> type
alias is), the closure needs to move itself <em>out</em> of the <code>Box&lt;T&gt;</code> because the
closure takes ownership of <code>self</code> when we call it. In general, Rust doesn’t
allow us to move a value out of a <code>Box&lt;T&gt;</code> because Rust doesn’t know how big
the value inside the <code>Box&lt;T&gt;</code> will be: recall in Chapter 15 that we used
<code>Box&lt;T&gt;</code> precisely because we had something of an unknown size that we wanted
to store in a <code>Box&lt;T&gt;</code> to get a value of a known size.</p>
<p>As you saw in Listing 17-15, we can write methods that use the syntax <code>self: Box&lt;Self&gt;</code>, which allows the method to take ownership of a <code>Self</code> value stored
in a <code>Box&lt;T&gt;</code>. That’s exactly what we want to do here, but unfortunately Rust
won’t let us: the part of Rust that implements behavior when a closure is
called isn’t implemented using <code>self: Box&lt;Self&gt;</code>. So Rust doesn’t yet
understand that it could use <code>self: Box&lt;Self&gt;</code> in this situation to take
ownership of the closure and move the closure out of the <code>Box&lt;T&gt;</code>.</p>
<p>Rust is still a work in progress with places where the compiler could be
improved, but in the future, the code in Listing 20-20 should work just fine.
People just like you are working to fix this and other issues! After you’ve
finished this book, we would love for you to join in.</p>
<p>But for now, let’s work around this problem using a handy trick. We can tell
Rust explicitly that in this case we can take ownership of the value inside the
<code>Box&lt;T&gt;</code> using <code>self: Box&lt;Self&gt;</code>; then, once we have ownership of the closure,
we can call it. This involves defining a new trait <code>FnBox</code> with the method
<code>call_box</code> that will use <code>self: Box&lt;Self&gt;</code> in its signature, defining <code>FnBox</code>
for any type that implements <code>FnOnce()</code>, changing our type alias to use the new
trait, and changing <code>Worker</code> to use the <code>call_box</code> method. These changes are
shown in Listing 20-21.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-21: Adding a new trait <code>FnBox</code> to work around
the current limitations of <code>Box&lt;FnOnce()&gt;</code></span></p>
<p>First, we create a new trait named <code>FnBox</code>. This trait has the one method
<code>call_box</code>, which is similar to the <code>call</code> methods on the other <code>Fn*</code> traits
except that it takes <code>self: Box&lt;Self&gt;</code> to take ownership of <code>self</code> and move the
value out of the <code>Box&lt;T&gt;</code>.</p>
<p>Next, we implement the <code>FnBox</code> trait for any type <code>F</code> that implements the
<code>FnOnce()</code> trait. Effectively, this means that any <code>FnOnce()</code> closures can use
our <code>call_box</code> method. The implementation of <code>call_box</code> uses <code>(*self)()</code> to
move the closure out of the <code>Box&lt;T&gt;</code> and call the closure.</p>
<p>We now need our <code>Job</code> type alias to be a <code>Box</code> of anything that implements our
new trait <code>FnBox</code>. This will allow us to use <code>call_box</code> in <code>Worker</code> when we get
a <code>Job</code> value instead of invoking the closure directly. Implementing the
<code>FnBox</code> trait for any <code>FnOnce()</code> closure means we don’t have to change anything
about the actual values we’re sending down the channel. Now Rust is able to
recognize that what we want to do is fine.</p>
<p>This trick is very sneaky and complicated. Don’t worry if it doesn’t make
perfect sense; someday, it will be completely unnecessary.</p>
<p>With the implementation of this trick, our thread pool is in a working state!
Give it a <code>cargo run</code> and make some requests:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won’t get
overloaded if the server receives a lot of requests. If we make a request to
<em>/sleep</em>, the server will be able to serve other requests by having another
thread run them.</p>
<p>Note that if you open <em>/sleep</em> in multiple browser windows simultaneously, they
might load 5 seconds apart from each other, because some web browsers execute
multiple instances of the same request sequentially for caching reasons. This
limitation is not caused by our web server.</p>
<p>After learning about the <code>while let</code> loop in Chapter 18, you might be wondering
why we didn’t write the worker thread code as shown in Listing 20-22.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-22: An alternative implementation of
<code>Worker::new</code> using <code>while let</code></span></p>
<p>This code compiles and runs but doesn’t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the <code>Mutex</code> struct has no public
<code>unlock</code> method because the ownership of the lock is based on the lifetime of
the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code>
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the
lock. But this implementation can also result in the lock being held longer
than intended if we don’t think carefully about the lifetime of the
<code>MutexGuard&lt;T&gt;</code>. Because the values in the <code>while</code> expression remain in scope
for the duration of the block, the lock remains held for the duration of the
call to <code>job.call_box()</code>, meaning other workers cannot receive jobs.</p>
<p>By using <code>loop</code> instead and acquiring the lock and a job within the block
rather than outside it, the <code>MutexGuard</code> returned from the <code>lock</code> method is
dropped as soon as the <code>let job</code> statement ends. This ensures that the lock is
held during the call to <code>recv</code>, but it is released before the call to
<code>job.call_box()</code>, allowing multiple requests to be serviced concurrently.</p>
<a class="header" href="#graceful-shutdown-and-cleanup" id="graceful-shutdown-and-cleanup"><h2>Graceful Shutdown and Cleanup</h2></a>
<p>The code in Listing 20-21 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the <code>workers</code>,
<code>id</code>, and <code>thread</code> fields that we’re not using in a direct way that reminds us
we’re not cleaning up anything. When we use the less elegant <span
class="keystroke">ctrl-c</span> method to halt the main thread, all other
threads are stopped immediately as well, even if they’re in the middle of
serving a request.</p>
<p>Now we’ll implement the <code>Drop</code> trait to call <code>join</code> on each of the threads in
the pool so they can finish the requests they’re working on before closing.
Then we’ll implement a way to tell the threads they should stop accepting new
requests and shut down. To see this code in action, we’ll modify our server to
accept only two requests before gracefully shutting down its thread pool.</p>
<a class="header" href="#implementing-the-drop-trait-on-threadpool" id="implementing-the-drop-trait-on-threadpool"><h3>Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></h3></a>
<p>Let’s start with implementing <code>Drop</code> on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 20-23 shows a first attempt at a <code>Drop</code> implementation; this code won’t
quite work yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-23: Joining each thread when the thread pool
goes out of scope</span></p>
<p>First, we loop through each of the thread pool <code>workers</code>. We use <code>&amp;mut</code> for
this because <code>self</code> is a mutable reference, and we also need to be able to
mutate <code>worker</code>. For each worker, we print a message saying that this
particular worker is shutting down, and then we call <code>join</code> on that worker’s
thread. If the call to <code>join</code> fails, we use <code>unwrap</code> to make Rust panic and go
into an ungraceful shutdown.</p>
<p>Here is the error we get when we compile this code:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<p>The error tells us we can’t call <code>join</code> because we only have a mutable borrow
of each <code>worker</code> and <code>join</code> takes ownership of its argument. To solve this
issue, we need to move the thread out of the <code>Worker</code> instance that owns
<code>thread</code> so <code>join</code> can consume the thread. We did this in Listing 17-15: if
<code>Worker</code> holds an <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> instead, we can call the
<code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code> variant and
leave a <code>None</code> variant in its place. In other words, a <code>Worker</code> that is running
will have a <code>Some</code> variant in <code>thread</code>, and when we want to clean up a
<code>Worker</code>, we’ll replace <code>Some</code> with <code>None</code> so the <code>Worker</code> doesn’t have a
thread to run.</p>
<p>So we know we want to update the definition of <code>Worker</code> like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
#}</code></pre></pre>
<p>Now let’s lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:</p>
<pre><code class="language-text">error[E0599]: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum `std::option::Option`, found struct
   `std::thread::JoinHandle`
   |             help: try using a variant of the expected type: `Some(thread)`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<p>Let’s address the second error, which points to the code at the end of
<code>Worker::new</code>; we need to wrap the <code>thread</code> value in <code>Some</code> when we create a
new <code>Worker</code>. Make the following changes to fix this error:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>The first error is in our <code>Drop</code> implementation. We mentioned earlier that we
intended to call <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code>.
The following changes will do so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p>As discussed in Chapter 17, the <code>take</code> method on <code>Option</code> takes the <code>Some</code>
variant out and leaves <code>None</code> in its place. We’re using <code>if let</code> to destructure
the <code>Some</code> and get the thread; then we call <code>join</code> on the thread. If a worker’s
thread is already <code>None</code>, we know that worker has already had its thread
cleaned up, so nothing happens in that case.</p>
<a class="header" href="#signaling-to-the-threads-to-stop-listening-for-jobs" id="signaling-to-the-threads-to-stop-listening-for-jobs"><h3>Signaling to the Threads to Stop Listening for Jobs</h3></a>
<p>With all the changes we’ve made, our code compiles without any warnings. But
the bad news is this code doesn’t function the way we want it to yet. The key
is the logic in the closures run by the threads of the <code>Worker</code> instances: at
the moment, we call <code>join</code>, but that won’t shut down the threads because they
<code>loop</code> forever looking for jobs. If we try to drop our <code>ThreadPool</code> with our
current implementation of <code>drop</code>, the main thread will block forever waiting
for the first thread to finish.</p>
<p>To fix this problem, we’ll modify the threads so they listen for either a <code>Job</code>
to run or a signal that they should stop listening and exit the infinite loop.
Instead of <code>Job</code> instances, our channel will send one of these two enum
variants.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Job;
enum Message {
    NewJob(Job),
    Terminate,
}
#}</code></pre></pre>
<p>This <code>Message</code> enum will either be a <code>NewJob</code> variant that holds the <code>Job</code> the
thread should run, or it will be a <code>Terminate</code> variant that will cause the
thread to exit its loop and stop.</p>
<p>We need to adjust the channel to use values of type <code>Message</code> rather than type
<code>Job</code>, as shown in Listing 20-24.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-24: Sending and receiving <code>Message</code> values and
exiting the loop if a <code>Worker</code> receives <code>Message::Terminate</code></span></p>
<p>To incorporate the <code>Message</code> enum, we need to change <code>Job</code> to <code>Message</code> in two
places: the definition of <code>ThreadPool</code> and the signature of <code>Worker::new</code>. The
<code>execute</code> method of <code>ThreadPool</code> needs to send jobs wrapped in the
<code>Message::NewJob</code> variant. Then, in <code>Worker::new</code> where a <code>Message</code> is received
from the channel, the job will be processed if the <code>NewJob</code> variant is
received, and the thread will break out of the loop if the <code>Terminate</code> variant
is received.</p>
<p>With these changes, the code will compile and continue to function in the same
way as it did after Listing 20-21. But we’ll get a warning because we aren’t
creating any messages of the <code>Terminate</code> variety. Let’s fix this warning by
changing our <code>Drop</code> implementation to look like Listing 20-25.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-25: Sending <code>Message::Terminate</code> to the
workers before calling <code>join</code> on each worker thread</span></p>
<p>We’re now iterating over the workers twice: once to send one <code>Terminate</code>
message for each worker and once to call <code>join</code> on each worker’s thread. If we
tried to send a message and <code>join</code> immediately in the same loop, we couldn’t
guarantee that the worker in the current iteration would be the one to get the
message from the channel.</p>
<p>To better understand why we need two separate loops, imagine a scenario with
two workers. If we used a single loop to iterate through each worker, on the
first iteration a terminate message would be sent down the channel and <code>join</code>
called on the first worker’s thread. If that first worker was busy processing a
request at that moment, the second worker would pick up the terminate message
from the channel and shut down. We would be left waiting on the first worker to
shut down, but it never would because the second thread picked up the terminate
message. Deadlock!</p>
<p>To prevent this scenario, we first put all of our <code>Terminate</code> messages on the
channel in one loop; then we join on all the threads in another loop. Each
worker will stop receiving requests on the channel once it gets a terminate
message. So, we can be sure that if we send the same number of terminate
messages as there are workers, each worker will receive a terminate message
before <code>join</code> is called on its thread.</p>
<p>To see this code in action, let’s modify <code>main</code> to accept only two requests
before gracefully shutting down the server, as shown in Listing 20-26.</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
</code></pre>
<p><span class="caption">Listing 20-26: Shut down the server after serving two
requests by exiting the loop</span></p>
<p>You wouldn’t want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.</p>
<p>The <code>take</code> method is defined in the <code>Iterator</code> trait and limits the iteration
to the first two items at most. The <code>ThreadPool</code> will go out of scope at the
end of <code>main</code>, and the <code>drop</code> implementation will run.</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request
should error, and in your terminal you should see output similar to this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You might see a different ordering of workers and messages printed. We can see
how this code works from the messages: workers 0 and 3 got the first two
requests, and then on the third request, the server stopped accepting
connections. When the <code>ThreadPool</code> goes out of scope at the end of <code>main</code>, its
<code>Drop</code> implementation kicks in, and the pool tells all workers to terminate.
The workers each print a message when they see the terminate message, and then
the thread pool calls <code>join</code> to shut down each worker thread.</p>
<p>Notice one interesting aspect of this particular execution: the <code>ThreadPool</code>
sent the terminate messages down the channel, and before any worker received
the messages, we tried to join worker 0. Worker 0 had not yet received the
terminate message, so the main thread blocked waiting for worker 0 to finish.
In the meantime, each of the workers received the termination messages. When
worker 0 finished, the main thread waited for the rest of the workers to
finish. At that point, they had all received the termination message and were
able to shut down.</p>
<p>Congrats! We’ve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. We’re able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.</p>
<p>Here’s the full code for reference:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let contents = fs::read_to_string(filename).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;dyn FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
#}</code></pre></pre>
<p>We could do more here! If you want to continue enhancing this project, here are
some ideas:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods.</li>
<li>Add tests of the library’s functionality.</li>
<li>Change calls to <code>unwrap</code> to more robust error handling.</li>
<li>Use <code>ThreadPool</code> to perform some task other than serving web requests.</li>
<li>Find a thread pool crate on <em>https://crates.io/</em> and implement a similar web
server using the crate instead. Then compare its API and robustness to the
thread pool we implemented.</li>
</ul>
<a class="header" href="#summary-7" id="summary-7"><h2>Summary</h2></a>
<p>Well done! You’ve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. You’re now ready to implement your own Rust
projects and help with other peoples’ projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.</p>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<p>The following sections contain reference material you may find useful in your
Rust journey.</p>
<a class="header" href="#appendix-a-keywords" id="appendix-a-keywords"><h2>Appendix A: Keywords</h2></a>
<p>The following list contains keywords that are reserved for current or future
use by the Rust language. As such, they cannot be used as identifiers (except as
<a href="#raw-identifiers">raw identifiers</a>), including names of functions, variables,
parameters, struct fields, modules, crates, constants, macros, static values,
attributes, types, traits, or lifetimes.</p>
<a class="header" href="#keywords-currently-in-use" id="keywords-currently-in-use"><h3>Keywords Currently in Use</h3></a>
<p>The following keywords currently have the functionality described.</p>
<ul>
<li><code>as</code> - perform primitive casting, disambiguate the specific trait containing
an item, or rename items in <code>use</code> and <code>extern crate</code> statements</li>
<li><code>break</code> - exit a loop immediately</li>
<li><code>const</code> - define constant items or constant raw pointers</li>
<li><code>continue</code> - continue to the next loop iteration</li>
<li><code>crate</code> - link an external crate or a macro variable representing the crate in
which the macro is defined</li>
<li><code>dyn</code> - dynamic dispatch to a trait object</li>
<li><code>else</code> - fallback for <code>if</code> and <code>if let</code> control flow constructs</li>
<li><code>enum</code> - define an enumeration</li>
<li><code>extern</code> - link an external crate, function, or variable</li>
<li><code>false</code> - Boolean false literal</li>
<li><code>fn</code> - define a function or the function pointer type</li>
<li><code>for</code> - loop over items from an iterator, implement a trait, or specify a
higher-ranked lifetime</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>impl</code> - implement inherent or trait functionality</li>
<li><code>in</code> - part of <code>for</code> loop syntax</li>
<li><code>let</code> - bind a variable</li>
<li><code>loop</code> - loop unconditionally</li>
<li><code>match</code> - match a value to patterns</li>
<li><code>mod</code> - define a module</li>
<li><code>move</code> - make a closure take ownership of all its captures</li>
<li><code>mut</code> - denote mutability in references, raw pointers, or pattern bindings</li>
<li><code>pub</code> - denote public visibility in struct fields, <code>impl</code> blocks, or modules</li>
<li><code>ref</code> - bind by reference</li>
<li><code>return</code> - return from function</li>
<li><code>Self</code> - a type alias for the type implementing a trait</li>
<li><code>self</code> - method subject or current module</li>
<li><code>static</code> - global variable or lifetime lasting the entire program execution</li>
<li><code>struct</code> - define a structure</li>
<li><code>super</code> - parent module of the current module</li>
<li><code>trait</code> - define a trait</li>
<li><code>true</code> - Boolean true literal</li>
<li><code>type</code> - define a type alias or associated type</li>
<li><code>unsafe</code> - denote unsafe code, functions, traits, or implementations</li>
<li><code>use</code> - bring symbols into scope</li>
<li><code>where</code> - denote clauses that constrain a type</li>
<li><code>while</code> - loop conditionally based on the result of an expression</li>
</ul>
<a class="header" href="#keywords-reserved-for-future-use" id="keywords-reserved-for-future-use"><h3>Keywords Reserved for Future Use</h3></a>
<p>The following keywords do not have any functionality but are reserved by Rust
for potential future use.</p>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<a class="header" href="#raw-identifiers" id="raw-identifiers"><h3>Raw identifiers</h3></a>
<p>Raw identifiers let you use keywords where they would not normally be allowed by
prefixing them with <code>r#</code>.</p>
<p>For example, <code>match</code> is a keyword. If you try to compile this function:</p>
<pre><code class="language-rust ignore">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>You’ll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>You can write this with a raw identifier:</p>
<pre><pre class="playpen"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>Note the <code>r#</code> prefix on both the function name as well as the call.</p>
<a class="header" href="#motivation" id="motivation"><h4>Motivation</h4></a>
<p>This feature is useful for a few reasons, but the primary motivation was
inter-edition situations. For example, <code>try</code> is not a keyword in the 2015
edition, but is in the 2018 edition. So if you have a library that is written
in Rust 2015 and has a <code>try</code> function, to call it in Rust 2018, you’ll need
to use the raw identifier.</p>
<a class="header" href="#appendix-b-operators-and-symbols" id="appendix-b-operators-and-symbols"><h2>Appendix B: Operators and Symbols</h2></a>
<p>This appendix contains a glossary of Rust’s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.</p>
<a class="header" href="#operators" id="operators"><h3>Operators</h3></a>
<p>Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.</p>
<p><span class="caption">Table B-1: Operators</span></p>
<table><thead><tr><th> Operator </th><th> Example </th><th> Explanation </th><th> Overloadable? </th></tr></thead><tbody>
<tr><td> <code>!</code> </td><td> <code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code> </td><td> Macro expansion </td><td> </td></tr>
<tr><td> <code>!</code> </td><td> <code>!expr</code> </td><td> Bitwise or logical complement </td><td> <code>Not</code> </td></tr>
<tr><td> <code>!=</code> </td><td> <code>var != expr</code> </td><td> Nonequality comparison </td><td> <code>PartialEq</code> </td></tr>
<tr><td> <code>%</code> </td><td> <code>expr % expr</code> </td><td> Arithmetic remainder </td><td> <code>Rem</code> </td></tr>
<tr><td> <code>%=</code> </td><td> <code>var %= expr</code> </td><td> Arithmetic remainder and assignment </td><td> <code>RemAssign</code> </td></tr>
<tr><td> <code>&amp;</code> </td><td> <code>&amp;expr</code>, <code>&amp;mut expr</code> </td><td> Borrow </td><td> </td></tr>
<tr><td> <code>&amp;</code> </td><td> <code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code> </td><td> Borrowed pointer type </td><td> </td></tr>
<tr><td> <code>&amp;</code> </td><td> <code>expr &amp; expr</code> </td><td> Bitwise AND </td><td> <code>BitAnd</code> </td></tr>
<tr><td> <code>&amp;=</code> </td><td> <code>var &amp;= expr</code> </td><td> Bitwise AND and assignment </td><td> <code>BitAndAssign</code> </td></tr>
<tr><td> <code>&amp;&amp;</code> </td><td> <code>expr &amp;&amp; expr</code> </td><td> Logical AND </td><td> </td></tr>
<tr><td> <code>*</code> </td><td> <code>expr * expr</code> </td><td> Arithmetic multiplication </td><td> <code>Mul</code> </td></tr>
<tr><td> <code>*=</code> </td><td> <code>var *= expr</code> </td><td> Arithmetic multiplication and assignment </td><td> <code>MulAssign</code> </td></tr>
<tr><td> <code>*</code> </td><td> <code>*expr</code> </td><td> Dereference </td><td> </td></tr>
<tr><td> <code>*</code> </td><td> <code>*const type</code>, <code>*mut type</code> </td><td> Raw pointer </td><td> </td></tr>
<tr><td> <code>+</code> </td><td> <code>trait + trait</code>, <code>'a + trait</code> </td><td> Compound type constraint </td><td> </td></tr>
<tr><td> <code>+</code> </td><td> <code>expr + expr</code> </td><td> Arithmetic addition </td><td> <code>Add</code> </td></tr>
<tr><td> <code>+=</code> </td><td> <code>var += expr</code> </td><td> Arithmetic addition and assignment </td><td> <code>AddAssign</code> </td></tr>
<tr><td> <code>,</code> </td><td> <code>expr, expr</code> </td><td> Argument and element separator </td><td> </td></tr>
<tr><td> <code>-</code> </td><td> <code>- expr</code> </td><td> Arithmetic negation </td><td> <code>Neg</code> </td></tr>
<tr><td> <code>-</code> </td><td> <code>expr - expr</code> </td><td> Arithmetic subtraction </td><td> <code>Sub</code> </td></tr>
<tr><td> <code>-=</code> </td><td> <code>var -= expr</code> </td><td> Arithmetic subtraction and assignment </td><td> <code>SubAssign</code> </td></tr>
<tr><td> <code>-&gt;</code> </td><td> <code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code> </td><td> Function and closure return type </td><td> </td></tr>
<tr><td> <code>.</code> </td><td> <code>expr.ident</code> </td><td> Member access </td><td> </td></tr>
<tr><td> <code>..</code> </td><td> <code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code> </td><td> Right-exclusive range literal </td><td> </td></tr>
<tr><td> <code>..=</code> </td><td> <code>..=expr</code>, <code>expr..=expr</code> </td><td> Right-inclusive range literal </td><td> </td></tr>
<tr><td> <code>..</code> </td><td> <code>..expr</code> </td><td> Struct literal update syntax </td><td> </td></tr>
<tr><td> <code>..</code> </td><td> <code>variant(x, ..)</code>, <code>struct_type { x, .. }</code> </td><td> “And the rest” pattern binding </td><td> </td></tr>
<tr><td> <code>...</code> </td><td> <code>expr...expr</code> </td><td> In a pattern: inclusive range pattern </td><td> </td></tr>
<tr><td> <code>/</code> </td><td> <code>expr / expr</code> </td><td> Arithmetic division </td><td> <code>Div</code> </td></tr>
<tr><td> <code>/=</code> </td><td> <code>var /= expr</code> </td><td> Arithmetic division and assignment </td><td> <code>DivAssign</code> </td></tr>
<tr><td> <code>:</code> </td><td> <code>pat: type</code>, <code>ident: type</code> </td><td> Constraints </td><td> </td></tr>
<tr><td> <code>:</code> </td><td> <code>ident: expr</code> </td><td> Struct field initializer </td><td> </td></tr>
<tr><td> <code>:</code> </td><td> <code>'a: loop {...}</code> </td><td> Loop label </td><td> </td></tr>
<tr><td> <code>;</code> </td><td> <code>expr;</code> </td><td> Statement and item terminator </td><td> </td></tr>
<tr><td> <code>;</code> </td><td> <code>[...; len]</code> </td><td> Part of fixed-size array syntax </td><td> </td></tr>
<tr><td> <code>&lt;&lt;</code> </td><td> <code>expr &lt;&lt; expr</code> </td><td> Left-shift </td><td> <code>Shl</code> </td></tr>
<tr><td> <code>&lt;&lt;=</code> </td><td> <code>var &lt;&lt;= expr</code> </td><td> Left-shift and assignment </td><td> <code>ShlAssign</code> </td></tr>
<tr><td> <code>&lt;</code> </td><td> <code>expr &lt; expr</code> </td><td> Less than comparison </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&lt;=</code> </td><td> <code>expr &lt;= expr</code> </td><td> Less than or equal to comparison </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>=</code> </td><td> <code>var = expr</code>, <code>ident = type</code> </td><td> Assignment/equivalence </td><td> </td></tr>
<tr><td> <code>==</code> </td><td> <code>expr == expr</code> </td><td> Equality comparison </td><td> <code>PartialEq</code> </td></tr>
<tr><td> <code>=&gt;</code> </td><td> <code>pat =&gt; expr</code> </td><td> Part of match arm syntax </td><td> </td></tr>
<tr><td> <code>&gt;</code> </td><td> <code>expr &gt; expr</code> </td><td> Greater than comparison </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&gt;=</code> </td><td> <code>expr &gt;= expr</code> </td><td> Greater than or equal to comparison </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&gt;&gt;</code> </td><td> <code>expr &gt;&gt; expr</code> </td><td> Right-shift </td><td> <code>Shr</code> </td></tr>
<tr><td> <code>&gt;&gt;=</code> </td><td> <code>var &gt;&gt;= expr</code> </td><td> Right-shift and assignment </td><td> <code>ShrAssign</code> </td></tr>
<tr><td> <code>@</code> </td><td> <code>ident @ pat</code> </td><td> Pattern binding </td><td> </td></tr>
<tr><td> <code>^</code> </td><td> <code>expr ^ expr</code> </td><td> Bitwise exclusive OR </td><td> <code>BitXor</code> </td></tr>
<tr><td> <code>^=</code> </td><td> <code>var ^= expr</code> </td><td> Bitwise exclusive OR and assignment </td><td> <code>BitXorAssign</code> </td></tr>
<tr><td> <code>|</code> </td><td> <code>pat | pat</code> </td><td> Pattern alternatives </td><td> </td></tr>
<tr><td> <code>|</code> </td><td> <code>expr | expr</code> </td><td> Bitwise OR </td><td> <code>BitOr</code> </td></tr>
<tr><td> <code>|=</code> </td><td> <code>var |= expr</code> </td><td> Bitwise OR and assignment </td><td> <code>BitOrAssign</code> </td></tr>
<tr><td> <code>||</code> </td><td> <code>expr || expr</code> </td><td> Logical OR </td><td> </td></tr>
<tr><td> <code>?</code> </td><td> <code>expr?</code> </td><td> Error propagation </td><td> </td></tr>
</tbody></table>
<a class="header" href="#non-operator-symbols" id="non-operator-symbols"><h3>Non-operator Symbols</h3></a>
<p>The following list contains all non-letters that don’t function as operators;
that is, they don’t behave like a function or method call.</p>
<p>Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.</p>
<p><span class="caption">Table B-2: Stand-Alone Syntax</span></p>
<table><thead><tr><th> Symbol </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>'ident</code> </td><td> Named lifetime or loop label </td></tr>
<tr><td> <code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc. </td><td> Numeric literal of specific type </td></tr>
<tr><td> <code>&quot;...&quot;</code> </td><td> String literal </td></tr>
<tr><td> <code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc. </td><td> Raw string literal, escape characters not processed </td></tr>
<tr><td> <code>b&quot;...&quot;</code> </td><td> Byte string literal; constructs a <code>[u8]</code> instead of a string </td></tr>
<tr><td> <code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc. </td><td> Raw byte string literal, combination of raw and byte string literal </td></tr>
<tr><td> <code>'...'</code> </td><td> Character literal </td></tr>
<tr><td> <code>b'...'</code> </td><td> ASCII byte literal </td></tr>
<tr><td> <code>|...| expr</code> </td><td> Closure </td></tr>
<tr><td> <code>!</code> </td><td> Always empty bottom type for diverging functions </td></tr>
<tr><td> <code>_</code> </td><td> “Ignored” pattern binding; also used to make integer literals readable </td></tr>
</tbody></table>
<p>Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.</p>
<p><span class="caption">Table B-3: Path-Related Syntax</span></p>
<table><thead><tr><th> Symbol </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>ident::ident</code> </td><td> Namespace path </td></tr>
<tr><td> <code>::path</code> </td><td> Path relative to the crate root (i.e., an explicitly absolute path) </td></tr>
<tr><td> <code>self::path</code> </td><td> Path relative to the current module (i.e., an explicitly relative path).</td></tr>
<tr><td> <code>super::path</code> </td><td> Path relative to the parent of the current module </td></tr>
<tr><td> <code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code> </td><td> Associated constants, functions, and types </td></tr>
<tr><td> <code>&lt;type&gt;::...</code> </td><td> Associated item for a type that cannot be directly named (e.g., <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.) </td></tr>
<tr><td> <code>trait::method(...)</code> </td><td> Disambiguating a method call by naming the trait that defines it </td></tr>
<tr><td> <code>type::method(...)</code> </td><td> Disambiguating a method call by naming the type for which it’s defined </td></tr>
<tr><td> <code>&lt;type as trait&gt;::method(...)</code> </td><td> Disambiguating a method call by naming the trait and type </td></tr>
</tbody></table>
<p>Table B-4 shows symbols that appear in the context of using generic type
parameters.</p>
<p><span class="caption">Table B-4: Generics</span></p>
<table><thead><tr><th> Symbol </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>path&lt;...&gt;</code> </td><td> Specifies parameters to generic type in a type (e.g., <code>Vec&lt;u8&gt;</code>) </td></tr>
<tr><td> <code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code> </td><td> Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>) </td></tr>
<tr><td> <code>fn ident&lt;...&gt; ...</code> </td><td> Define generic function </td></tr>
<tr><td> <code>struct ident&lt;...&gt; ...</code> </td><td> Define generic structure </td></tr>
<tr><td> <code>enum ident&lt;...&gt; ...</code> </td><td> Define generic enumeration </td></tr>
<tr><td> <code>impl&lt;...&gt; ...</code> </td><td> Define generic implementation </td></tr>
<tr><td> <code>for&lt;...&gt; type</code> </td><td> Higher-ranked lifetime bounds </td></tr>
<tr><td> <code>type&lt;ident=type&gt;</code> </td><td> A generic type where one or more associated types have specific assignments (e.g., <code>Iterator&lt;Item=T&gt;</code>) </td></tr>
</tbody></table>
<p>Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.</p>
<p><span class="caption">Table B-5: Trait Bound Constraints</span></p>
<table><thead><tr><th> Symbol </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>T: U</code> </td><td> Generic parameter <code>T</code> constrained to types that implement <code>U</code> </td></tr>
<tr><td> <code>T: 'a</code> </td><td> Generic type <code>T</code> must outlive lifetime <code>'a</code> (meaning the type cannot transitively contain any references with lifetimes shorter than <code>'a</code>) </td></tr>
<tr><td> <code>T : 'static</code> </td><td> Generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones </td></tr>
<tr><td> <code>'b: 'a</code> </td><td> Generic lifetime <code>'b</code> must outlive lifetime <code>'a</code> </td></tr>
<tr><td> <code>T: ?Sized</code> </td><td> Allow generic type parameter to be a dynamically sized type </td></tr>
<tr><td> <code>'a + trait</code>, <code>trait + trait</code> </td><td> Compound type constraint </td></tr>
</tbody></table>
<p>Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.</p>
<p><span class="caption">Table B-6: Macros and Attributes</span></p>
<table><thead><tr><th> Symbol </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>#[meta]</code> </td><td> Outer attribute </td></tr>
<tr><td> <code>#![meta]</code> </td><td> Inner attribute </td></tr>
<tr><td> <code>$ident</code> </td><td> Macro substitution </td></tr>
<tr><td> <code>$ident:kind</code> </td><td> Macro capture </td></tr>
<tr><td> <code>$(…)…</code> </td><td> Macro repetition </td></tr>
</tbody></table>
<p>Table B-7 shows symbols that create comments.</p>
<p><span class="caption">Table B-7: Comments</span></p>
<table><thead><tr><th> Symbol </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>//</code> </td><td> Line comment </td></tr>
<tr><td> <code>//!</code> </td><td> Inner line doc comment </td></tr>
<tr><td> <code>///</code> </td><td> Outer line doc comment </td></tr>
<tr><td> <code>/*...*/</code> </td><td> Block comment </td></tr>
<tr><td> <code>/*!...*/</code> </td><td> Inner block doc comment </td></tr>
<tr><td> <code>/**...*/</code> </td><td> Outer block doc comment </td></tr>
</tbody></table>
<p>Table B-8 shows symbols that appear in the context of using tuples.</p>
<p><span class="caption">Table B-8: Tuples</span></p>
<table><thead><tr><th> Symbol </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>()</code> </td><td> Empty tuple (aka unit), both literal and type </td></tr>
<tr><td> <code>(expr)</code> </td><td> Parenthesized expression </td></tr>
<tr><td> <code>(expr,)</code> </td><td> Single-element tuple expression </td></tr>
<tr><td> <code>(type,)</code> </td><td> Single-element tuple type </td></tr>
<tr><td> <code>(expr, ...)</code> </td><td> Tuple expression </td></tr>
<tr><td> <code>(type, ...)</code> </td><td> Tuple type </td></tr>
<tr><td> <code>expr(expr, ...)</code> </td><td> Function call expression; also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants </td></tr>
<tr><td> <code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code> </td><td> Macro invocation </td></tr>
<tr><td> <code>expr.0</code>, <code>expr.1</code>, etc. </td><td> Tuple indexing </td></tr>
</tbody></table>
<p>Table B-9 shows the contexts in which curly braces are used.</p>
<p><span class="caption">Table B-9: Curly Brackets</span></p>
<table><thead><tr><th> Context </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>{...}</code> </td><td> Block expression </td></tr>
<tr><td> <code>Type {...}</code> </td><td> <code>struct</code> literal </td></tr>
</tbody></table>
<p>Table B-10 shows the contexts in which square brackets are used.</p>
<p><span class="caption">Table B-10: Square Brackets</span></p>
<table><thead><tr><th> Context </th><th> Explanation </th></tr></thead><tbody>
<tr><td> <code>[...]</code> </td><td> Array literal </td></tr>
<tr><td> <code>[expr; len]</code> </td><td> Array literal containing <code>len</code> copies of <code>expr</code> </td></tr>
<tr><td> <code>[type; len]</code> </td><td> Array type containing <code>len</code> instances of <code>type</code> </td></tr>
<tr><td> <code>expr[expr]</code> </td><td> Collection indexing. Overloadable (<code>Index</code>, <code>IndexMut</code>) </td></tr>
<tr><td> <code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code> </td><td> Collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, or <code>RangeFull</code> as the “index” </td></tr>
</tbody></table>
<a class="header" href="#appendix-c-derivable-traits" id="appendix-c-derivable-traits"><h2>Appendix C: Derivable Traits</h2></a>
<p>In various places in the book, we’ve discussed the <code>derive</code> attribute, which
you can apply to a struct or enum definition. The <code>derive</code> attribute generates
code that will implement a trait with its own default implementation on the
type you’ve annotated with the <code>derive</code> syntax.</p>
<p>In this appendix, we provide a reference of all the traits in the standard
library that you can use with <code>derive</code>. Each section covers:</p>
<ul>
<li>What operators and methods deriving this trait will enable</li>
<li>What the implementation of the trait provided by <code>derive</code> does</li>
<li>What implementing the trait signifies about the type</li>
<li>The conditions in which you’re allowed or not allowed to implement the trait</li>
<li>Examples of operations that require the trait</li>
</ul>
<p>If you want different behavior than that provided by the <code>derive</code> attribute,
consult the <a href="../std/index.html">standard library documentation</a><!-- ignore -->
for each trait for details of how to manually implement them.</p>
<p>The rest of the traits defined in the standard library can’t be implemented on
your types using <code>derive</code>. These traits don’t have sensible default behavior,
so it’s up to you to implement them in the way that makes sense for what you’re
trying to accomplish.</p>
<p>An example of a trait that can’t be derived is <code>Display</code>, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn’t have this insight, so
it can’t provide appropriate default behavior for you.</p>
<p>The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement <code>derive</code> for their own traits, making the list of
traits you can use <code>derive</code> with truly open-ended. Implementing <code>derive</code>
involves using a procedural macro, which is covered in the “Macros” section of
Chapter 19.</p>
<a class="header" href="#debug-for-programmer-output" id="debug-for-programmer-output"><h3><code>Debug</code> for Programmer Output</h3></a>
<p>The <code>Debug</code> trait enables debug formatting in format strings, which you
indicate by adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p>The <code>Debug</code> trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program’s execution.</p>
<p>The <code>Debug</code> trait is required, for example, in use of the <code>assert_eq!</code> macro.
This macro prints the values of instances given as arguments if the equality
assertion fails so programmers can see why the two instances weren’t equal.</p>
<a class="header" href="#partialeq-and-eq-for-equality-comparisons" id="partialeq-and-eq-for-equality-comparisons"><h3><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons</h3></a>
<p>The <code>PartialEq</code> trait allows you to compare instances of a type to check for
equality and enables use of the <code>==</code> and <code>!=</code> operators.</p>
<p>Deriving <code>PartialEq</code> implements the <code>eq</code> method. When <code>PartialEq</code> is derived on
structs, two instances are equal only if <em>all</em> fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.</p>
<p>The <code>PartialEq</code> trait is required, for example, with the use of the
<code>assert_eq!</code> macro, which needs to be able to compare two instances of a type
for equality.</p>
<p>The <code>Eq</code> trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The <code>Eq</code> trait can only be
applied to types that also implement <code>PartialEq</code>, although not all types that
implement <code>PartialEq</code> can implement <code>Eq</code>. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (<code>NaN</code>) value are not equal to each other.</p>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the
<code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</p>
<a class="header" href="#partialord-and-ord-for-ordering-comparisons" id="partialord-and-ord-for-ordering-comparisons"><h3><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons</h3></a>
<p>The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting
purposes. A type that implements <code>PartialOrd</code> can be used with the <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, and <code>&gt;=</code> operators. You can only apply the <code>PartialOrd</code> trait to types
that also implement <code>PartialEq</code>.</p>
<p>Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an
<code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don’t produce an
ordering. An example of a value that doesn’t produce an ordering, even though
most values of that type can be compared, is the not-a-number (<code>NaN</code>) floating
point value. Calling <code>partial_cmp</code> with any floating point number and the <code>NaN</code>
floating point value will return <code>None</code>.</p>
<p>When derived on structs, <code>PartialOrd</code> compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.</p>
<p>The <code>PartialOrd</code> trait is required, for example, for the <code>gen_range</code> method
from the <code>rand</code> crate that generates a random value in the range specified by a
low value and a high value.</p>
<p>The <code>Ord</code> trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The <code>Ord</code> trait implements the <code>cmp</code> method,
which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid
ordering will always be possible. You can only apply the <code>Ord</code> trait to types
that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>). When
derived on structs and enums, <code>cmp</code> behaves the same way as the derived
implementation for <code>partial_cmp</code> does with <code>PartialOrd</code>.</p>
<p>An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>,
a data structure that stores data based on the sort order of the values.</p>
<a class="header" href="#clone-and-copy-for-duplicating-values" id="clone-and-copy-for-duplicating-values"><h3><code>Clone</code> and <code>Copy</code> for Duplicating Values</h3></a>
<p>The <code>Clone</code> trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See the “Ways Variables and Data Interact: Clone” section in Chapter 4
for more information on <code>Clone</code>.</p>
<p>Deriving <code>Clone</code> implements the <code>clone</code> method, which when implemented for the
whole type, calls <code>clone</code> on each of the parts of the type. This means all the
fields or values in the type must also implement <code>Clone</code> to derive <code>Clone</code>.</p>
<p>An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a
slice. The slice doesn’t own the type instances it contains, but the vector
returned from <code>to_vec</code> will need to own its instances, so <code>to_vec</code> calls
<code>clone</code> on each item. Thus, the type stored in the slice must implement <code>Clone</code>.</p>
<p>The <code>Copy</code> trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See the “Stack-Only Data: Copy”
section in Chapter 4 for more information on <code>Copy</code>.</p>
<p>The <code>Copy</code> trait doesn’t define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.</p>
<p>You can derive <code>Copy</code> on any type whose parts all implement <code>Copy</code>. You can
only apply the <code>Copy</code> trait to types that also implement <code>Clone</code>, because a
type that implements <code>Copy</code> has a trivial implementation of <code>Clone</code> that
performs the same task as <code>Copy</code>.</p>
<p>The <code>Copy</code> trait is rarely required; types that implement <code>Copy</code> have
optimizations available, meaning you don’t have to call <code>clone</code>, which makes
the code more concise.</p>
<p>Everything possible with <code>Copy</code> you can also accomplish with <code>Clone</code>, but the
code might be slower or have to use <code>clone</code> in places.</p>
<a class="header" href="#hash-for-mapping-a-value-to-a-value-of-fixed-size" id="hash-for-mapping-a-value-to-a-value-of-fixed-size"><h3><code>Hash</code> for Mapping a Value to a Value of Fixed Size</h3></a>
<p>The <code>Hash</code> trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
<code>Hash</code> implements the <code>hash</code> method. The derived implementation of the <code>hash</code>
method combines the result of calling <code>hash</code> on each of the parts of the type,
meaning all fields or values must also implement <code>Hash</code> to derive <code>Hash</code>.</p>
<p>An example of when <code>Hash</code> is required is in storing keys in a <code>HashMap&lt;K, V&gt;</code>
to store data efficiently.</p>
<a class="header" href="#default-for-default-values" id="default-for-default-values"><h3><code>Default</code> for Default Values</h3></a>
<p>The <code>Default</code> trait allows you to create a default value for a type. Deriving
<code>Default</code> implements the <code>default</code> function. The derived implementation of the
<code>default</code> function calls the <code>default</code> function on each part of the type,
meaning all fields or values in the type must also implement <code>Default</code> to
derive <code>Default</code>.</p>
<p>The <code>Default::default</code> function is commonly used in combination with the struct
update syntax discussed in the “Creating Instances From Other Instances With
Struct Update Syntax” section in Chapter 5. You can customize a few fields of a
struct and then set and use a default value for the rest of the fields by using
<code>..Default::default()</code>.</p>
<p>The <code>Default</code> trait is required when you use the method <code>unwrap_or_default</code> on
<code>Option&lt;T&gt;</code> instances, for example. If the <code>Option&lt;T&gt;</code> is <code>None</code>, the method
<code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type
<code>T</code> stored in the <code>Option&lt;T&gt;</code>.</p>
<a class="header" href="#appendix-d---useful-development-tools" id="appendix-d---useful-development-tools"><h1>Appendix D - Useful Development Tools</h1></a>
<p>In this appendix, we’ll talk about tools provided by the Rust project that are
useful when developing Rust code.</p>
<a class="header" href="#automatic-formatting-with-rustfmt" id="automatic-formatting-with-rustfmt"><h2>Automatic Formatting with <code>rustfmt</code></h2></a>
<p>The tool <code>rustfmt</code> reformats your code according to the community code style.
Many projects use <code>rustfmt</code> to prevent arguments about which style to use when
writing Rust: everyone formats their code with the tool!</p>
<p>The <code>rustfmt</code> tool is not yet at the quality of a version 1.0 release, but
a preview is available for you to use in the meantime. Please give it a try and
let us know how it goes!</p>
<p>To install <code>rustfmt</code>:</p>
<pre><code class="language-text">$ rustup component add rustfmt-preview
</code></pre>
<p>This will give you both <code>rustfmt</code> and <code>cargo-fmt</code>, similar to how Rust gives
you both <code>rustc</code> and <code>cargo</code>. To take any Cargo project and format it:</p>
<pre><code class="language-text">$ cargo fmt
</code></pre>
<p>Running this command will reformat all of the Rust code in the current crate.
This should only change the code style, not the code semantics. For more
information on <code>rustfmt</code>, see <a href="https://github.com/rust-lang-nursery/rustfmt">its documentation</a>.</p>
<a class="header" href="#fix-up-your-code-with-rustfix" id="fix-up-your-code-with-rustfix"><h2>Fix Up Your Code with <code>rustfix</code></h2></a>
<p>If you’ve written code in Rust, you’ve probably seen compiler warnings. For
example, consider this code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Here, we’re calling the <code>do_something</code> function 100 times, but we never use the
variable <code>i</code> in the body of the <code>for</code> loop. Rust warns us about that:</p>
<pre><code class="language-text">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>The warning suggests that we use <code>_i</code> as a name instead: the underscore
indicates that we intend for this variable to be unused. We can automatically
apply that suggestion using the <code>rustfix</code> tool by running the command <code>cargo fix</code>:</p>
<pre><code class="language-text">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>If we look at <em>src/main.rs</em> again, we’ll see that <code>cargo fix</code> has changed the
code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>The <code>for</code> loop variable is now named <code>_i</code>, and the warning will no longer
appear.</p>
<p>The <code>cargo fix</code> command can also be used to transition your code between
different editions of Rust. Editions are covered in Appendix E.</p>
<a class="header" href="#more-lints-with-clippy" id="more-lints-with-clippy"><h2>More Lints with <code>clippy</code></h2></a>
<p>The <code>clippy</code> tool is a collection of lints to catch common mistakes and improve
your Rust code.</p>
<p>The <code>clippy</code> tool is not yet at the quality of a version 1.0 release, but a
preview is available for you to use in the meantime. Please give it a try and
let us know how it goes!</p>
<p>To install <code>clippy</code>:</p>
<pre><code class="language-text">$ rustup component add clippy-preview
</code></pre>
<p>To take any Cargo project and run clippy’s lints on it:</p>
<pre><code class="language-text">$ cargo clippy
</code></pre>
<p>For example, if you write a program that uses an approximation of a
mathematical constant such as pi, as this program does:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Running <code>cargo clippy</code> on this project will result in this error:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/v0.0.212/index.html#approx_constant
</code></pre>
<p>This lets you know that Rust has this constant defined more precisely, and that
your program would be more correct if you used the constant instead. This code
doesn’t result in any errors or warnings from <code>clippy</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>For more information on <code>clippy</code>, see <a href="https://github.com/rust-lang-nursery/rust-clippy">its documentation</a>.</p>
<a class="header" href="#ide-integration-using-the-rust-language-server" id="ide-integration-using-the-rust-language-server"><h2>IDE Integration Using the Rust Language Server</h2></a>
<p>To help IDE integration, the Rust project distributes the <code>rls</code>, which stands
for the Rust Language Server. This tool speaks the <a href="http://langserver.org/">Language Server
Protocol</a>, which is a specification for IDEs and programming languages to
communicate with each other. The <code>rls</code> can be used by different clients, such
as <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">the Rust plugin for Visual Studio: Code</a>.</p>
<p>The <code>rls</code> is not yet at the quality of a version 1.0 release, but a preview is
available for you to use in the meantime. Please give it a try and let us know
how it goes!</p>
<p>To install the <code>rls</code>:</p>
<pre><code class="language-text">$ rustup component add rls-preview
</code></pre>
<p>Then install the language server support in your particular IDE, and you will
gain abilities such as autocompletion, jump to definition, and inline errors.</p>
<p>For more information on the <code>rls</code>, see <a href="https://github.com/rust-lang-nursery/rls">its documentation</a>.</p>
<a class="header" href="#appendix-e---editions" id="appendix-e---editions"><h1>Appendix E - Editions</h1></a>
<p>Way back in Chapter 1, we saw that <code>cargo new</code> adds a bit of metadata to your
<em>Cargo.toml</em> about an <code>edition</code>. This appendix talks about what that means!</p>
<p>The Rust language and compiler have a six-week release cycle. This means users
get a constant stream of new features. Other programming languages release
larger changes less often; Rust chooses to release smaller updates more
frequently. After a while, all of those tiny changes add up. But from release
to release, it can be hard to look back and say “Wow, between Rust 1.10 and
Rust 1.31, Rust has changed a lot!”</p>
<p>Every two or three years, the Rust team produces a new <em>edition</em> of Rust.
Each edition brings together the features that have landed into a clear
package with fully updated documentation and tooling. New editions ship
as part of the usual six-week release process.</p>
<p>This serves different purposes for different people:</p>
<ul>
<li>For active Rust users, it brings together incremental changes into an
easy-to-understand package.</li>
<li>For non-users, it signals that some major advancements have landed, which
might make Rust worth another look.</li>
<li>For those developing Rust itself, it provides a rallying point for the
project as a whole.</li>
</ul>
<p>At the time of writing, there are two editions: Rust 2015 and Rust 2018.
This book is written using Rust 2018 edition idioms.</p>
<p>The <code>edition</code> key in <em>Cargo.toml</em> indicates which edition your code should be
compiled under. If the key does not exist, it defaults to <code>2015</code> for backwards
compatibility reasons.</p>
<p>Each project can choose to opt in to an edition other than the default 2015
edition. By doing so, editions can contain incompatible changes, such as adding
a new keyword that might conflict with identifiers in code or turning warnings
into errors. But unless you opt in to those changes, your code will continue to
compile even as you upgrade the version of the Rust compiler that you use. All
Rust compiler versions support any edition that existed prior to that
compiler’s release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if you’re using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.</p>
<p>To be clear: most features will be available on all editions. Developers using
any edition of Rust will continue to see improvements as new stable releases
are made. In some cases, however, mainly when new keywords are added, there may
be new features that are only available in later editions. You only need to
switch editions if you want to take advantage of such features.</p>
<p>For more details, the <a href="https://rust-lang-nursery.github.io/edition-guide/">Edition
Guide</a> is a complete
book about editions, including how to automatically upgrade your code to
a new edition via <code>cargo fix</code>.</p>
<a class="header" href="#appendix-f-translations-of-the-book" id="appendix-f-translations-of-the-book"><h2>Appendix F: Translations of the Book</h2></a>
<p>For resources in languages other than English. Most are still in progress; see
<a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">the Translations label</a> to help or let us know about a new translation!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/hngnaig/rust-lang-book/tree/vi-VN">Tiếng việt</a></li>
<li><a href="http://www.broadview.com.cn/article/144">简体中文</a>, <a href="https://github.com/KaiserY/trpl-zh-cn">alternate</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/iDeBugger/rust-book-ru">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/hazama-yuinyan/book">日本語</a></li>
<li><a href="https://github.com/quadrifoglio/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
</ul>
<a class="header" href="#appendix-g---how-rust-is-made-and-nightly-rust" id="appendix-g---how-rust-is-made-and-nightly-rust"><h1>Appendix G - How Rust is Made and “Nightly Rust”</h1></a>
<p>This appendix is about how Rust is made and how that affects you as a Rust
developer.</p>
<a class="header" href="#stability-without-stagnation" id="stability-without-stagnation"><h3>Stability Without Stagnation</h3></a>
<p>As a language, Rust cares a <em>lot</em> about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can’t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.</p>
<p>Our solution to this problem is what we call “stability without stagnation”,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.</p>
<a class="header" href="#choo-choo-release-channels-and-riding-the-trains" id="choo-choo-release-channels-and-riding-the-trains"><h3>Choo, Choo! Release Channels and Riding the Trains</h3></a>
<p>Rust development operates on a <em>train schedule</em>. That is, all development is
done on the <code>master</code> branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three <em>release channels</em> for Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.</p>
<p>Here’s an example of how the development and release process works: let’s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the <code>master</code>
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Every six weeks, it’s time to prepare a new release! The <code>beta</code> branch of the
Rust repository branches off from the <code>master</code> branch used by nightly. Now,
there are two releases:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there’s still a nightly release every night:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Let’s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to <code>master</code>, so that nightly is fixed, and then the fix is backported to the
<code>beta</code> branch, and a new release of beta is produced:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Six weeks after the first beta was created, it’s time for a stable release! The
<code>stable</code> branch is produced from the <code>beta</code> branch:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the <em>next</em> version of Rust, 1.6.
So after <code>stable</code> branches off of <code>beta</code>, the next version of <code>beta</code> branches
off of <code>nightly</code> again:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>This is called the “train model” because every six weeks, a release “leaves the
station”, but still has to take a journey through the beta channel before it
arrives as a stable release.</p>
<p>Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it’s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there’s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.</p>
<p>Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it’s easy to upgrade to: if a beta release doesn’t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
<code>rustc</code> is still a piece of software, and bugs do exist.</p>
<a class="header" href="#unstable-features" id="unstable-features"><h3>Unstable Features</h3></a>
<p>There’s one more catch with this release model: unstable features. Rust uses a
technique called “feature flags” to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
<code>master</code>, and therefore, in nightly, but behind a <em>feature flag</em>. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.</p>
<p>If you’re using a beta or stable release of Rust, you can’t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won’t break. Stability without stagnation.</p>
<p>This book only contains information about stable features, as in-progress
features are still changing, and surely they’ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.</p>
<a class="header" href="#rustup-and-the-role-of-rust-nightly" id="rustup-and-the-role-of-rust-nightly"><h3>Rustup and the Role of Rust Nightly</h3></a>
<p>Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you’ll have stable Rust installed. To
install nightly, for example:</p>
<pre><code class="language-text">$ rustup install nightly
</code></pre>
<p>You can see all of the <em>toolchains</em> (releases of Rust and associated
components) you have installed with <code>rustup</code> as well. Here’s an example on one
of your authors’ Windows computer:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use <code>rustup override</code> in that project’s directory to set the
nightly toolchain as the one <code>rustup</code> should use when you’re in that directory:</p>
<pre><code class="language-text">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Now, every time you call <code>rustc</code> or <code>cargo</code> inside of
<em>~/projects/needs-nightly</em>, <code>rustup</code> will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!</p>
<a class="header" href="#the-rfc-process-and-teams" id="the-rfc-process-and-teams"><h3>The RFC Process and Teams</h3></a>
<p>So how do you learn about these new features? Rust’s development model follows
a <em>Request For Comments (RFC) process</em>. If you’d like an improvement in Rust,
you can write up a proposal, called an RFC.</p>
<p>Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There’s
a full list of the teams <a href="https://www.rust-lang.org/en-US/team.html">on Rust’s
website</a>, which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there’s consensus to accept or reject the feature.</p>
<p>If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the <code>master</code> branch behind a feature gate, as we discussed
in the “Unstable Features” section.</p>
<p>After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it’s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
