## UTF-8でエンコードされた文字列を格納する

第4章で文字列について説明しましたが、ここではそれらをさらに詳しく見ていきます。可能性のあるエラーを表示するためのRustの傾向、多くのプログラマーが信用できるデータ構造よりも複雑な文字列、UTF-8の3つの理由のため、新しいRust開発者は一般的に文字列に固執します。これらの要素は、他のプログラミング言語から来ているときには難しいように見えます。

文字列はバイトの集合として実装されているので、コレクションのコンテキストで文字列を議論すると便利です。さらに、これらのバイトがテキストとして解釈されるときに便利な機能を提供するいくつかのメソッドがあります。このセクションでは、作成、更新、および読み込みなど、すべてのコレクション型が持つ`String`の操作について説明します。`String`が他のコレクションとどのように異なっているか、すなわち`String`への索引付けが人とコンピュータが`String`データをどのように解釈するかの違いによってどのように複雑になるかを議論します。

### 文字列とは？

最初に、*string*という用語の意味を定義します。Rustはコア言語では文字列型が1つしかありません。これは、通常は借用された形式の`&str`で見られる文字列スライス`str`です。第4章では、他の場所に格納されたUTF-8でエンコードされた文字列データへの参照である*文字列スライス*について説明しました。たとえば、文字列リテラルはプログラムのバイナリ出力に格納されるため、文字列スライスです。

コア言語にコード化されるのではなく、Rustの標準ライブラリによって提供される`String`型は、拡張可能で、変更可能な、所有されたUTF-8でエンコードされた文字列型です。Rust開発者がRustの"strings"を参照するとき、それらは通常、それらの型の1つだけではなく、`String`型と文字列slice`&str`型を意味します。このセクションは主に`String`について書かれていますが、どちらのタイプもRustの標準ライブラリで頻繁に使用されています。また、`String`と文字列スライスの両方がUTF-8でエンコードされています。

Rustの標準ライブラリには、`OsString`、`OsStr`、`CString`、`CStr`といった他の多くの文字列型も含まれています。ライブラリのテンプレートは、文字列データを格納するためのさらに多くのオプションを提供します。それらの名前が`String`や`Str`でどのように終わるかを見てください。以前に見た`String`や`str`のように、所有し、借用しているバリアントを参照します。 これらの文字列型は、異なるエンコーディングでテキストを格納したり、異なる方法でメモリに表現することができます。この章では、他の文字列型については説明しません。APIの使用方法とそれぞれが適切な場合のAPIドキュメントを参照してください。

### 新しい文字列の作成

リスト8-11に示す`Vec<T>`で利用可能な操作の多くは、文字列を作成する`new`関数から始まる`String`でも利用できます。

```rust
let mut s = String::new();
```

<span class="caption">リスト 8-11: 新しい空の`String`を作成する</span>

この行は、`s`という新しい空文字列を作成し、データを読み込むことができます。多くの場合、文字列を開始する初期データがあります。そのためには、文字列リテラルのように、`Display`トレイトを実装する任意の型で利用できる`to_string`メソッドを使用します。リスト8-12に2つの例を示します。

```rust
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
```

<span class="caption">リスト 8-12: `to_string`メソッドを使って文字列リテラルから` String`を作成する</span>

このコードは `initial contents`を含む文字列を作成します。

文字列リテラルから`String`を生成するために`String::from`関数を使うこともできます。リスト8-13のコードは、リスト8-12のコードに`to_string`を使用したコードに相当します。

```rust
let s = String::from("initial contents");
```

<span class="caption">リスト 8-13: `String::from`関数を使って文字列リテラルから`String`を作成する</span>

文字列は非常に多くのものに使用されているため、文字列にはさまざまな汎用APIを使用でき、多くのオプションが用意されています。それらのいくつかは冗長に見えるかもしれませんが、彼らはすべて自分の場所を持っています。この場合、`String::from`と`to_string`は同じことをするので、どちらを選んでもかまいません。

文字列はUTF-8でエンコードされているので、リスト8-14に示すように、適切にエンコードされたデータをエンコードすることができます。

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```

<span class="caption">リスト 8-14: 文字列の異なる言語での挨拶の保存</span>

これらはすべて有効な `String`値です。

### 文字列の更新

`Vec<T>`の内容と同じように、`String`のサイズが大きくなり、内容を変更することができます。さらに、`+`演算子や `format!`マクロを使うと、`String`値を連結することができます。

#### `push_str`と` push`を使って文字列に追加する

リスト8-15に示すように、文字列スライスを追加するために`push_str`メソッドを使って`String`を拡張することができます。

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

<span class="caption">リスト 8-15: `push_str`メソッドを使って文字列スライスを`String`に追加する</span>

これらの2行の後に、`s`は`foobar`を含みます。`push_str`メソッドは文字列スライスを取るので、必ずしも引数の所有権を取る必要はありません。例えば、リスト8-16のコードでは内容を`s1`に追加した後に`s2`を使用できます。
```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {}", s2);
```

<span class="caption">リスト 8-16: 文字列スライスの内容を `String`に追加した後で使用する</span>

`push_str`メソッドが`s2`の所有権を取った場合、最後の行にその値を出力することはできません。しかし、このコードは期待どおりに動作します。

`push`メソッドは引数として単一の文字をとり、それを`String`に追加します。コードリスト8-17は`push`メソッドを使って`String`に文字lを追加するコードを示しています：

```rust
let mut s = String::from("lo");
s.push('l');
```

<span class="caption">リスト 8-17: `push`を使って`String`値に一つの文字を追加する</span>

このコードの結果として、`s`は`lol`を含みます。

#### `+`演算子や`format!`マクロとの連結

しばしば、2つの既存の文字列を結合したいと思うでしょう。1つの方法は、リスト8-18に示すように、`+`演算子を使うことです。

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // Note s1 has been moved here and can no longer be used
```

<span class="caption">Listing 8-18: `+`演算子を使って2つの`String`値を新しい`String`値に結合します</span>

文字列`s3`はこのコードの結果として`Hello、world!`を含みます。なぜなら`s1`は加算の後にもはや有効でなく、`s2`への参照を使用した理由は、`+`演算子を使用したときに呼び出されるメソッドのシグニチャと関係しているからです。`+`演算子は `add`メソッドを使います。そのシグニチャは次のようになります。

```rust,ignore
fn add(self, s: &str) -> String {
```

これは標準ライブラリにある正確な署名ではありません。標準ライブラリでは、`add`はジェネリックを使って定義されています。ここでは、一般的なものに代わる具体的な型の`add`のシグニチャを見ています。これは、このメソッドを`String`値で呼び出すときに起こります。第10章でジェネリックについて説明します。このシグニチャは、`+`演算子のトリッキーなビットを理解するために必要な手がかりを与えてくれます。

まず、`s2`は`&`を持ちます。つまり、`add`関数の`s`引数のために、2番目の文字列の*参照*を最初の文字列に追加しています。`&str`を`String`に変換します。2つの`String`値を一緒に追加することはできません。`&s2`の型は、`&str`ではなく、`add`への2番目の引数で指定された`&String`です。なぜ、リスト8-18はコンパイルされるのでしょうか？

`add`の呼び出しで`&s2`を使うことができるのは、コンパイラが`&String`引数を`&str`に強制することができるからです。 `add`メソッドを呼び出すと、Rustは*deref強制*を使用します。ここで`&s2`は`&s2[..]`になります。第15章でより深く説明します。`add`は`s`引数の所有権を取らないので、`s2`はこの操作の後でも有効な`String`です。

次に、`self`は`&`を持たないので、`add`は`self`の所有権を取ります。これは、リスト8-18の`s1`が`add`コールに移動し、それ以降は無効になることを意味します。したがって、`s3 = s1 + &s2;`は両方の文字列をコピーして新しい文字列を作成するように見えますが、実際に、`s1`の所有権を取得し`s2`の内容のコピーを追加し、その後の所有権を返します。言い換えれば、それはコピーをたくさん作っているように見えますが、そうではありません。実装はコピーよりも効率的です。

複数の文字列を連結する必要がある場合、`+`演算子の動作は扱いにくくなります。

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

この時点で、`s`は`tic-tac-toe`になります。 `+`と`"`の文字はすべて、何が起こっているのかを見るのは難しいです。複雑な文字列を組み合わせるには、`format！`マクロを使うことができます。

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
```

このコードは`s`を`tic-tac-toe`に設定します。`format!`マクロは`println!`と同じように動作しますが、出力を画面に出力するのではなく、その内容を含む`String`を返します。`format!`を使ったコードのバージョンははるかに読みやすく、その引数の所有権を取ることはありません。

### ストリングへの索引付け

他の多くのプログラミング言語では、文字列内の個々の文字にインデックスで参照してアクセスすることは、有効かつ一般的な操作です。しかし、Rustの索引構文を使用して`String`の部分にアクセスしようとすると、エラーが発生します。リスト8-19の無効なコードを考えてみましょう。

```rust,ignore,does_not_compile
let s1 = String::from("hello");
let h = s1[0];
```

<span class="caption">リスト 8-19: 文字列でIndex構文を使用しようとする</span>

このコードでは、次のエラーが発生します。

```text
error[E0277]: the trait bound `std::string::String: std::ops::Index<{integer}>` is not satisfied
 -->
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index<{integer}>` is not implemented for `std::string::String`
```

エラーとノートはストーリーに伝えます。Rust文字列はインデックス作成をサポートしていません。しかし、どうしてですか？ その質問に答えるために、Rustが文字列をメモリにどのように格納するかについて議論する必要があります。

#### 内部表現

`String`は`Vec<u8>`のラッパーです。リスト8-14の適切にエンコードされたUTF-8のサンプル・ストリングのいくつかを見てみましょう。

```rust
let len = String::from("Hola").len();
```

この場合、lenは4であり、これは文字列"Hola"を格納するベクトルが4バイト長であることを意味する。これらの文字のそれぞれは、UTF-8でエンコードされたときに1バイトをとります。しかし、次の行はどうでしょうか？（この行は、アラビア数字3ではなく、キリル文字Zeで始まることに注意してください）

```rust
let len = String::from("Здравствуйте").len();
```

Rustの答えは24です。これは、文字列の各Unicodeスカラー値が2バイトの記憶域を取るため、UTF-8で"文字列をエンコードする"バイト数です。したがって、文字列のバイトへのインデックスは、有効なUnicodeスカラー値と必ずしも相関しません。実証するために、この無効な錆のコードを考えてみましょう。

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

`answer`の値はどうあるべきでしょう？最初の文字は`З`でしょうか？UTF-8でエンコードされている場合、`З`の最初のバイトは`208`で、二番目のバイトは`151`です。したがって、`answer`は実際には`208`ですが、`208`はそれ自身で有効な文字ではありません。`208`を返すことは、ユーザーがこの文字列の最初の文字を尋ねた場合、ユーザーが望むものではない可能性があります。しかし、それはRustがバイトインデックス0で持つ唯一のデータです。文字列にラテン文字だけが含まれていても、一般的には返されるバイト値は望ましくありません。`&"hello"[0]`が`h`ではなく`104`を返します。予期しない値を返さず、直ちに発見されない可能性のあるバグを引き起こさないように、Rustはこのコードをまったくコンパイルせず、開発プロセスの初期段階で誤解を防止します。

#### バイトとスカラの値とグレーフェームクラスタ

UTF-8についてのもう一つの点は、実際にはRustの観点から、文字列をバイト、スカラー値、および文字列クラスター（*文字*と呼ぶものに最も近いもの）として見るための3つの関連する方法があるということです。

Devanagariスクリプトに書かれたヒンディー語の"नमस्ते"を見ると、これは次のような`u8`値のベクトルとして格納されます。

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

これは18バイトで、コンピュータが最終的にこのデータをどのように格納するかです。Rustの`char`型のUnicodeスカラー値として見れば、それらのバイトは次のようになります。

```text
['न', 'म', 'स', '्', 'त', 'े']
```

ここには6つの`char`値がありますが、第4と第6は文字ではありません。それは特に意味をなさない発音区別記号です。最後に、それらを書記官クラスターとして見ると、ヒンズー語を構成する4つの文字を人が何と呼ぶかを知ることができます。

```text
["न", "म", "स्", "ते"]
```

Rustはデータがどのような人間言語であっても、各プログラムが必要とする解釈を選択できるように、コンピュータが格納する生の文字列データを解釈するさまざまな方法を提供します。

Rustの最終的な理由は、文字列を取得するために`String`にインデックスを付けることができないということです。なぜなら、インデックス処理は常に一定の時間(0(1))を取ることが予想されるからです。しかし、Rustは有効な文字がいくつあるのかを判断するために、最初からインデックスまで内容を通らなければならないので、`String`でそのパフォーマンスを保証することはできません。

### スライシング文字列

文字列インデクシング操作の戻り値の型は、バイト値、文字、グラフェンクラスター、または文字列スライスのどれであるべきかが明確でないため、文字列へのインデックス付けはしばしば悪い考えです。したがって、実際にインデックスを使用して文字列スライスを作成する必要がある場合、Rustはより具体的になるように指示します。具体的にはインデックス作成で文字列スライスが必要であることを示すには、単一の数値で`[]`を使用してインデックスを作成するのではなく、`[]`を使用して範囲を指定して特定のバイトを含む文字列スライスを作成します。

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

ここで、`s`は文字列の最初の4バイトを含む`&str`です。以前は、これらの文字のそれぞれが2バイトであることに言及しました。これは`s`が`Зд`であることを意味します。

`&hello [0..1]`を使うとどうなりますか？答えはvectorで無効なインデックスがアクセスされたのと同じ方法で、実行時にRustがパニックに陥ります。

```text
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
```

文字列スライスを作成するには、プログラムをクラッシュさせる可能性があるため、範囲を使用して慎重に文字列スライスを作成する必要があります。

### 文字列を反復処理するための方法

文字列内の要素には他の方法でアクセスできます。

個々のUnicodeスカラー値に対して操作を行う必要がある場合は、`chars`メソッドを使用するのが最良の方法です。"नमस्ते"で `chars`を呼び出すと、`char`型の6つの値が分離され、各要素にアクセスするために結果を繰り返し処理できます。

```rust
for c in "नमस्ते".chars() {
    println!("{}", c);
}
```

このコードは以下を出力します。

```text
न
म
स
्
त
े
```

`bytes`メソッドはドメインにふさわしいかもしれない生のバイトを返します。

```rust
for b in "नमस्ते".bytes() {
    println!("{}", b);
}
```

このコードは、この `String`を構成する18バイトを出力します。

```text
224
164
// --snip--
165
135
```

しかし、有効なUnicodeスカラ値は1バイト以上で構成されることを覚えておいてください。

文字列から書記素クラスタを得ることは複雑なので、この機能は標準ライブラリでは提供されていません。この機能が必要な場合は、 [crates.io](https://crates.io)でcrateを利用できます

### 文字列は単純ではありません

まとめると、文字列は複雑です。異なるプログラミング言語は、この複雑さをどのようにプログラマに提示するかについて異なる選択をします。RustはすべてのRustプログラムのデフォルトの動作である`String`データの正しい処理を行うことを選択しました。これは、プログラマがUTF-8データを先に処理することをもっと考慮する必要があることを意味します。このトレードオフは、他のプログラミング言語よりも複雑なストリングを提供しますが、開発ライフサイクルの後半で非ASCII文字を含むエラーを処理する必要がなくなります。

