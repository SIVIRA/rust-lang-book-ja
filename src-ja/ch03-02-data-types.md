## データ型

Rustのすべての値は特定の*データ型*であり、指定されているデータの種類をRustに知らせるので、そのデータの処理方法を知ることができます。スカラーと複合体の2つのデータ型サブセットを見ていきます。

Rustは*静的に型指定された*言語であることに注意してください。つまり、コンパイル時にすべての変数の型を知っている必要があります。コンパイラは、通常、値と使用方法に基づいて使用する型を推論することができます。第2章で `parse`を使って`String`を数値型に変換したときなど、多くの型が可能な場合には、このような型名を追加する必要があります ：

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

ここで型を追加しないと、Rustは次のエラーを表示します。これは、コンパイラが使用したいタイプを知るためにより多くの情報を必要とすることを意味します。

```text
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```

他のデータ型には異なるタイプの注釈が表示されます。

### スカラ型

 *スカラー*型は単一の値を表します。Rustには、整数、浮動小数点数、ブール値、および文字の4つの主なスカラ型があります。これらは他のプログラミング言語から認識されるかもしれません。それらがRustでどのように働いているかを考えてみましょう。

#### 整数型

*integer*は小数成分のない数値です。第2章では1つの整数型、`u32`型を使用しました。この型宣言は、関連する値が32ビットの空間を占める符号なし整数（符号付き整数型は `u`ではなく`i`で始まる）でなければならないことを示します。表3-1に、Rustの組み込み整数型を示します。「符号付き」列と「符号なし」列の各バリアント（たとえば、`i16`）を使用して、整数値の型を宣言できます。

<span class="caption">表3-1: Rustの数値型</span>

| Length  | Signed  | Unsigned |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

各バリアントは、符号付きまたは符号なしのいずれかであり、明示的なサイズを持ちます。*符号付き*と*符号なし*は、数値が負であるか正であるかを参照します。つまり、数値に符号を付ける必要があるか（符号付き）、それとも正であるかどうか 符号なしで表される（符号なし）。それは紙に数字を書くようなものです。記号が重要なときはプラス記号またはマイナス記号で数字が表示されます。しかし、数字が正であると仮定することは安全ですが、それは記号なしで示されます。符号付き数値は、2の補数表現を使用して格納されます（これが何であるかわからない場合は、オンラインで検索できますが説明は本書の範囲外です）。

各符号付きバリアントは、 -(2<sup>n - 1</sup>)から2<sup>n - 1</sup> - 1までの数値を格納できます。*n*は、バリアントが使用するビット数です。したがって、`i8`は - (2 <sup> 7 </sup>)から2<sup>7</sup> - 1までの数を保存できます。これは-128〜127になります。 <sup>n</sup> - 1であるので、`u8`は0から255までの数字を格納することができます。

さらに、`isize`と`usize`の型は、あなたのプログラムが動作しているコンピュータの種類によって異なります。64ビットアーキテクチャの場合は64ビット、32ビットアーキテクチャの場合は32ビットです。

表3-2に示すいずれかの形式で整数リテラルを記述することができます。バイトリテラル以外のすべての数値リテラルは、型接尾辞`57u8`を許可し、`_`は視覚的区切り文字として`1_000`などを許すことに注意してください。

<span class="caption">表 3-2: Rustの整数リテラル</span>

| Number literals  | Example       |
|------------------|---------------|
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |

どのようなタイプの整数を使うべきでしょうか？ もし確信が持てないなら、Rustのデフォルトは一般的に良い選択肢です（整数型のデフォルトは`i32`です）。このタイプは、64ビットシステムでさえ一般的に最も速いです。`isize`や`usize`を使う主な状況は何らかのコレクションのインデックスを作るときです。

##### 整数オーバーフロー

`u8`を持っていて、0と255の間の値を保持できるとしましょう。`256 'に変更しようとするとどうなりますか？これは 「整数オーバーフロー」と呼ばれ、Rustはこの振る舞いに関するいくつかの興味深い規則を持っています。デバッグモードでコンパイルすると、Rustはこの種の問題をチェックし、プログラムがエラーで終了したときにRustが使う*panic*を引き起こします。panicについては、第9章で詳しく説明します。

リリースビルドでは、Rustはオーバーフローをチェックせず、代わりに「2の補数ラッピング」と呼ばれるものを実行します。つまり、`256`は`0`に、`257`は`1`になります。オーバーフローに依存するのは、 この現象が発生した場合でも、エラーが発生します。この振る舞いを明示的にしたいのであれば、標準ライブラリは明示的にそれを提供する`Wrapping`型を持っています。

#### 浮動小数点型

Rustには、小数点を含む数字である*浮動小数点数*の2つのプリミティブ型もあります。Rustの浮動小数点型はそれぞれ32ビットと64ビットの `f32`と`f64`です。現代のCPUでは`f32`とほぼ同じ速度ですが、より精度が高いのでデフォルトの型は`f64`です。

実際の浮動小数点数を示す例です。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮動小数点数は、IEEE-754標準に従って表されます。`f32`型は単精度浮動小数点型で、`f64`型は倍精度です。

#### 数値演算

Rustは、加算、減算、乗算、除算、および剰余のすべての数値タイプに期待される基本的な数学演算をサポートしています。次のコードは `let`文でどのように使うのかを示しています。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```

これらのステートメントの各式は、数学演算子を使用して単一の値に評価され、変数にバインドされます。Appendix Bには、Rustが提供するすべての演算子のリストが含まれています。

#### ブール型


ほとんどの他のプログラミング言語と同様に、Rustのブール型には、2つの値、`true`と` false`があります。Rustのブール型は`bool`を使って指定します。例えば次のように使います。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

ブール値を使用する主な方法は、`if`文のような条件文によるものです。Control Flow"セクションでRustの式がどのように働くかについて説明します。

ブール値は1バイトの大きさです。

#### 文字型

これまでは数字だけで作業していましたが、Rustも文字をサポートしています。 Rustの`char`型は言語の最も原始的なアルファベット型であり、次のコードはそれを使う一つの方法を示しています(`char`リテラルは二重引用符を使用する文字列リテラルではなく、一重引用符で指定されています)。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```

Rustの `char`型はUnicode Scalar Valueを表しています。これはASCIIよりもはるかに多くを表現できることを意味します。アクセント付きの文字(中国語、日本語、韓国語の文字、 絵文字)、 ゼロ幅の空白はすべてRustの有効な`char`値です。Unicodeスカラ値の範囲は、`U + 0000`から`U + D7FF`まで、`U + E000`から`U + 10FFFF`までです。しかし、"文字"は実際にはUnicodeの概念ではないので、人間の"文字"の直感は、Rustのcharと一致しないかもしれません。このトピックについては、第8章の「文字列」で詳しく説明します。

### 複合型

*複合型*は、複数の値を1つの型にグループ化できます。Rustには、タプルと配列の2つの基本的な複合型があります。

#### タプル

タプルはさまざまなタイプのいくつかの値を1つの複合タイプにグループ化する一般的な方法です。タプルの長さは固定されています。一度宣言すると、タプルのサイズが拡大または縮小できません。

タプルはカッコで区切った値のリストをコンマで区切って作成します。タプル内の各位置は型を持ち、タプル内の異なる値の型は同じである必要はありません。この例では、オプションの注釈を追加しました。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

変数tupは、タプルが単一の複合要素とみなされるため、タプル全体にバインドされます。タプルから個々の値を取得するには、パターンマッチングを使用して次のようにタプル値を破棄できます。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

このプログラムは最初にタプルを作成し、それを変数 `tup`にバインドします。次に`let`のパターンを使って`tup`を取り出し、`x`、`y`、 `z`の3つの変数に変換します。これは、単一タプルを3つの部分に分割するため、*destructuring*と呼ばれます。最後に、プログラムは `y`の値、`6.4`を出力します。

パターンマッチングによる構造解除に加えて、アクセスする値のインデックスが続くピリオド(`.`)を使用して、タプル要素に直接アクセスすることができます。例えば次のようにできます。

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

このプログラムはタプル`x`を作成し、そのインデックスを使って要素ごとに新しい変数を作成します。ほとんどのプログラミング言語と同様に、タプルの最初のインデックスは0です。

#### 配列

複数の値のコレクションを持つもう1つの方法は、*配列*です。タプルとは異なり、配列のすべての要素は同じ型でなければなりません。Rustの配列はタプルのように固定長であるため、Rustの配列は他の言語の配列とは異なります。

Rustでは、配列に入る値は角括弧で囲まれたコンマ区切りのリストとして書き出されます。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

配列は、ヒープではなくスタックにデータを割り当てたい場合に便利です(スタックとヒープについては第4章で詳しく説明します)。また、常に固定数の要素を確保したい場合にも便利です。しかし、配列はベクトル型ほど柔軟ではありません。ベクトルは標準ライブラリによって提供される同様のコレクション型であり、サイズの拡大または縮小が許可されています。配列やベクトルを使用するかどうかわからない場合は、おそらくベクトルを使用するべきです。第8章では、ベクトルについて詳しく説明します。

ベクトルではなく配列を使用する場合の例は、月の名前を知る必要があるプログラムにあります。このようなプログラムでは月を追加または削除する必要はほとんどありません。したがって、配列には常に12個の項目が含まれていることがわかっているので、配列を使用できます。

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

配列には面白い型があります。これは次のようになります： `[type; 要素数]`。

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

まず、角括弧があります。配列を作成する構文のように見えます。内部にはセミコロンで区切られた2つの情報があります。1つは、配列の各要素の型です。すべての要素は同じ型であるため、一度リストするだけで済みます。セミコロンの後には、配列の長さを示す数字があります。配列のサイズは固定されているため、配列の要素が変更されても、その数は常に同じです。拡大または縮小できません。


##### 配列要素へのアクセス

配列は、スタックに割り当てられたメモリの単一のチャンクです。次のように、インデックスを使用して配列の要素にアクセスできます。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

この例では、 `first`という名前の変数は配列のインデックス`[0]`の値であるため、値`1`を取得します。 `second`という名前の変数は配列のインデックス`[1]`から値`2`を取得します。


##### 無効な配列要素へのアクセス

配列の最後を過ぎた配列の要素にアクセスしようとするとどうなるでしょうか？例を以下のコードに変更します。コンパイルは実行されますが、実行時にエラーが発生して終了します。

<span class="filename">ファイル名: src/main.rs</span>

```rust,ignore,panics
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

`cargo run`を使用してこのコードを実行すると、次の結果が得られます。

```text
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

コンパイルでエラーは発生しませんでしたが、プログラムは*実行時*エラーとなり、正常に終了しませんでした。インデックスを使用して要素にアクセスしようとすると、指定したインデックスが配列の長さよりも小さいかどうかが確認されます。インデックスが長さより大きい場合、Rustはパニックになります。

これは、Rustの安全原則の最初の実例です。多くの低レベル言語では、このようなチェックは行われず、間違ったインデックスを指定すると無効なメモリにアクセスすることができます。Rustはメモリアクセスを許可し続ける代わりにすぐに終了することで、この種のエラーから守ります。第9章では、Rustのエラー処理の詳細について説明します。