## 変数と変更可能性

第2章で述べたように、デフォルトでは変数は不変です。Rustは、Rustが提供する安全性と容易な並行性を利用してコードを記述するために、多くのポイントの1つです。ただし、変数を変更可能にするオプションはあります。どのように、そしてなぜRustがあなたに不変性を推奨し、なぜ時々オプトアウトを希望するのかを考えましょう。

変数が不変の場合、値が名前にバインドされるとその値を変更することはできません。これを説明するために、*projects*ディレクトリに*variables *という新しいプロジェクトを生成しましょう。

次に、新しい*variables*ディレクトリで、*src/main.rs*を開き、そのコードを次のコードに置き換えます。

<span class="filename">ファイル名: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

`cargo run`を使ってプログラムを保存して実行してください。次の出力に示すように、エラーメッセージが表示されます。

```text
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

この例は、コンパイラがどのようにプログラムのエラーを見つけるのに役立つかを示しています。こプログラムはまだ安全に実行していないことを意味します。

エラーの原因が`immutable variable xに2回割り当てられない`ということです。不変の`x`変数に第2の値を代入しようとしたためです。

このような状況がバグにつながる可能性があるため、以前は不変として指定した値を変更しようとするとコンパイル時エラーが発生することが重要です。コードの一部が変更されず、コードの別の部分がその値を変更すると仮定してコードの一部が動作する場合、コードの最初の部分は設計されたものを実行しない可能性があります。この種のバグの原因は事実の後で追跡するのが難しい場合があります。特にコードの2番目の部分が*時々*変更される場合はそうです。

Rustではコンパイラは、値が変更されないことを宣言すると、実際には変更されないことを保証します。つまり、コードを読み書きしているときに、値と値がどこでどのように変化するかを把握する必要はありません。したがって、そのコードは理性的に簡単です。

しかし、変更可能性は非常に便利です。変数はデフォルトでのみ変更できません。第2章で行ったように、変数名の前に`mut`を追加することでそれらを変更可能にすることができます。この値を変更できることに加えて、`mut`は、コードの他の部分がこの変数値を変更することを示すことによって、将来のコード読者に意図を伝えます。

例えば、*src/main.rs*を次のように変更してみましょう。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

プログラムを実行すると、次のようになります。

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

`mut`を使うとき、`x`が`5`から`6`にバインドする値を変更することができます。場合によっては、変数を変更可能にする必要があります。これは、変数に不変な変数がある場合よりもコードを書く方が便利なためです。

バグの防止に加えて、考慮すべき複数のトレードオフがあります。たとえば、大規模なデータ構造を使用している場合、インスタンスを変更すると、新しく割り当てられたインスタンスをコピーして返すよりも速くなる場合があります。より小さなデータ構造では、新しいインスタンスを作成し、より機能的なプログラミングスタイルで記述することが考えやすくなります。

### 変数と定数の違い

変数の値を変更できない場合は、他のほとんどの言語には*定数*という概念があります。不変変数と同様に、定数は名前にバインドされ、変更が許可されない値ですが、定数と変数の間にはいくつかの違いがあります。

まず、定数で `mut`を使うことは許されません。定数は、デフォルトで不変ではなく、常に不変です。

`let`キーワードの代わりに`const`キーワードを使用して定数を宣言し、値の型に注釈を付ける必要があります。次のセクション「データ型」で型と型名を扱いますので、今のところ詳細を心配しないでください。必ずタイプに注釈を付ける必要があることをご存じですか。

定数はグローバルスコープを含む任意のスコープで宣言することができ、コードの多くの部分が知る必要がある値に便利です。

最後の違いは、定数は関数呼び出しの結果や実行時にのみ計算できる他の値ではなく、定数式にのみ設定できることです。

次に定数の名前が`MAX_POINTS`で、その値が100,000に設定されている定数宣言の例を示します（Rustの定数命名規則では、単語間にアンダースコアを含む大文字を使用し、可読性を高めるためにアンダースコアを数値リテラルに挿入することができます）。

```rust
const MAX_POINTS: u32 = 100_000;
```

定数はプログラムが実行されている間、宣言されたスコープ内で有効です。

プログラム全体で定数として使用されているハードコーディングされた値の名前は、その値の意味を将来のコードのメンテナに伝えるのに便利です。また、ハードコードされた値を将来更新する必要がある場合は、コード内に1つの場所だけを変更して変更する必要があります。

### シャドーイング

第2章で見たように、以前の変数と同じ名前の新しい変数を宣言することができます。新しい変数は前の変数をシャドウします。Rust開発者は、最初の変数は2番目の変数によってシャドーイングされていると言います。つまり、2番目の変数の値は変数が使用されたときの値です。同じ変数の名前を使用し、次のように`let`キーワードの使用を繰り返すことによって、変数をシャドーすることができます。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

このプログラムは最初に`x`を` 5`の値に束縛します。`let x =`を繰り返すことで`x`を陰にし、元の値をとり、`1`を加えると`x`の値は`6`になります。3番目の`let`ステートメントは`x`を影にし、前の値に`2`を掛けて`x`に`12`の最終値を与えます。このプログラムを実行すると、次のものが出力されます。

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

`let`キーワードを使わずにこの変数に誤って再割り当てしようとすると、コンパイル時にエラーが発生するため、シャドウイングは変数を`mut`とマークすることとは異なります。`let`を使うことによって、値に対していくつかの変換を実行できますが、変換が完了した後は変数を不変にすることができます。

`mut`とシャドーイングのもう一つの違いは、`let`キーワードを再び使用するときに効果的に新しい変数を作成するので、同じ名前を再利用することができます。例えば、私たちのプログラムでは、スペース文字を入力することによってテキストの間にいくつのスペースが必要かを表示するようにユーザーに求めていますが、実際にはその入力を数値として保存したいとします。

```rust
let spaces = "   ";
let spaces = spaces.len();
```

この構造体は、最初の`spaces`変数が文字列型で、最初のものと同じ名前を持つまったく新しい変数である`spaces`変数が数値型であるために許可されています。したがって、シャドウイングは`spaces_str`や`spaces_num`のような別の名前を出さなくて済むようにします。代わりに、より単純な `spaces`という名前を再利用することができます。ただし、ここに示すように`mut`を使用しようとすると、コンパイル時エラーが発生します：

```rust,ignore,does_not_compile
let mut spaces = "   ";
spaces = spaces.len();
```

エラーは、変数の型を変更することができないと言っています。

```text
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```

変数がどのように機能するかを調べたので、もっと多くのデータ型を見てみましょう。