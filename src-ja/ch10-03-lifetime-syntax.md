## ライフタイムで参照を有効化する

第4章の「参照と借用」のセクションでは説明しなかった1つの詳細は、Rustのすべての参照にはその参照が有効なスコープである*ライフタイム*があることです。型が推論されるように、ライフタイムも暗黙的に推論されます。複数の型の可能性がある場合、型に注釈を付ける必要があります。同様の方法で、参照の存続期間がいくつか異なる方法で関係する可能性がある場合、ライフタイムに注釈を付ける必要があります。Rustでは、実行時に使用される実際の参照が確実に有効であることを保証するために、ジェネリックなライフタイム引数を使用して関係に注釈を付ける必要があります。

ライフタイムのコンセプトは、他のプログラミング言語のツールとは多少異なります。間違いなく、Rustの最も特徴的な機能です。この章では、ライフタイム全体については触れませんが、ライフタイムの構文に遭遇する可能性のある一般的な方法について説明し、概念に慣れることができます。詳細については、第19章の「高度なライフタイム」の項を参照してください。

### ライフタイムを参照するダングリングの防止

ライフタイムの主な目的は、参照することを意図したデータ以外のデータをプログラムが参照させるダングリング参照を防止することです。外側スコープと内側スコープを持つリスト10-17のプログラムを考えてみましょう。

```rust,ignore,does_not_compile
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

<span class="caption">リスト 10-17: 値がスコープを抜けてしまった参照を使用しようとする</span>

> 注：リスト10-17、10-18、および10-24の例では、変数に初期値を指定せずに変数を宣言しているため、変数名は外部スコープに存在します。一見すると、これはnull値を持たないRustと衝突しているように見えるかもしれません。しかし、変数に値を渡す前に変数を使用しようとすると、コンパイル時エラーが発生します。これは、Rustが実際にnull値を許可しないことを示しています。

外側スコープは`r`という名前の変数を初期値なしで宣言し、内側スコープは`x`という名前の変数を初期値5で宣言します。内側のスコープ内で、`r`の値を`x`への参照にセットしようとしています。それから内側のスコープが終わり、`r`の値を出力しようとしています。`r`が参照している値が使おうとする前にスコープを抜けるので、このコードはコンパイルできません。以下がエラーメッセージです。

```text
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:5
   |
6  |         r = &x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
```

変数`x`は「生存期間が短すぎます」。なぜなら、内部スコープが7行目で終了すると`x`がスコープから外れるからです。しかし `r`は外側スコープに対しても有効です。Rustでこのコードが動くことを許可していたら、`r`は`x`がスコープを抜けた時に解放されるメモリを参照していることになり、`r`で行おうとするいかなることも動かないでしょう。では、どうやってコンパイラはこのコードが無効であると決定しているのでしょうか？*借用精査機(borrow checker)*を使用しています。

### 借用精査機

Rustコンパイラにはスコープを比較してすべての借用が有効かどうかを判断する*借用精査機*があります。リスト10-18は、リスト10-17と同じコードを示していますが、コメントには変数のライフタイムが示されています。

```rust,ignore,does_not_compile
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```

<span class="caption">リスト10-18: それぞれ`'a`と`'b`と名付けられた`r`と`x`のライフタイムのコメント</span>

ここでは、`r`の存続期間を`'a`、`x`の存続期間を`'b`と注釈を付けました。見てわかるように、内側の`'b`ブロックは、外側の`'a`ライフタイムブロックよりもはるかに小さくなっています。コンパイル時に、Rustは2つのライフタイムのサイズを比較して、 `r`は`'a`のライフタイムだけれども、`'b`のライフタイムのメモリを参照していると確認します。`'b`は`'a`よりも短いので、プログラムは拒否されます。参照の被写体が参照ほど長生きしないのです。

リスト10-19はコードを修正して、ダグルな参照がなく、エラーなくコンパイルします。

```rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

<span class="caption">リスト 10-19: データのライフタイムが参照より長いので、有効な参照</span>

ここで、`x`はライフタイム`'b`になり、この場合`'a`よりも大きいです。これはコンパイラは`x`が有効な間、`r`の参照も常に有効になることを把握しているので、`r`は`x`を参照できることを意味します。

参照のライフタイムと、Rustがライフタイムをどのように分析して参照が常に有効になるかを知ったので、関数の文脈で引数と戻り値の一般的なライフタイムを調べてみましょう。

### 関数のジェネリックなライフタイム

2つの文字列スライスのうち長い方を返す関数を記述しましょう。この関数は2つの文字列スライスを取り、文字列スライスを返します。`longest`関数を実装完了後、リスト10-20のコードは`The longest string is abcd`を出力します。

<span class="filename">ファイル名: src/main.rs</span>

```rust,ignore
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

<span class="caption">リスト 10-20: `longest`関数を呼び出して2つの文字列スライスのうち長い方を探す`main`関数</span>

`longest`関数に引数の所有権を奪ってほしくないため、関数が受け取って欲しい引数が文字列スライス、つまり参照であることに注意してください。関数が`String`（変数`string1`に格納されている型）のスライスと、文字列リテラル（変数`string2`に含まれているもの）を受け入れるようにしたいとします。

リスト10-20で使用する引数がなぜ必要なのかについては、第4章の「引数としての文字列スライス」を参照してください。

リスト10-21に示すような `longest`関数を実装しようとすると、コンパイルされません。

<span class="filename">ファイル名: src/main.rs</span>

```rust,ignore,does_not_compile
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

<span class="caption">リスト 10-21:  2つの文字列スライスのうち長い方を返すけれども、コンパイルできないlongest関数の実装</span>

代わりにライフタイムについて説明する、以下のエラーを受け取ります。

```text
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:33
  |
1 | fn longest(x: &str, y: &str) -> &str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
```

ヘルプテキストは、返されるリファレンスが`x`または`y`を参照するかどうかをRustが知ることができないため、戻り値の型がそれにジェネリックなライフタイム引数を必要とすることを示しています。実際には、この関数の本体の`if`ブロックは`x`への参照を返し、`else`ブロックは`y`への参照を返すので、どちらかわかりません。

この関数を定義するとき、この関数に渡される具体的な値はわからないので、`if`か`else`のどちらが実行されるかはわかりません。また、渡される参照の具体的なライフタイムもわからないため、リスト10-18および10-19で行ったようにスコープを見ることができず、返す参照が常に有効かどうかが判断されます。`x`と`y`のライフタイムが返り値の存続期間にどのように関係しているのか分からないので、借用精査機はこれを判断することができません。このエラーを修正するために、借用精査機が解析を実行できるよう、参照間の関係を定義するジェネリックなライフタイム引数を追加します。

### ライフタイム注釈記法

ライフタイム注釈はいかなる参照のライフタイムを変更しません。シグニチャがジェネリック型引数を指定するときに関数が任意の型を受け入れるのと同じように、関数はジェネリックなライフタイム引数を指定することで、任意のライフタイムの参照を受け入れることができます。ライフタイム注釈は、ライフタイムに影響を与えることなく、複数のリファレンスのライフタイムの相互関係を記述します。

生涯の注釈には少し珍しい構文があります。生涯引数の名前はアポストロフィ(`'`)で始まらなければならず、通常はジェネリック型のようにすべて小文字で非常に短いです。ほとんどの人は`'a`という名前を使用します。ライフタイム引数注釈は、参照の`&`の後に配置し、注釈と参照の型を区別するために空白を1つ使用します。

ここにいくつかの例があります。ライフタイム引数なしの`i32`への参照、`'a`というライフタイム引数付きの`i32`への参照、 同じくライフタイム`'a`付き`i32`への可変参照です。

```rust,ignore
&i32        // ただの参照
&'a i32     // 明示的なライフタイム付きの参照
&'a mut i32 // 明示的なライフタイム付きの可変参照
```

1つのライフタイム注釈それだけでは、大して意味はありません。ライフタイム注釈は、複数の参照のジェネリックなライフタイム引数が、 お互いにどう関係するかをコンパイラに指示することを意図しているからです。たとえば、ライフタイム`'a`付きの`i32`への参照となる引数`first`のある関数があるとしましょう。この関数にはさらに、`'a`のライフタイム付きの`i32`への別の参照となる`second`という別の引数もあります。ライフタイム注釈は、`first`と`second`の参照がどちらもジェネリックなライフタイムと同じだけ生きることを示唆します。

### 関数シグニチャにおけるライフタイム注釈

次に、`longest`関数の文脈でライフタイム注釈を調べてみましょう。ジェネリック型引数の場合と同様に、関数名と引数リストの間に山括弧で囲んだジェネリックなライフタイム引数を宣言する必要があります。このシグニチャで表現したい制約は、引数内のすべての参照と戻り値のライフタイムが同じでなければならないということです。リスト10-22に示すように、ライフタイムを `'a`という名前にして、それを各参照に追加します。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

<span class="caption">リスト10-22: シグニチャの全参照が同じライフタイム`'a`になると指定した`longest`関数の定義

</span>

このコードはコンパイルでき、リスト10-20の`main`関数とともに使用したら、欲しい結果になるはずです。

関数シグニチャは、なんらかのライフタイム`'a`に対して、関数は2つの引数を取り、どちらも少なくともライフタイム`'a`と同じだけ生きる文字列スライスであるとコンパイラに教えています。また、この関数シグニチャは、関数から返る文字列スライスも少なくともライフタイム`'a`と同じだけ生きると、コンパイラに教えています。これらの制約は、コンパイラに強制してほしいものです。この関数シグニチャでライフタイム引数を指定する時、渡されたり、返したりしたいかなる値のライフタイムも変更していないことを思い出してください。むしろ、借用精査機は、これらの制約を支持しない値全てを拒否するべきと指定しています。 `longest`関数は、正確に`x`と`y`の生存期間を知る必要はなく、何かのスコープが`'a`に代替され、 このシグニチャを満足することだけ知っている必要があることに注意してください。

関数のライフタイム注釈を付けるとき、注釈は関数の本体ではなく関数のシグニチャに入ります。Rustは、何の助けもなしに関数内のコードを分析することができます。しかし、ある関数がその関数の外にあるコードを参照したり、その関数の外にあるコードから参照を受け取ったりすると、Rustは引数のライフタイムや独自の戻り値を把握することがほとんど不可能になります。機能が呼び出されるたびにライフタイムが異なる場合があります。このため、ライフタイムに手動で注釈を付ける必要があります。

具体的な参照を`longest`に渡すと、`'a`に置き換えられる具体的なライフタイムは、`y`のスコープと被さる`x`のスコープの一部になります。言い換えると、ジェネリックなライフタイム`'a`は、`x`と`y`のライフタイムのうち、小さい方に等しい具体的なライフタイムになるのです。返却される参照を同じライフタイム引数`'a`で注釈したので、返却される参照も`x`か`y`のライフタイムの小さい方と同じだけ有効になるでしょう。

ライフタイム注釈がどのようにして具体的なライフタイムになる参照を渡すことで`longest`関数を制限する方法を見ましょう。リスト10-23は簡単な例です。

<span class="filename">ファイル名: src/main.rs</span>

```rust
# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

<span class="caption">リスト 10-23: 異なる具体的なライフタイムの`String`値への参照で`longest`関数を使用する</span>

この例では `string1`は外側スコープの終わりまで有効です。`string2`は内側スコープの終わりまで有効で、`result`は内側スコープの終わりまで有効なものを参照します。このコードを実行すると、借用精査機がこのコードを承認していることがわかります。コンパイルして実行すると`The longest string is long string is long`を出力します。

次に、`result`の参照のライフタイムが2つの引数のうちのより短いライフタイムでなければならないことを示す例を試してみましょう。`result`変数の宣言を内部スコープの外側に移動しますが、`string2`スコープ内の`result`変数にその値を代入します。 次に、内部スコープが終了した後、`scope`の外側に`result`を使用する`println!`を移動します。リスト10-24のコードはコンパイルされません。

<span class="filename">ファイル名: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

<span class="caption">リスト 10-24: `string2`がスコープを抜けてから`result`を使用しようとする</span>

このコードをコンパイルしようとすると、次のエラーが表示されます。

```text
error[E0597]: `string2` does not live long enough
  --> src/main.rs:15:5
   |
14 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
15 |     }
   |     ^ `string2` dropped here while still borrowed
16 |     println!("The longest string is {}", result);
17 | }
   | - borrowed value needs to live until here
```

このエラーは、`result`が`println!`文に対して有効になるために、`string2`が外側のスコープの終わりまで有効である必要があることを示しています。関数引数と戻り値のライフタイムを同じライフタイム引数`'a`で注釈したので、コンパイラはこのことを知っています。

人間からしたら、このコードを見て`string1`は`string`2よりも長いことが確認でき、そのため`result`は`string1`への参照を含んでいます。`string1`はまだスコープから外れていないので、`string1`への参照は`println!`ステートメントでも有効です。
しかし、コンパイラはこの場合参照が有効であることを認識できません。`longest`関数が返す参照の有効期間は、渡された参照の有効期間のうちの小さいものと同じであることをRustに告げました。したがって、借用精査機はリスト10-24のコードを無効な参照がある可能性があるとして許可しないのです。

試しに値や`longest`関数に渡される参照のライフタイムや返される参照の使用法が異なる実験をもっと企ててみてください。自分の実験がコンパイル前に借用精査機を通るかどうか仮説を立てて、それが正しいか確認してみてください。

### ライフタイムの観点で思考する

ライフタイム引数を指定する必要がある方法は、関数が何をしているかによって異なります。たとえば、最長の文字列スライスではなく最初の引数を常に返すように`longest`関数の実装を変更した場合、`y`引数で有効期間を指定する必要はないため、以下のコードがコンパイルされます。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

この例では、引数`x`と戻り値の型に対して`'a`というライフタイム引数を指定しましたが、引数`y`には指定していません。`y`のライフタイムは`x`や戻り値のライフタイムとは何の関係もないからです。

関数から参照を返す際、戻り値型のライフタイム引数は、引数のうちどれかのライフタイム引数と一致する必要があります。返される参照が引数のどれかを参照してい*なければ*、この関数内で生成された値を参照しているに違いなく、その値が関数の末端でスコープを抜けるので、ダングリング参照になるでしょう。コンパイルできないこの`longest`関数の試行された実装を考えてみましょう。

<span class="filename">ファイル名: src/main.rs</span>

```rust,ignore,does_not_compile
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

ここでは、戻り値の型としてライフタイム引数`'a`を指定していますが、戻り値の有効期間が引数のライフタイムにまったく関係しないため、この実装はコンパイルに失敗します。以下のようなエラーメッセージを受け取ります。

```text
error[E0597]: `result` does not live long enough
 --> src/main.rs:3:5
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the
function body at 1:1...
 --> src/main.rs:1:1
  |
1 | / fn longest<'a>(x: &str, y: &str) -> &'a str {
2 | |     let result = String::from("really long string");
3 | |     result.as_str()
4 | | }
  | |_^
```

問題は`result`が範囲外になり、`longest`関数の最後でクリーンアップされるということです。また、関数から`result`を返そうともしています。ダングリング参照を変えるであろうライフタイム引数を指定する手段はなく、コンパイラは、ダングリング参照を生成させてくれません。今回の場合、最善の修正案は、呼び出し元の関数が値のクリーンアップに責任を持てるよう、参照ではなく所有されたデータ型を返すことでしょう。

最終的に、ライフタイム構文は、さまざまな引数のライフタイムと関数の戻り値を結びつけることです。それらが接続されると、Rustはメモリセーフな操作を許可し、ダングリングポインタを作成したり、メモリの安全性に違反する操作を禁止するのに十分な情報を持っています。

### 構造体定義のライフタイム注釈

これまでは、所有している型を保持する構造体しか定義していませんでした。構造体が参照を保持することは可能ですが、その場合は構造体の定義内のすべての参照に生涯の注釈を追加する必要があります。リスト10-25には、文字列スライスを保持する `ImportantExcerpt`という名前の構造体があります。

<span class="filename">ファイル名: src/main.rs</span>

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.')
        .next()
        .expect("Could not find a '.'");
    let i = ImportantExcerpt { part: first_sentence };
}
```

<span class="caption">リスト 10-25: 参照を含む構造体なので、定義にライフタイム注釈が必要</span>

この構造体には参照用の文字列スライスを保持する1つのフィールド`part`があります。一般的なデータ型と同様に、構造体の名前の後ろに山形括弧の中にある一般的なライフタイム引数の名前を宣言して、構造体定義の本体でライフタイム引数を使用することができます。この注釈は、`ImportantExcerpt`のインスタンスが`part`フィールドに保持している参照を残存させることができないことを意味します。

`main`関数は変数`novel`が所有する`String`の最初の文に対する参照を保持する`ImportantExcerpt`構造体のインスタンスを生成します。`novel`のデータは` ImportantExcerpt`インスタンスが作成される前に存在します。さらに、`novel`は`ImportantExcerpt`が範囲外になるまで範囲外に出ないので、`ImportantExcerpt`インスタンスの参照は有効です。

### ライフタイム省略

すべてのリファレンスにはライフタイムがあり、参照を使用する関数や構造体にはライフタイム引数を指定する必要があることがわかりました。しかし、第4章ではリスト4-9の関数がありました。これはリスト10-26にもあり、ライフタイム注釈なしでコンパイルされています。

<span class="filename">ファイル名: src/lib.rs</span>

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

<span class="caption">リスト 10-26: 引数と戻り値型が参照であるにも関わらず、ライフタイム注釈なしでコンパイルできた リスト4-9で定義した関数</span>

この関数がライフタイム注釈なしでコンパイルできた理由は、歴史的なものです。昔のバージョンのRust(1.0以前)では、全参照に明示的なライフタイムが必要だったので、このコードはコンパイルできませんでした。その頃、関数シグニチャはこのように記述されていたのです。

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

多くのRustコードを書いた後、Rustチームは、Rustプログラマが特定の場面では、何度も何度も同じライフタイム注釈に入ることを発見しました。これらの場面は予測可能で、いくつかの決定的なパターンに従っていました。開発者はこのパターンをコンパイラのコードに落とし込んだので、このような場面には借用精査機がライフタイムを推論できるようになり、明示的な注釈を必要としなくなったのです。

他の決定的なパターンが出現し、コンパイラに追加されることもあり得るので、このRustの歴史は関係があります。将来的に、さらに少数のライフタイム注釈しか必要にならない可能性もあります。

コンパイラの参照解析に落とし込まれたパターンは、*ライフタイム省略規則*と呼ばれます。これらはプログラマが従う規則ではありません。コンパイラが考慮する一連の特定のケースであり、 自分のコードがこのケースに当てはまれば、ライフタイムを明示的に書く必要はなくなります。

*省略規則*は、完全な推論を提供しません。コンパイラが決定的に規則を適用できるけれども、参照がなるライフタイムに関してそれでも曖昧性があるなら、コンパイラは、残りの参照がなるべきライフタイムを推論しません。この場合、推論ではなく、コンパイラは、参照がお互いにどう関係するかを指定するライフタイム注釈を追記することで、解決できるエラーを与えます。


関数またはメソッドの引数の寿命は*入力ライフタイム*と呼ばれ、戻り値の寿命は*出力ライフタイム*と呼ばれます。

コンパイラは、3つのルールを使用して、明示的な注釈がない場合に参照されるライフタイムを把握します。第1のルールは入力ライフタイムに適用され、第2および第3のルールは出力ライフタイムに適用されます。コンパイラが3つのルールの終わりに達し、まだライフタイムがわからない参照がある場合、コンパイラはエラーで停止します。

これらの規則は、`fn`定義と`impl`ブロックに適用されます。

最初の規則は、参照である各引数は、独自のライフタイム引数を得るというものです。換言すれば、1引数の関数は、1つのライフタイム引数を得るということです（`fn foo<'a>(x: &'a i32)`）。また、2つ引数のある関数は、2つの個別のライフタイム引数を得ます（`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`）。以下も同様です。

2番目の規則は、1つだけ入力ライフタイム引数があるなら、そのライフタイムが全ての出力ライフタイム引数に代入されるというものです（`fn foo<'a>(x: &'a i32) -> &'a i32`）。

3番目の規則は、複数の入力ライフタイム引数があるけれども、メソッドなのでそのうちの一つが`&self`や`&mut self`だった場合、`self`のライフタイムが全出力ライフタイム引数に代入されるというものです。この3番目の規則により、必要なシンボルの数が減るので、メソッドが遥かに読み書きしやすくなります。

コンパイラになってみましょう。これらの規則を適用して、リスト10-26の`first_word`関数のシグニチャの参照のライフタイムが何か計算します。シグニチャは、参照に紐付けられるライフタイムがない状態から始まります。

```rust,ignore
fn first_word(s: &str) -> &str {
```

コンパイラは最初のルールを適用します。このルールは、各引数が独自のライフタイムを取得するように指定します。それを通常通り`'a`と呼ぶので、シグニチャはこれです。

```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```

1つだけ入力ライフタイムがあるので、2番目の規則を適用します。2番目の規則は、1つの入力引数のライフタイムが、出力引数に代入されると指定するので、シグニチャはこうなります。

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

もうこの関数シグニチャの全ての参照にライフタイムが付いたので、コンパイラは、プログラマにこの関数シグニチャのライフタムを注釈してもらう必要なく、解析を続行できます。

別の例を見てみましょう。リスト10-21で作業を開始したときにライフタイム引数を持たない`longest`関数を使用します。

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```

最初のルールを適用してみましょう。各引数は独自のライフタイムを取得します。今回は、1つではなく2つの引数があるため、2つのライフタイムがあります。

```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

2つ以上入力ライフタイムがあるので、2番目の規則は適用されないとわかります。また3番目の規則も適用されません。`longest`はメソッドではなく関数なので、どの引数も`self`ではないからです。3つのルールをすべて実行した後も、戻り値の型のライフタイムはまだわかりません。このため、リスト10-21のコードをコンパイルしようとしたときにエラーが発生しました。コンパイラはライフタイムの省略規則を処理しましたが、シグニチャ内の参照のライフタイムをすべて把握できませんでした。

3番目の規則は実際メソッドシグニチャでしか適用されないので、次にその文脈でライフタイムを観察し、3番目の規則が、メソッドシグニチャであまり頻繁にライフタイムを注釈しなくても済むことを意味する理由を確認します。

### メソッド定義におけるライフタイム注釈

構造体にライフタイムのあるメソッドを実装する際、リスト10-11に示すジェネリック型の引数と同じ構文を使用します。 ライフタイム引数を宣言して使用する場所は、構造体フィールド、メソッドの引数、および戻り値に関連しているかどうかによって異なります。

構造体フィールドのライフタイム名前は、`impl`キーワードの後に宣言し、構造体の型の一部であるため、構造体の名前の後に使用する必要があります。

`impl`ブロック内のメソッドシグニチャでは、参照は構造体のフィールド内の参照のライフタイムに縛られるか、独立している可能性があります。さらに、ライフタイム省略規則では、ライフタイム注釈がメソッドシグニチャに必要ないようにすることがよくあります。リスト10-25で定義した`ImportantExcerpt`という名前の構造体を使ったいくつかの例を見てみましょう。

まず、`level`という名前のメソッドを使います。このメソッドは`self`への参照であり、戻り値は`i32`です。これは何も参照していません。

```rust
# struct ImportantExcerpt<'a> {
#     part: &'a str,
# }
#
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

`impl`の後のライフタイム引数宣言と型名の後に使用する必要がありますが、最初の省略規則のために`self`への参照のライフタイムに注釈を付ける必要はありません。

3番目のライフタイム省略規則が適用される例を次に示します。

```rust
# struct ImportantExcerpt<'a> {
#     part: &'a str,
# }
#
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

2つ入力ライフタイムがあるので、コンパイラは最初のライフタイム省略規則を適用し、`&self`と`announcement`に独自のライフタイムを与えます。それから、引数の1つが`&self`なので、戻り値型は`&self`のライフタイムを得て、全てのライフタイムが説明されました。

### 静的ライフタイム

議論する必要のある1種の特殊なライフタイムが、`'static`であり、これはプログラム全体の期間を示します。文字列リテラルは全て`'static`ライフタイムになり、次のように注釈できます:

```rust
let s: &'static str = "I have a static lifetime.";
```

この文字列のテキストは、プログラムのバイナリに直接格納され、常に利用可能です。そのため、全文字列リテラルのライフタイムは、`'static`なのです。

エラーメッセージで`'static`ライフタイムを使用することを勧められることがある可能性があります。ですが、参照に対してライフタイムとして`'static`を指定する前に、今ある参照が本当にプログラムの全期間生きるかどうか考えてください。可能であっても、参照がそれだけの期間生きるかどうか考慮する可能性があります。ほとんどの場合、問題は、ダングリング参照を生成しようとしているか、利用可能なライフタイムの不一致が原因です。そのような場合、解決策はその問題を修正することであり、`'static`ライフタイムを指定することではありません。


## ジェネリックな型引数、トレイト境界、ライフタイムを一度に

ジェネリック型引数、トレイト境界、およびすべての関数を1つの関数で指定する構文を簡単に見てみましょう。

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

リスト10-22からの2つの文字列のうち長い方を返す`longest`関数ですが、ジェネリック型`T`の`ann`という追加の引数があり、これは`where`句で指定されているように、`Display`トレイトを実装するあらゆる型で埋めることができます。この追加の引数は、関数が文字列スライスの長さを比較する前に出力されるので、`Display`トレイト境界が必要なのです。ライフタイムは1種のジェネリックなので、ライフタイム引数`'a`とジェネリックな型引数`T`が関数名の後、山カッコ内の同じリストに収まっています。

## まとめ

この章で多くをカバーしました。ジェネリック型引数、トレイトとトレイト境界、およびジェネリックなライフタイム引数について知ったので、多くの異なる状況で動作する繰り返しなしでコードを書く準備が整いました。ジェネリック型の引数を使用すると、さまざまな型にコードを適用できます。トレイトとトレイト境界は、ジェネリックな型であっても、コードが必要とする動作を保証します。ライフタイム注釈を使用する方法を学び、この柔軟なコードにダングリング参照がないようにしました。この分析はすべてコンパイル時に実行されますが、実行時のパフォーマンスには影響しません。

信じるかどうかは自由ですが、この章で議論した話題にはもっともっと学ぶべきことがあります。第17章ではトレイトオブジェクトを議論し、これはトレイトを使用する別の手段です。第19章では、ライフタイム注釈が関わるもっと複雑な筋書きと何か高度な型システムの機能を講義します。次は、Rustでテストを書く方法を学ぶので、コードがあるべき通りに動いていることを確かめられます。