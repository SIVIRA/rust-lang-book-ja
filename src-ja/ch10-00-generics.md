# ジェネリック型、トレイト、ライフタイム

すべてのプログラミング言語には、概念の重複を効果的に処理するツールがあります。Rustにおいて、そのようなツールの1つが*ジェネリックス*です。ジェネリックスは、具体的な型やその他のプロパティの抽象的な代役です。コードを書くときは、ジェネリックスの振る舞いや、コードをコンパイルして実行するときに何が起きるのかを知ることなく、ジェネリックスの動作や他のジェネリックとの関係を表現できます。

関数が未知の値を持つ引数を複数の具体的な値で同じコードを実行する方法と同様に、関数は`i32`や`String`のような具体的な型の代わりにいくつかの汎用型の引数を取ることができます。実際に第6章で`Option<T>`、第8章で`Vec <T>`、`HashMap<K, V>`、第9章で`Result<T, E>`を既に使用しました。この章では、ジェネリックスで独自の型、関数、およびメソッドを定義する方法について説明します。

まず、コードの重複を減らす関数を抽出する方法を見ていきます。次に、同じテクニックを使用して、引数の型だけが異なる2つの関数から汎用的な関数を作成します。構造体と列挙型の定義でジェネリック型を使用する方法についても説明します。

次に、*トレイト*を使用して動作を汎用的な方法で定義する方法を学びます。型をジェネリック型と組み合わせることで、ジェネリック型を特定の振る舞いを持つ型だけに制限することができます。

最後に、*ライフタイム*について説明します。ライフタイムとは、コンパイラに参照がお互いにどう関係しているかの情報を与える1種のジェネリックスです。ライフタイムでは、多くの状況で値を借用することができ、コンパイラーは参照が有効であることを確認することを可能にします。

## 関数を抽出することで重複を取り除く

ジェネリックスの構文に入る前に、まず関数を抽出してジェネリック型を含まない重複を削除する方法を見てみましょう。次に、このテクニックを適用して汎用的な関数を抽出します。関数に重複したコードを抽出するのと同じ方法で、ジェネリックスを使用できる重複したコードを認識し始めます。

リスト10-1に示すように、リスト内で最大の数を見つける短いプログラムを考えてみましょう。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
#  assert_eq!(largest, 100);
}
```

<span class="caption">リスト 10-1: 数字のリストから最大値を求めるコード</span>

このコードは整数のリストを変数`number_list`に格納し、最初の数値を`most`という名前の変数にリストに格納します。次に、リスト内のすべての数値を繰り返し処理し、現在の数値が`largest`に格納されている数値よりも大きい場合は、その変数の数値を置き換えます。ただし、現在の数値がこれまでに見た最大数値よりも小さい場合、変数は変更されず、コードはリストの次の数値に移動します。リスト内のすべての数字を考慮した後、`largest`は最大の数字を保持します。この場合は100です。

2つの異なる数値リストで最大の数値を見つけるには、リスト10-1のコードを複製し、プログラムの2つの異なる場所で同じロジックを使用することができます（リスト10-2を参照）。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
```

<span class="caption">リスト 10-2: 2つの数値のリストから最大値を探すコード</span>

このコードは機能しますが、コードを複製するのは面倒でエラーが発生しやすいです。コードを変更したいときは、複数の場所でコードを更新する必要があります。

この重複を排除するために、与えられた整数リストに作用する関数を引数で定義して抽象化を作成することができます。この解決法は、コードをより明確にし、最も大きな数字を抽象的にリストするという概念を表現することができます。

コードリスト10-3では、`largest`という名前の関数に最大の番号を見つけるコードを抽出しました。リスト10-1のコードとは異なり、このプログラムは特定の1つのリストで最大の番号を見つけることができますが、このプログラムは2つの異なるリストで最大の番号を見つけることができます。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
#    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
#    assert_eq!(result, 6000);
}
```

<span class="caption">リスト 10-3: 2つのリストから最大値を探す抽象化されたコード</span>

`largest`関数には`list`という引数があります。この引数は関数に渡すことができる`i32`値の具体的なスライスを表します。 その結果、関数を呼び出すと、渡された特定の値でコードが実行されます。

まとめると、リスト10-2のコードをリスト10-3に変更するために取った手順は次のとおりです。

1. 重複したコードを特定する
2. 関数の本体に重複したコードを抽出し、その関数のシグニチャにそのコードの入力と戻り値を指定します
3. 代わりに関数を呼び出すように、重複したコードの2つのインスタンスを更新します。

次に、これらの同じ手順をジェネリックで使用して、コードの重複をさまざまな方法で減らします。関数本体が特定の値の代わりに抽象的な`list`で動作するのと同じように、ジェネリックスは抽象型でコードを操作できるようにします。

例えば、`i32`値のスライスの中で最大のものを見つける関数と`char`値のスライスの中で最大のものを見つけるものの2つの関数があります。その重複をどのように排除しますか？確認してみましょう。
