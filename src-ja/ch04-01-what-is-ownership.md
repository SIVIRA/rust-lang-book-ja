## 所有権とは何か？

Rustの中心的な特徴は*所有権*です。この機能は説明するのは簡単ですが、残りの言語には深い意味があります。

すべてのプログラムは、実行中にコンピュータのメモリを使用する方法を管理する必要があります。一部の言語では、プログラムの実行中にメモリが使用されなくなることを常に検出するガベージコレクションがあります。他の言語ではプログラマはメモリを明示的に割り当てて解放する必要があります。Rustは第3のアプローチを使用しています。メモリはコンパイル時にコンパイラがチェックする一連の規則を持つ所有権システムによって管理されます。所有権機能は、実行中にプログラムの速度を低下させるものではありません。

所有権は多くのプログラマーのための新しいコンセプトなので慣れるまでに時間がかかります。良い情報はRustとオーナーシップシステムのルールにもっと熟練すればするほど、安全かつ効率的なコードを自然に開発できるようになることです。

所有権を理解すると、Rustをユニークにする機能を理解するための強固な基盤が得られます。この章では、非常に一般的なデータ構造(文字列)に焦点を当てたいくつかの例を使って、所有権を学習します。

> ### スタックとヒープ
>
> 多くのプログラミング言語では、スタックとヒープについて非常に頻繁に考える必要はありません。しかし、Rustのようなシステムプログラミング言語では、値がスタック上にあるかヒープ上にあるかは、言語の振る舞いや特定の決定を下さなければならない理由に大きな影響を与えます。所有権の一部については、この章の後半でスタックとヒープに関連して説明しますので、ここでは簡単な説明をします。
>
> スタックとヒープは実行時にコードで使用できるメモリの一部ですがさまざまな方法で構造化されています。スタックは値を取得した順に値を格納し、逆の順序で値を削除します。これは*last in、first out*と呼ばれます。プレートのスタックを考えてみましょう。プレートを追加するときはプレートの上に置きプレートが必要なときはプレートを上から外します。中央や底からのプレートの追加や削除もうまくいかないでしょう。データの追加は*pushing onto the stack*、データの削除は*popping off the stack*と呼ばれます。
>
> スタックはデータにアクセスする方法が速いため高速です。新しいデータを置く場所やデータを取得する場所を検索する必要はありません。その場所は常に先頭にあるからです。スタックを高速化するもう1つの特性は、スタック上のすべてのデータが既知の固定サイズを占有しなければならないということです。
>
>コンパイル時にサイズが不明なデータまたは変更される可能性があるサイズのデータは代わりにヒープに格納できます。ヒープは組織化されていません。ヒープ上にデータを置くといくらかの容量を要求します。オペレーティングシステムは、ヒープ内のどこかに空きがあり、十分な大きさの空き領域を見つけ出し、使用中であるとマークし、その場所のアドレスである*ポインタ*を返します。このプロセスは、*ヒープ上での割り当て*と呼ばれ、時には単に「割り当て」と略されます。スタックに値をプッシュすることは、割り当てとはみなされません。ポインタは既知の固定サイズなので、スタックにポインタを格納することはできますが、実際のデータが必要な場合はポインタをたどらなければなりません。
>
> レストランに座っていると考えてください。あなたが入店するとグループの人の数を述べ、スタッフは人数に合う空のテーブルを見つけ案内します。あなたのグループの誰かが遅れて来たら、あなたを見つけるためにどこに座っているのかを聞くことができます。
>
> ヒープ内のデータへのアクセスは、そこに到達するためのポインタに従わなければならないため、スタック上のデータにアクセスするよりも時間がかかります。現代のプロセッサはメモリが少なくても飛び越えば高速になります。同様のことを続けると、多くのテーブルから注文を受けているレストランのサーバーを考えてみましょう。1つのテーブルですべての注文を取得してから次のテーブルに移動するのが最も効率的です。テーブルAからの注文を受けると、テーブルBからの注文、次にAからの注文、Bからの注文の順番はずっと遅くなります。同様に、プロセッサは、（ヒープ上にあるように）離れているのではなく、（スタック上にある）他のデータに近いデータで動作する場合、その仕事をより良くすることができます。ヒープ上に大量の領域を割り当てることも時間がかかることがあります。
>
> コードが関数を呼び出すと、関数に渡された値（ヒープ上のデータへのポインタを含む）と関数のローカル変数がスタックにプッシュされます。関数が終了すると、それらの値がスタックからポップされます。
>
> ヒープ上のどのデータを使用しているのかを追跡し、ヒープ上の重複データの量を最小限に抑え、ヒープ上の未使用データをクリーンアップしてスペースを使い果たしないようにすることは、 所有権を理解したら、スタックとヒープを頻繁に考える必要はありませんが、ヒープデータを管理することはオーナーシップが存在する理由で、なぜそれが動作するのかを説明するのに役立ちます。

### 所有権ルール

まず、所有権ルールを見てみましょう。 これらのルールを説明する例で作業するときは、これらのルールを念頭に置いてください。

> 1. Rustの各値には、*owner*という変数があります。
> 2. 一度に所有できるのは1人だけです。
> 3. 所有者が範囲外になるとその値は削除されます。

### 可変スコープ

2章ですでに書かれているRustプログラムの例を見てきました。`fn main() {`のコードは例に含まれていないので、次の例を `main`関数の中に手動で書かなければなりません。その結果、例は少し簡潔になり、定型コードではなく実際の詳細に焦点を当てることができます。

所有権の最初の例として、いくつかの変数の*scope*を見ていきます。有効範囲は項目が有効なプログラム内の範囲です。次のような変数があるとします。

```rust
let s = "hello";
```

変数`s`は文字列リテラルを参照しています。文字列の値はプログラムのテキストにハードコードされています。変数は宣言されているポイントから現在のスコープ*の終わりまで有効です。リスト4-1には変数`s`が有効な箇所に注釈を付けるコメントがあります。

```rust
{                      // s is not valid here, it’s not yet declared
    let s = "hello";   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid
```

<span class="caption">リスト 4-1: 変数とその有効範囲</span>

つまり、ここでは2つの重要なポイントがあります。

* `s`がスコープ*に来たとき*に有効です。
* *スコープ外*になるまで有効です。

この時点でスコープと変数が有効なときの関係は、他のプログラミング言語のそれと同様です。ここではこの理解の上に`String`型を導入して構築します。

### `String`型

所有権の規則を説明するには、第3章の「データ型」のセクションで説明したよりも複雑なデータ型が必要です。以前に説明した型はすべてスタックに格納されスコープ終了しましたが、ヒープに格納されているデータを調べRustがそのデータをいつクリーンアップするかを知りたいと考えています。

ここでは例として`String`を使用し、所有権に関連する`String`の部分に集中します。これらの側面は、標準ライブラリによって提供され、作成する他の複雑なデータ型にも適用されます。第8章では`String`について詳しく説明します。

文字列の値がプログラムにハードコードされている文字列リテラルは既に見てきました。文字列リテラルは便利ですが、テキストを使用したいあらゆる状況には適していません。1つの理由は、それらが不変であるということです。もう1つは、コードを書くときに文字列の値がすべてわかっているわけではないことです。たとえば、ユーザーの入力を受け取り、格納する場合はどうすればいいでしょうか？このような状況の場合、Rustは2番目の文字列型、`String`を持っています。この型はヒープ上に割り当てられ、コンパイル時にはわからない量のテキストを格納することができます。`from`関数を使って文字列リテラルから`String`を作ることができます：


```rust
let s = String::from("hello");
```

二重コロン(`::`)は、`string`型のような何らかの種類の名前を使うのではなく、`String`型の下でこの特定の`from`関数の名前空間を許す演算子です。この構文については、第5章の「メソッドの構文」の節と、第7章の「モジュールツリーの項目を参照するためのパス」のモジュールの名前空間について説明します。

この種の文字列は変更することが*できます*。

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() appends a literal to a String

println!("{}", s); // This will print `hello, world!`
```

では、違いは何ですか？なぜ`String`は突然変異することができますが、リテラルはできないのですか？違いは、これらの2つのタイプがメモリをどう扱うかです。

### メモリと割り当て

文字列リテラルの場合、コンパイル時に内容がわかるので、テキストは最終実行ファイルに直接ハードコードされます。これが、文字列リテラルが高速で効率的な理由です。しかし、これらのプロパティは文字列リテラルの不変性からのみ発生します。残念ながら、コンパイル時にサイズが不明で、プログラムの実行中にサイズが変更される可能性がある各テキストのバイナリには、一塊のメモリを入れることはできません。

`String`型では変更可能な拡張可能なテキストをサポートするために、コンパイル時には分からないヒープ上に、内容を保持するためのメモリ量を割り当てる必要があります。これの意味は、

* 実行時にオペレーティングシステムからメモリを要求する必要があります。
* `String`が終わったらこのメモリをオペレーティングシステムに返す方法が必要です。

最初の部分は自分たちの手で行われます。`String::from`を呼び出すとき、その実装は必要なメモリを要求します。これはプログラミング言語ではかなり普遍的です。

しかし、2つめの部分は異なります。*ガベージコレクタ（GC）*を持つ言語では、GCは使用されていないメモリを追跡してクリーンアップします。したがって、そのことについて考える必要はありません。GCがなければ、メモリが使用されなくなった時点を特定し、明示的に返すためにコードを呼び出すことは、自分が要求したのと同じです。これを正しく行うことは、歴史的にはプログラミング上の困難な問題でした。忘れてしまったら、メモリを浪費します。早すぎると無効な変数が返されます。それを2回行うとそれもバグになります。厳密に1つの`free`と正確に1つの`allocate`をペアにする必要があります。

Rustは別の方法をとります。それを所有する変数が範囲外になるとメモリは自動的に返されます。リスト4-1のスコープの例は、文字列リテラルの代わりに`String`を使用したものです：


```rust
{
    let s = String::from("hello"); // s is valid from this point forward

    // do stuff with s
}                                  // this scope is now over, and s is no
                                   // longer valid
```

`String`が必要とするメモリをオペレーティングシステムに返すことができる自然なポイントがあります。`s`が範囲外になるときです。変数がスコープから外れると、Rustは特別な関数を呼び出します。この関数は`drop`と呼ばれ、`String`の作成者がメモリを返すためのコードを置く場所です。 Rustは`}`の終了時に`drop`を自動的に呼び出します。

> 注：C ++ではアイテムの有効期間の終わりにリソースを解放するこのパターンは「リソース取得初期化（RAII）」と呼ばれることもあります。 RAIIパターンを使用していればRustの`drop`機能はなじみやすいでしょう。

このパターンはRustのコードが書き方に大きな影響を与えます。今のところ単純に思えるかもしれませんが、ヒープ上に割り当てたデータを複数の変数で使用したい場合、複雑な状況ではコードの動作が予期しないことがあります。これらの例のいくつか見てみましょう。

#### 変数とデータのやり取り方法：移動

複数の変数はRustの異なる方法で同じデータとやりとりすることができます。リスト4-2の整数を使用した例を見てみましょう。

```rust
let x = 5;
let y = x;
```

<span class="caption">リスト 4-2: 変数 `x`の整数値を` y`に代入する</span>

これが何をしているのかを推測することができます。「値'5'を` x`に束縛します。`x`の値のコピーを作り、これを`y`に束縛します」。xとyの2つの変数があり、両方とも` 5`になります。整数は既知の固定サイズの単純な値であり、これらの2つの'5'の値がスタックにプッシュされるということが、実際に起こっていることです。


次に `String`バージョンを見てみましょう。

```rust
let s1 = String::from("hello");
let s2 = s1;
```

これは前のコードと非常によく似ているので、同じように動作すると仮定します。つまり、2行目は`s1`の値のコピーを作成し、`s2`にバインドします。しかし、そうなりません。

図4-1を見て、カバーの下にある `String`に何が起こっているのかを見てください。`String`は左に示すように、文字列の内容、長さ、および容量を保持するメモリへのポインタの3つの部分で構成されています。このデータグループはスタックに格納されます。 右側には内容を保持するヒープ上のメモリがあります。

<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />

<span class="caption">図 4-1: "`hello`"が`s1`に束縛されている`String`のメモリ内の表現</span>

長さは、現在使用されている`String`の内容のバイト単位のメモリ量です。容量は、文字列がオペレーティングシステムから受け取った総メモリ量（バイト単位）です。長さと容量の違いは重要ですが、ここではそうではありません。今のところ容量を無視しても問題ありません。

`s1`を`s2`に割り当てると、`String`データがコピーされます。つまり、スタック上にあるポインタ、長さ、および容量をコピーします。ポインタが参照するヒープ上のデータはコピーしません。つまり、メモリ内のデータ表現は図4-2のようになります。

<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">図 4-2: `s1`のポインタ、長さ、および容量のコピーを持つ変数`s2`のメモリ内の表現</span>

この表現は、図4-3のようにはなりません。Rustがヒープデータを代わりにコピーした場合のメモリの様子です。Rustがこれを行った場合、ヒープ上のデータが大きかった場合、ランタイムパフォーマンスの点で`s2 = s1`操作は高価です。

<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">図 4-3: Rustがヒープデータを同様にコピーした場合`s2 = s1`とは別の可能性があります</span>

以前、変数がスコープから外れると、Rustは自動的に`drop`関数を呼び出し、その変数のヒープメモリをクリーンアップします。しかし、図4-2は、両方のデータポインタが同じ場所を指していることを示しています。これは問題です。`s2`と` s1`が範囲外になると、彼らは同じメモリを解放しようとします。これは*double free*エラーとして知られており、これまで説明したメモリの安全性のバグの1つです。メモリを2回解放するとメモリが破損し、セキュリティの脆弱性が発生する可能性があります。

メモリの安全性を確保するために、Rustのこの状況で何が起こるかについてもう少し詳しくみましょう。割り当てられたメモリをコピーしようとするのではなく、Rustは`s1`がもはや有効ではないと考え`s1`が有効範囲外になったときにRustは何も解放する必要はありません。`s2`が作成された後に`s1`を使用しようとすると何が起きるかを調べてください。それは動作しません。

```rust,ignore,does_not_compile
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

Rustは無効化された参照を使用できないため、次のようなエラーが発生します。

```text
error[E0382]: use of moved value: `s1`
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
```

他の言語で作業しているときに*shallow copy*と*deep copy*という言葉を聞いたことがあるならば、データをコピーせずにポインタ、長さ、容量をコピーするというコンセプトはshallow copyのように聞こえるでしょう。しかし、Rustは最初の変数を無効にするので、shallow copyと呼ばれる代わりに、*move*と呼ばれます。ここでは`s1`が`s2`に移されたといいます。実際に何が起こるかを図4-4に示します。

<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />

<span class="caption">図 4-4: `s1`の後のメモリ内の表現は無効にされました</span>

これで問題が解決されます。`s2`だけが有効で範囲外になるとそれだけでメモリが解放され完了です。

さらに、Rustは自動的にデータの「deep」copyを作成することはありません。したがって、*自動*コピーは、ランタイムパフォーマンスの点で安価であるとみなすことができます。

#### 変数とデータのやりとり方法：クローン

スタックデータだけでなく、`String`のヒープデータをdeep copyしたい場合は、`clone`という一般的なメソッドを使用することができます。第5章ではメソッド構文について説明しますが、メソッドは多くのプログラミング言語で共通の機能です。。

実際の `clone`メソッドの例を以下に示します。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

これは正常に動作し、ヒープデータがコピー*される*図4-3のような動作を明示的に生成します。

`clone`の呼び出しを見ると任意のコードが実行されていてコードが高価になることがあります。これは何か違うことが起こっているという視覚的な指標です。

#### スタックオンリーデータ：コピー

まだ説明していない別の問題があります。前述のコードリスト4-2の一部を示した整数を使用するこのコードは機能して有効です。

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

しかし、このコードはちょうど学んだことと矛盾しているようです。クローンを呼び出す必要はありませんが、`x`はまだ有効で`y`に移動しませんでした。

その理由はコンパイル時に既知のサイズを持つ整数などの型はスタック全体に格納されるため、実際の値のコピーはすばやく作成できるからです。つまり、変数`y`を作成した後`x`が有効にならないようにしたいという理由はありません。言い換えれば、ここではdeep copyとshallow copyの間に違いはないので `clone`を呼び出すことは、通常のshallow copyとは何も変わりません。

Rustにはスタックに格納されている整数のような型に置くことができる`Copy`トレイトという特殊なアノテーションがあります（第10章のトレイトについて詳しく説明します）。 型に `Copy`トレイトがある場合、割り当て後に古い変数を引き続き使用することができます。Rustは型またはその部分のいずれかが `Drop`トレイトを実装している場合、型に` Copy`トレイトを付けることはできません。値が範囲外になり、その型に `Copy`アノテーションを追加する際に型が特別なことを必要とする場合、コンパイル時エラーが発生します。自分のタイプに `Copy`アノテーションを追加する方法については、Appedix Cの「Derivable Traits」を参照してください。

どのようなタイプの `コピー`ですか？ 与えられた型のドキュメントを確かめることができますが、原則として、単純なスカラー値のグループは `Copy`であり、割り当てを必要とするものや何らかの形のリソースは`Copy`です。`Copy`であるいくつかの型があります。

* `u32`のようなすべての整数型。
* ブール型 `bool`は、値が` true`と `false`です。
* `f64`のようなすべての浮動小数点型。
* 文字型、`char`。
* タプル、それらが`Copy`である型だけを含む場合。たとえば、`（i32、i32）`は `Copy`ですが、`（i32、String）`はそうではありません。

### 所有権と機能

関数に値を渡すセマンティクスは、変数に値を代入するセマンティクスと同様です。変数に関数を渡すと、割り当てと同じように移動またはコピーされます。コードリスト4-3には、変数がスコープのどこに出入りするかを示すアノテーションの例があります。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

<span class="caption">リスト 4-3: 所有権とスコープがアノテーション付きの関数</span>

`takes_ownership`の呼び出しの後に`s`を使用しようとすると、Rustはコンパイル時エラーを投げます。これらの静的チェックは、間違いから守ります。`main`に`s`と`x`を使うコードを追加して、どこでそれらを使うことができるのか、そして所有権の規則がそうしないところを見てみてください。

### 戻り値と範囲

値を返すことで所有権を譲渡することもできます。リスト4-4は、リスト4-3のアノテーションと似たアノテーションを持つ例です。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function.
}

// takes_and_gives_back will take a String and return one.
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```

<span class="caption">リスト 4-4:戻り値の所有権の転送</span>

変数の所有権は毎回同じパターンに従います。別の変数に値を代入すると変数が移動します。ヒープ上のデータを含む変数が範囲外になると、データが別の変数によって所有されるように移動されていない限り値は`drop`によってクリーンアップされます。

所有権を取得してから、すべての機能で所有権を返すのはちょっと面倒です。関数に値を使用させ、所有権を持たせたくない場合はどうすればよいですか？渡したものも、関数本体から返されるデータに加えてそれを再び使用したい場合には戻す必要があるということはとても厄介です。

リスト4-5に示すように、タプルを使用して複数の値を返すことができます。

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```

<span class="caption">リスト 4-5: 引数の所有権を返す</span>

しかし、これはあまりにも多くの儀式であり、一般的でなければならないコンセプトのための多くの仕事です。幸いなことに、Rustには*references*というこのコンセプトの特徴があります。