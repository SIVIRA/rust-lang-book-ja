## `panic!`すべきかするまいか

では、`panic!`を呼ぶべきときと`Result`を返すべきときをどう決めるのでしょうか？コードがパニックすると、回復する方法はありません。復旧の可能性があるかどうかにかかわらず、エラー状況に応じて`panic!`を呼び出すことができますが、呼び出す側のコードの立場に立ってこの場面は回復不能だという決定を下すことになります。`Result`値を返すことを選択した場合、決断を下すのではなく、呼び出し側に選択肢を与えます。呼び出しコードは、状況に適した方法で回復しようとするか、この場合の`Err`値が回復不能であると判断して、`panic!`を呼び出して回復可能だったエラーを回復不能に変換することもできます。したがって、失敗する可能性のある関数を定義するときは、`Result`を返すのが良い選択です。

`Result`を返す代わりにパニックするコードを書く方が適切な場合がたまにあります。例やプロトタイプコード、テストでなぜパニックになるのが適切かを調べてみましょう。そして、コンパイラが失敗かどうかを人間のように考えることができない状況について話し合いましょう。この章では、ライブラリコードをパニックするかどうかを決定する方法に関する一般的なガイドラインを示します。

###例、プロトタイプコード、テスト

いくつかの概念を説明するための例を書くときには、堅牢なエラー処理コードを使用することで、この例をあまり明確にすることはできません。例では、`unwrap`のような、パニックに陥る可能性のあるメソッドへの呼び出しは、アプリケーションにエラーを処理してほしい方法へのプレースホルダーを意味していると理解され、残りのコードが何をしているかによって異なります。

同様に、`unwrap`と`expect`メソッドはエラーを処理する方法を決める準備が整う前のプロトタイプ作成時に非常に便利です。プログラムをより堅牢にする準備ができたときに、コードに明瞭なマーカーが残っているからです。

テストでメソッド呼び出しが失敗した場合、たとえそのメソッドがテスト中の機能ではなくても、テスト全体が失敗することが望しいです。`panic!`はテストが失敗としてマークされる方法であるため、`unwrap`や`expect`を呼び出すことはまさに何が起こるべきかです。

### コンパイラよりもプログラマがより情報を持っている場合

`Result`が`Ok`値を持つことを確実にする他のロジックがあるときに`unwrap`を呼び出すことも適切でしょうが、ロジックはコンパイラが理解できるものではありません。それでも、まだ処理しなければならない`Result`値を持っています。なぜなら、呼び出している処理が何であれ、自分の特定の場面では論理的に起こり得なくても、一般的にまだ失敗する可能性はあるからです。手動でコードを調査して`Err`バリアントは存在しないと確認できたら、`unwrap`を呼び出すことは完全に受容できることです。ここに例があります。

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1".parse().unwrap();
```

ハードコーディングされた文字列を解析することによって`IpAddr`インスタンスを作成しています。`127.0.0.1`は有効なIPアドレスであることがわかります。ここで` unwrap`を使用することは可能です。しかし、ハードコードされた有効な文字列を持っていても、`parse`メソッドの戻り値の型は変更されません。`Result`値が得られ、`Err`のように`Result`を処理します。コンパイラはこの文字列が常に有効なIPアドレスであることを知るほどスマートではないからです。IPアドレス文字列がプログラムにハードコードされているのではなく、失敗している可能性がある場合は、より堅牢な方法で`Result`を処理しなければなりません。

### エラー処理のガイドライン

コードが悪い状態になる可能性がある場合は、コードパニックを起こすことをお勧めします。この文脈において*悪い状態*は、無効な値、矛盾する値、欠損値がコードに渡されたり、次のうちの1つ以上が発生した場合など、いくつかの前提条件、保証、契約、または不変条件が破られた状態です。

* 悪い状態がときに起こるとは*想定*されないとき
* この時点以降、この悪い状態にないことを頼りにコードが書かれている場合
* 使用している型にこの情報をコード化するいい手段がないとき

誰かが自分のコードを呼び出して筋の通らない値を渡してきたら、最善の選択肢は`panic!`し、開発段階で修正できるように自分たちのコードにバグがあることをライブラリ使用者に通知することかもしれません。同様に自分の制御下にない外部コードを呼び出し、修正しようのない無効な状態を返すときに`panic!`はしばしば適切です。

しかし、失敗が予想されるときは、`panic!`呼び出しを行うよりも`Result`を返す方が適切です。例えば、不正なデータが与えられたパーサーやレート制限を超えたことを示すステータスを返すHTTPリクエストが含まれます。このような場合、`Result`を返すことは、呼び出し元コードがどのように処理するかを決定しなければならない可能性が高いことを示します。

コードが値に対して操作を実行するとき、コードは値が有効であることを確認し、値が有効でない場合はパニックにする必要があります。これは主に安全上の理由によるものです。不正なデータの処理を試みると、コードを脆弱性に晒す可能性があります。これは、境界外のメモリアクセスを試みると、標準ライブラリが `panic!`を呼び出す主な理由です。現在のデータ構造に属さないメモリにアクセスしようとするのはセキュリティ上の一般的な問題です。関数にはしばしば*契約*が伴います。入力が特定の要件を満たしている場合にのみその動作が保証されます。契約違反は常に呼び出し側のバグを示し、呼び出しコードで明示的に処理しなければならない種類のエラーではないため、契約違反時にパニックが発生します。実際、コードを呼び出すための合理的な方法はありません。呼び出し元の*プログラマ*はコードを修正する必要があります。関数の契約、特に違反がパニックの原因となる場合は、関数のAPIドキュメントで説明する必要があります。

しかし、すべての機能で多くのエラーチェックを行うと、冗長で煩わしいことです。幸いなことに、Rustの型システム(コンパイラが行う型チェック)を使用して、多くのチェックを行うことができます。関数にパラメータとして特定の型がある場合は、コンパイラが有効な値を持つことを既に確認していることを確認して、コードのロジックを進めることができます。例えば、`Option`ではなく型を持っているならば、プログラムは*何もない*ではなく*何かある*ことを想定します。そうするとコードは、`Some`と`None`バリアントの2つのケースを処理する必要はありません。それは確実に値を持つケースが1つしかありません。あなたの関数に何も渡そうとしないコードはコンパイルされないので、実行時にその関数をチェックする必要はありません。もう一つの例は`u32`のような符号なし整数型を使用して、パラメータが決して負でないことを保証するものです。

Rustの型システムを使用して有効な値をさらに確実に取得し、検証用のカスタム型を作成する方法を考えてみましょう。第2章の数あてゲームを思い出してください。このコードでは、1から100までの数字を推測するようにユーザーに求めました。その数字の間にユーザーの推測があることを確認してから、推測が肯定的であることを確認しました。この場合、その結果はそれほど悲惨ではありませんでした。「大きすぎ」、「小さすぎ」という結果は正しいでしょう。しかし、ユーザを有効な推測に導き、ユーザが範囲外の数字を推測したり、例えばユーザが文字を代わりに入力したりしたときに別の挙動をするようにしたら、有益な改善になるでしょう。

これを行う一つの方法は、ただの`u32`の代わりに`i32`として推測をパースし、負の数になる可能性を許可し、それから数字が範囲に収まっているというチェックを追加することです。

```rust,ignore
loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
    // --snip--
}
```

この`if`式は値が範囲外であるかどうかをチェックし、ユーザに問題を告通知し、`continue`を呼び出してループの次の繰り返しを始め、別の推測を求めます。`if`式の後、`guess`は1から100の間にあることを知って、秘密の数の比較を進めることができます。

しかし、これは理想的な解決策ではありません。プログラムが1〜100の値でしか動作しないことが絶対に重要で、この要件を持つ多くの機能を持っていれば、このようなチェックをすべての機能に持たせることは面倒でパフォーマンスにも影響を及ぼす可能性があります。

その代わりに新しい型を作成し、検証をどこにでも繰り返すのではなく型のインスタンスを作成する関数に入れることができます。そうすれば、関数が新しい型をシグネチャに使用し、受け取った値を確実に使用することは安全です。リスト9-10は、`new`関数が1と100の間の値を受け取った場合にのみ、`Guess`のインスタンスを生成する`Guess`型を定義する1つの方法を示しています：

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess {
            value
        }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

<span class="caption">リスト 9-10: 値が1から100の場合のみ処理を継続する`Guess`型</span>

まず、`u32`型のvalueをフィールドに持つ`Guess`という名前の構造体を定義しています。ここに数値が保管されます。

次に、`Guess`に`new`という名前の関数を実装して、`Guess`値のインスタンスを生成します。`new`関数は、`i32`型の`value`という1つのパラメータを持ち、`Guess`を返すように定義されています。`new`関数の本体にあるコードは`value`をテストして1から100の間であることを確認します。`value`がこのテストに合格しなかった場合、`panic!`呼び出しを行います。この範囲外の`value`を持つ`Guess`を作成すると`Guess::new`が依存している契約に違反するので、修正する必要があるバグがあるという呼び出しコードを書いています。`Guess::new`がパニックに陥るかもしれない条件は、公開されているAPIドキュメントで議論されるべきです。第14章で作成したAPIドキュメントに`panic!`の可能性を示すドキュメントの表記法について説明します。1valueがテスト1に合格した場合、`value`フィールドが`value`引数にセットされた新しいGuessを作成して返します。

次に、`self`を借用し、他のパラメータを持たず、`i32`を返す`value`というメソッドを実装します。この種のメソッドは、*ゲッター*と呼ばれることもあります。その目的は、フィールドからデータを取得して返すことです。`Guess`構造体の`value`フィールドがプライベートであるため、このパブリックメソッドは必要です。`value`フィールドはプライベートであることが重要です。`Guess`構造体を使用するコードは`value`を直接設定することはできません。モジュールの外側のコードは、`Guess::new`関数を使って `Guess`が`Guess::new`関数の条件でチェックされていない`value`を持つことができないようにします。

引数を一つ持つか、1から100の範囲の数値のみを返す関数はシグニチャで`u32`ではなく、`Guess`を取るか返し、本体内で追加の確認を行う必要はなくなります。

## まとめ

Rustのエラー処理機能は、プログラマがより頑健なコードを書く手助けをするように設計されています。`panic!`マクロは、プログラムが処理できない状態にあり、無効だったり不正な値で処理を継続するのではなく、プロセスに処理を中止するよう指示することを通知します。`Result`列挙型は、Rustの型システムを使用して、コードが回復可能な方法で処理が失敗するかもしれないことを示唆します。`Result`を使用して、呼び出し側のコードに成功や失敗する可能性を処理する必要があることも教えます。適切な場面で`panic!`や`Result`を使用することで、必然的な問題の眼前でコードの信頼性を上げてくれます。

ここまでで、標準ライブラリが`Option`や`Resul`列挙型などでジェネリクスを有効活用するところを目の当たりにしたので、ジェネリクスの動作法と自分のコードでの使用方法について語りましょう。
